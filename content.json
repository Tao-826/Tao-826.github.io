{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"未来都是从今天开始","date":"2022-11-06T02:40:25.000Z","updated":"2022-11-06T03:17:52.812Z","comments":false,"path":"index.html","permalink":"http://example.com/index.html","excerpt":"","text":"我们都希望可以心想事成，可是世事往往事与愿违。得之我幸，失之我命，事与愿违也要随遇而安。 也许这一刻的愿望落空正是为下一次愿望实现所做的铺垫，不要着急，顺其自然就好。 每当我非常渴望能够实现某个愿望时，这个愿望往往不会实现，甚至会留下一个糟糕的结果让我品尝失望的苦果。 有时我会怀疑自己是不是太贪心了，想要的太多，想要不属于我的东西，所以所有事与愿违都是理所当然的。 我也会怀疑自己是不是太倒霉了，才会承受这么多失望。我羡慕别人的幸运，似乎轻而易举地就能得到我渴望的东西，而我坚持和等待了许久依然一无所获。 渐渐地，我学会不再期盼愿望成真，用平静的心看待事情的发生和发展，贯彻“尽人事，听天命”的做法，做好心理准备接受任何可能的结果。 当期望少了，愿望实现时的喜悦加倍了，愿望落空时的失落缩减了。 那一刻，我突然明白，我并非过于贪心，或是倒霉，只是我没有面对失望方法罢了。 得不到，可能是不够努力，可能是时机不对，可能是方法不对，可能是……保持平常心，冷静地分析事与愿违的原因，记住教训，累积经验，然后放下失望，积极地面对当下的每一分每一秒，别再回头哀叹过往。 做最好的准备，做最坏的打算，事与愿违也要随遇而安。 塞翁失马焉知非福，有时候得不到不是一件坏事，也许是幸运的开始，所以因为不要沉溺在失望中错失幸运的机会。"},{"title":"分类","date":"2022-11-06T02:15:16.005Z","updated":"2022-11-06T02:15:16.005Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"初识(十二)","slug":"初识-十二","date":"2022-11-06T03:53:36.000Z","updated":"2022-11-06T03:56:44.889Z","comments":true,"path":"2022/11/06/初识-十二/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E5%8D%81%E4%BA%8C/","excerpt":"","text":"uni-app1. 开发工具1.1 安装 scss&#x2F;sass 编译https://ext.dcloud.net.cn/plugin?name=compile-node-sass 进入插件下载页面之后，点击使用 HBuilderX 导入插件 按钮进行自动安装 1.2 快捷键方案切换操作步骤：工具 -&gt; 预设快捷键方案切换 -&gt; VS 代码 1.3 修改编辑器的基本设置操作步骤：工具 -&gt; 设置 -&gt; 打开 Settings.json 按需进行配置 源码视图下可用的参考配置： 12345678910111213141516&#123; &quot;editor.colorScheme&quot;: &quot;Default&quot;, &quot;editor.fontSize&quot;: 12, &quot;editor.fontFamily&quot;: &quot;Consolas&quot;, &quot;editor.fontFmyCHS&quot;: &quot;微软雅黑 Light&quot;, &quot;editor.insertSpaces&quot;: true, &quot;editor.lineHeight&quot;: &quot;1.5&quot;, &quot;editor.minimap.enabled&quot;: false, &quot;editor.mouseWheelZoom&quot;: true, &quot;editor.onlyHighlightWord&quot;: false, &quot;editor.tabSize&quot;: 2, &quot;editor.wordWrap&quot;: true, &quot;explorer.iconTheme&quot;: &quot;vs-seti&quot;, &quot;editor.codeassist.px2rem.enabel&quot;: false, &quot;editor.codeassist.px2upx.enabel&quot;: false&#125; 1.4 目录结构123456789101112┌─components uni-app组件目录│ └─comp-a.vue 可复用的a组件├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置小程序的全局样式、生命周期函数等├─manifest.json 配置应用名称、appid、logo、版本等打包信息└─pages.json 配置页面路径、页面窗口样式、tabBar、navigationBar 等页面类信息 1.5 把项目运行到微信开发者工具在 manifestjson -&gt;微信小程序配置 -&gt; 填写自己的微信小程序的 AppID 在 HBuilderX 中 -&gt;工具 -&gt;设置 -&gt;运行配置 -&gt;配置“微信开发者工具”的安装路径 在微信开发者工具中，通过 面板，开启”微信开发者工具”的服务端口 在 HBuilderX 中，点击菜单栏中的 ，将当前 uni-app 项目编译之后，自动运行到微信开发者工具中，从而方便查看项目效果与调试，运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具 1.6 使用 Git 管理项目1.在项目根目录中新建 忽略文件，并配置如下：.gitignore 123# 忽略 node_modules 目录/node_modules/unpackage/dist 为了让 Git 能够正常追踪 unpackage 目录，按照惯例，我们可以在 unpackage 目录下创建一个叫做 的文件进行占位.gitkeep 2.打开终端，切换到项目根目录中，运行如下的命令，初始化本地 Git 仓库： 1git init 3.将所有文件都加入到暂存区： 1git add . 4.本地提交更新： 1git commit -m &quot;init project&quot; 2. 标签栏2.1 创建 tabBar 分支运行如下的命令，基于 master 分支在本地创建 tabBar 子分支，用来开发和 tabBar 相关的功能： 1234// 创建分支git checkout -b tabbar// 查看分支git branch 2.2 创建 选项卡栏 页面在 目录中，创建首页（home）、分类（cate）、购物车（cart）、我的（my） 这 4 个 tabBar 页面。在 HBuilderX 中，可以通过如下的两个步骤，快速新建页面：pages 在 目录上鼠标右键，选择新建页面pages 在弹出的窗口中，填写页面的名称、勾选 scss 模板之后，点击创建按钮。 2.3 配置 tabBar 效果修改项目根目录中的 pages.json 配置文件，新增 tabBar 的配置节点 12345678910111213141516171819202122232425262728293031&#123; &quot;tabBar&quot;: &#123; &quot;selectedColor&quot;: &quot;#C00000&quot;, &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/home/home&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;static/tab_icons/home.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tab_icons/home-active.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/cate/cate&quot;, &quot;text&quot;: &quot;分类&quot;, &quot;iconPath&quot;: &quot;static/tab_icons/cate.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tab_icons/cate-active.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/cart/cart&quot;, &quot;text&quot;: &quot;购物车&quot;, &quot;iconPath&quot;: &quot;static/tab_icons/cart.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tab_icons/cart-active.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/my/my&quot;, &quot;text&quot;: &quot;我的&quot;, &quot;iconPath&quot;: &quot;static/tab_icons/my.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tab_icons/my-active.png&quot; &#125; ] &#125;&#125; 2.4 删除默认的 index 首页 在 HBuilderX 中，把 pages 目录下的 index首页文件夹 删除掉 同时，把 page.json 中记录的 index 首页 路径删除掉 为了防止小程序运行失败，在微信开发者工具中，手动删除 pages 目录下的 index 首页文件夹 同时，把 components 目录下的 uni-link 组件文件夹 删除掉 2.5 修改导航条的样式效果 打开 pages.json 这个全局的配置文件 修改 globalStyle 节点如下： 12345678&#123; &quot;globalStyle&quot;: &#123; &quot;navigationBarTextStyle&quot;: &quot;white&quot;, &quot;navigationBarTitleText&quot;: &quot;黑马优购&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#C00000&quot;, &quot;backgroundColor&quot;: &quot;#FFFFFF&quot; &#125;&#125; 2.6 分支的提交与合并 将本地的 tabbar 分支进行本地的 commit 提交： 12git add .git commit -m &quot;完成了 tabBar 的开发&quot; 将本地的 tabbar 分支推送到远程仓库进行保存： 1git push -u origin tabbar 将本地的 tabbar 分支合并到本地的 master 分支： 12git checkout mastergit merge tabbar 删除本地的 tabbar 分支： 1git branch -d tabbar 3. 首页3.0 创建 home 分支运行如下的命令，基于 master 分支在本地创建 home 子分支，用来开发和 home 首页相关的功能： 1git checkout -b home 3.1 配置网络请求由于平台的限制，小程序项目中不支持 axios，而且原生的 wx.request() API 功能较为简单，不支持拦截器等全局定制的功能。因此，建议在 uni-app 项目中使用 @escook/request-miniprogram 第三方包发起网络数据请求。 请参考 @escook&#x2F;request-miniprogram 的官方文档进行安装、配置、使用 官方文档：https://www.npmjs.com/package/@escook/request-miniprogram 最终，在项目的 main.js 入口文件中，通过如下的方式进行配置： 1234567891011121314151617import &#123; $http &#125; from &#x27;@escook/request-miniprogram&#x27;uni.$http = $http// 配置请求根路径$http.baseUrl = &#x27;https://www.uinav.com&#x27;// 请求开始之前做一些事情$http.beforeRequest = function (options) &#123; uni.showLoading(&#123; title: &#x27;数据加载中...&#x27;, &#125;)&#125;// 请求完成之后做一些事情$http.afterRequest = function () &#123; uni.hideLoading()&#125; 3.2 轮播图区域3.2.1 请求轮播图的数据实现步骤： 在 data 中定义轮播图的数组 在 onLoad 生命周期函数中调用获取轮播图数据的方法 在 methods 中定义获取轮播图数据的方法 示例代码： 1234567891011121314151617181920212223242526272829export default &#123; data() &#123; return &#123; // 1. 轮播图的数据列表，默认为空数组 swiperList: [], &#125; &#125;, onLoad() &#123; // 2. 在小程序页面刚加载的时候，调用获取轮播图数据的方法 this.getSwiperList() &#125;, methods: &#123; // 3. 获取轮播图数据的方法 async getSwiperList() &#123; // 3.1 发起请求 const &#123; data: res &#125; = await uni.$http.get(&#x27;/api/public/v1/home/swiperdata&#x27;) // 3.2 请求失败 if (res.meta.status !== 200) &#123; return uni.showToast(&#123; title: &#x27;数据请求失败！&#x27;, duration: 1500, icon: &#x27;none&#x27;, &#125;) &#125; // 3.3 请求成功，为 data 中的数据赋值 this.swiperList = res.message &#125;, &#125;,&#125; 3.2.2 渲染轮播图的 UI 结构 渲染 UI 结构： 1234567891011121314&lt;template&gt; &lt;view&gt; &lt;!-- 轮播图区域 --&gt; &lt;swiper :indicator-dots=&quot;true&quot; :autoplay=&quot;true&quot; :interval=&quot;3000&quot; :duration=&quot;1000&quot; :circular=&quot;true&quot;&gt; &lt;!-- 循环渲染轮播图的 item 项 --&gt; &lt;swiper-item v-for=&quot;(item, i) in swiperList&quot; :key=&quot;i&quot;&gt; &lt;view class=&quot;swiper-item&quot;&gt; &lt;!-- 动态绑定图片的 src 属性 --&gt; &lt;image :src=&quot;item.image_src&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt;&lt;/template&gt; 美化 UI 结构： 1234567891011&lt;style lang=&quot;scss&quot;&gt;swiper &#123; height: 330rpx; .swiper-item, image &#123; width: 100%; height: 100%; &#125;&#125;&lt;/style&gt; 3.2.3 配置小程序分包 分包可以减少小程序首次启动时的加载时间 为此，我们在项目中，把 tabBar 相关的 4 个页面放到主包中，其它页面（例如：商品详情页、商品列表页）放到分包中。在 uni-app 项目中，配置分包的步骤如下： 在项目根目录中，创建分包的根目录，命名为 subpkg 在 pages.json 中，和 pages 节点平级的位置声明 subPackages 节点，用来定义分包相关的结构： 1234567891011121314151617181920212223242526&#123; &quot;pages&quot;: [ &#123; &quot;path&quot;: &quot;pages/home/home&quot;, &quot;style&quot;: &#123;&#125; &#125;, &#123; &quot;path&quot;: &quot;pages/cate/cate&quot;, &quot;style&quot;: &#123;&#125; &#125;, &#123; &quot;path&quot;: &quot;pages/cart/cart&quot;, &quot;style&quot;: &#123;&#125; &#125;, &#123; &quot;path&quot;: &quot;pages/my/my&quot;, &quot;style&quot;: &#123;&#125; &#125; ], &quot;subPackages&quot;: [ &#123; &quot;root&quot;: &quot;subpkg&quot;, &quot;pages&quot;: [] &#125; ]&#125; 在 subpkg 目录上鼠标右键，点击 新建页面 选项，并填写页面的相关信息： 3.2.4 点击轮播图跳转到商品详情页面将 &#96;&#96; 节点内的 view 组件，改造为 navigator 导航组件，并动态绑定 url 属性 的值。 改造之前的 UI 结构： 123456&lt;swiper-item v-for=&quot;(item, i) in swiperList&quot; :key=&quot;i&quot;&gt; &lt;view class=&quot;swiper-item&quot;&gt; &lt;!-- 动态绑定图片的 src 属性 --&gt; &lt;image :src=&quot;item.image_src&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/swiper-item&gt; 改造之后的 UI 结构： 123456&lt;swiper-item v-for=&quot;(item, i) in swiperList&quot; :key=&quot;i&quot;&gt; &lt;navigator class=&quot;swiper-item&quot; :url=&quot;&#x27;/subpkg/goods_detail/goods_detail?goods_id=&#x27; + item.goods_id&quot;&gt; &lt;!-- 动态绑定图片的 src 属性 --&gt; &lt;image :src=&quot;item.image_src&quot;&gt;&lt;/image&gt; &lt;/navigator&gt;&lt;/swiper-item&gt; 3.2.5 封装 uni.$showMsg() 方法当数据请求失败之后，经常需要调用 uni.showToast(&#123; /* 配置对象 */ &#125;) 方法来提示用户。此时，可以在全局封装一个 uni.$showMsg() 方法，来简化 uni.showToast() 方法的调用。具体的改造步骤如下： 在 main.js 中，为 uni 对象挂载自定义的 $showMsg() 方法： 12345678// 封装的展示消息提示的方法uni.$showMsg = function (title = &#x27;数据加载失败！&#x27;, duration = 1500) &#123; uni.showToast(&#123; title, duration, icon: &#x27;none&#x27;, &#125;)&#125; 今后，在需要提示消息的时候，直接调用 uni.$showMsg() 方法即可： ​ ​ ​ ​ ​ 12345async getSwiperList() &#123; const &#123; data: res &#125; = await uni.$http.get(&#x27;/api/public/v1/home/swiperdata&#x27;) if (res.meta.status !== 200) return uni.$showMsg() this.swiperList = res.message&#125; 3.3 分类导航区域3.3.1 获取分类导航的数据实现思路： 定义 data 数据 在 onLoad 中调用获取数据的方法 在 methods 中定义获取数据的方法 示例代码如下： 1234567891011121314151617181920export default &#123; data() &#123; return &#123; // 1. 分类导航的数据列表 navList: [], &#125; &#125;, onLoad() &#123; // 2. 在 onLoad 中调用获取数据的方法 this.getNavList() &#125;, methods: &#123; // 3. 在 methods 中定义获取数据的方法 async getNavList() &#123; const &#123; data: res &#125; = await uni.$http.get(&#x27;/api/public/v1/home/catitems&#x27;) if (res.meta.status !== 200) return uni.$showMsg() this.navList = res.message &#125;, &#125;,&#125; 3.3.2 渲染分类导航的 UI 结构 定义如下的 UI 结构： 123456&lt;!-- 分类导航区域 --&gt;&lt;view class=&quot;nav-list&quot;&gt; &lt;view class=&quot;nav-item&quot; v-for=&quot;(item, i) in navList&quot; :key=&quot;i&quot;&gt; &lt;image :src=&quot;item.image_src&quot; class=&quot;nav-img&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/view&gt; 通过如下的样式美化页面结构： 12345678910.nav-list &#123; display: flex; justify-content: space-around; margin: 15px 0; .nav-img &#123; width: 128rpx; height: 140rpx; &#125;&#125; 3.3.2 点击第一项，切换到分类页面 为 nav-item 绑定点击事件处理函数： 123456&lt;!-- 分类导航区域 --&gt;&lt;view class=&quot;nav-list&quot;&gt; &lt;view class=&quot;nav-item&quot; v-for=&quot;(item, i) in navList&quot; :key=&quot;i&quot; @click=&quot;navClickHandler(item)&quot;&gt; &lt;image :src=&quot;item.image_src&quot; class=&quot;nav-img&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/view&gt; 定义 navClickHandler 事件处理函数： 123456789// nav-item 项被点击时候的事件处理函数navClickHandler(item) &#123; // 判断点击的是哪个 nav if (item.name === &#x27;分类&#x27;) &#123; uni.switchTab(&#123; url: &#x27;/pages/cate/cate&#x27; &#125;) &#125;&#125; 3.4 楼层区域3.4.1 获取楼层数据实现思路： 定义 data 数据 在 onLoad 中调用获取数据的方法 在 methods 中定义获取数据的方法 示例代码如下： 1234567891011121314151617181920export default &#123; data() &#123; return &#123; // 1. 楼层的数据列表 floorList: [], &#125; &#125;, onLoad() &#123; // 2. 在 onLoad 中调用获取楼层数据的方法 this.getFloorList() &#125;, methods: &#123; // 3. 定义获取楼层列表数据的方法 async getFloorList() &#123; const &#123; data: res &#125; = await uni.$http.get(&#x27;/api/public/v1/home/floordata&#x27;) if (res.meta.status !== 200) return uni.$showMsg() this.floorList = res.message &#125;, &#125;,&#125; 3.4.2 渲染楼层的标题 定义如下的 UI 结构： 12345678&lt;!-- 楼层区域 --&gt;&lt;view class=&quot;floor-list&quot;&gt; &lt;!-- 楼层 item 项 --&gt; &lt;view class=&quot;floor-item&quot; v-for=&quot;(item, i) in floorList&quot; :key=&quot;i&quot;&gt; &lt;!-- 楼层标题 --&gt; &lt;image :src=&quot;item.floor_title.image_src&quot; class=&quot;floor-title&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/view&gt; 美化楼层标题的样式： 123456.floor-title &#123; height: 60rpx; width: 100%; display: flex;&#125; 3.4.3 渲染楼层里的图片 定义楼层图片区域的 UI 结构： 1234567891011121314&lt;!-- 楼层图片区域 --&gt;&lt;view class=&quot;floor-img-box&quot;&gt; &lt;!-- 左侧大图片的盒子 --&gt; &lt;view class=&quot;left-img-box&quot;&gt; &lt;image :src=&quot;item.product_list[0].image_src&quot; :style=&quot;&#123;width: item.product_list[0].image_width + &#x27;rpx&#x27;&#125;&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;!-- 右侧 4 个小图片的盒子 --&gt; &lt;view class=&quot;right-img-box&quot;&gt; &lt;view class=&quot;right-img-item&quot; v-for=&quot;(item2, i2) in item.product_list&quot; :key=&quot;i2&quot; v-if=&quot;i2 !== 0&quot;&gt; &lt;image :src=&quot;item2.image_src&quot; mode=&quot;widthFix&quot; :style=&quot;&#123;width: item2.image_width + &#x27;rpx&#x27;&#125;&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 美化楼层图片区域的样式： 1234567891011.right-img-box &#123; display: flex; flex-wrap: wrap; justify-content: space-around;&#125;.floor-img-box &#123; display: flex; padding-left: 10rpx;&#125; 3.4.4 点击楼层图片跳转到商品列表页 在 subpkg 分包中，新建 goods_list 页面 楼层数据请求成功之后，通过双层 forEach 循环，处理 URL 地址： 123456789101112131415// 获取楼层列表数据async getFloorList() &#123; const &#123; data: res &#125; = await uni.$http.get(&#x27;/api/public/v1/home/floordata&#x27;) if (res.meta.status !== 200) return uni.$showMsg() // 通过双层 forEach 循环，处理 URL 地址 res.message.forEach(floor =&gt; &#123; floor.product_list.forEach(prod =&gt; &#123; prod.url = &#x27;/subpkg/goods_list/goods_list?&#x27; + prod.navigator_url.split(&#x27;?&#x27;)[1] &#125;) &#125;) this.floorList = res.message&#125; 把图片外层的 view 组件，改造为 navigator 组件，并动态绑定 url 属性 的值： 1234567891011121314&lt;!-- 楼层图片区域 --&gt;&lt;view class=&quot;floor-img-box&quot;&gt; &lt;!-- 左侧大图片的盒子 --&gt; &lt;navigator class=&quot;left-img-box&quot; :url=&quot;item.product_list[0].url&quot;&gt; &lt;image :src=&quot;item.product_list[0].image_src&quot; :style=&quot;&#123;width: item.product_list[0].image_width + &#x27;rpx&#x27;&#125;&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt; &lt;/navigator&gt; &lt;!-- 右侧 4 个小图片的盒子 --&gt; &lt;view class=&quot;right-img-box&quot;&gt; &lt;navigator class=&quot;right-img-item&quot; v-for=&quot;(item2, i2) in item.product_list&quot; :key=&quot;i2&quot; v-if=&quot;i2 !== 0&quot; :url=&quot;item2.url&quot;&gt; &lt;image :src=&quot;item2.image_src&quot; mode=&quot;widthFix&quot; :style=&quot;&#123;width: item2.image_width + &#x27;rpx&#x27;&#125;&quot;&gt;&lt;/image&gt; &lt;/navigator&gt; &lt;/view&gt;&lt;/view&gt; 3.5 分支的合并与提交 将本地的 home 分支进行本地的 commit 提交： 123git add .git commit -m &quot;完成了 home 首页的开发&quot; 将本地的 home 分支推送到远程仓库进行保存： 12git push -u origin home 将本地的 home 分支合并到本地的 master 分支： 123git checkout mastergit merge home 删除本地的 home 分支： 1git branch -d home","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"http://example.com/tags/uni-app/"}]},{"title":"初识(十一)","slug":"初识-十一","date":"2022-11-06T03:53:29.000Z","updated":"2022-11-06T03:56:33.936Z","comments":true,"path":"2022/11/06/初识-十一/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E5%8D%81%E4%B8%80/","excerpt":"","text":"微信小程序1.小程序代码的构成1.1 项目的基本组成结构1.pages 用来存放所有小程序的页面，每个页面都是一个单独的文件夹 2.utils 用来存放工具性质的模块 3.app.js 整个小程序项目的入口文件 4.app.json 小程序项目的全局配置文件 5.app.wxss 小程序项目的全局样式文件 6.project.config.json 项目的配置文件 7.sitemap.json 用来配置小程序及其页面是否允许被微信索引 1.2 小程序页面的组成部分每个页面由 4 个基本文件组成，它们分别是： .js 文件（页面的脚本文件，存放页面的数据、事件处理函数等） .json 文件（当前页面的配置文件，配置窗口的外观、表现等） .wxml 文件（页面的模板结构文件） .wxss 文件（当前页面的样式表文件） 1.3 JSON 配置文件JSON 是一种数据格式，在实际开发中， JSON 总是以配置文件的形式出现。小程序项目中也不例外： 通过不同的 .json 配置文件，可以对小程序项目进行不同级别的配置。 小程序项目中有 4 种 json 配置文件，分别是： 项目根目录的 app.json 配置文件 项目根目录种的 project.config.json 配置文件 项目根目录中的 sitemap.json 配置文件 每个页面文件夹中的 .json 配置文件 1.4 app.json 配置文件app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部tab 等。 Demo 项目里边的 app.json 配置内容如下： pages ：用来记录当前小程序所有页面的路径 window ：全局定义 小程序所有页面的背景色、文字颜色等 style ：全局定义小程序组件所使用的样式版本 sitemapLocation ：用来指明 sitemap.json 的位置 1.5 project.config.json 配置文件project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置 setting: 保存了编译相关的配置 projectname: 保存的是项目名称 appid: 保存的是小程序的账号 ID project.config.json 更多的是对微信开发者工具的配置, 而 app.json 是对项目代码功能层面上的配置. 1.6 sitemap.json 配置文件微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO 。 sitemap.json 文件用来配置小程序页面是否允许微信索引。 当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。 注意： sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false。 1.7 页面的 .json 配置文件小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，页面中的配置项会覆盖 app.json 的 window 中相同的配置项, 当然, 这指的是当前页面被展示出来的时候。 1.8 新建小程序页面在 app.json-&gt;pages 中新增页面的存放路径，小程序开发中工具就可帮我们自动创建对应的页面文件 123456// app.json 快速创建文件 &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;, &quot;pages/***/***&quot; ], 1.9 修改项目首页只需要调整 app.json -&gt; pages 数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的页面，当作项目首页进行渲染。 1.10 WXMLWXML 是小程序框架的标签语言,用来构建小程序页面的结构，其作用类似于网页开发中的 HTML。他们主要存在下面几点的差别: 1.标签名不同 HTML（div） WXML(view, text, image, navigator) 2.属性节点不同 3.提供了类似于 vue 中的模板语法 数据绑定 列表渲染 条件渲染 1.11 WXSSWXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS 。他们主要存在下面几点的差别 ① 新增了 rpx 尺寸单位 CSS 中需要手动进行像素单位换算，例如 rem WXSS 在底层支持新的尺寸单位 rpx ，在不同大小的屏幕上小程序会自动进行换算 ② 提供了全局的样式和局部样式 项目根目录中的 app.wxss 会作用于所有小程序页面 局部页面的 .wxss 样式仅对当前页面生效 ③ WXSS 仅支持部分 CSS 选择器 .class 和 #id element 并集选择器、后代选择器 ::after 和 ::before 等伪类选择器 1.12 js 文件的分类小程序中的 JS 文件分为三大类，分别是： ① app.js: 是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序 ② 页面的 .js 文件: 是页面的入口文件，通过调用 Page() 函数来创建并运行页面 ③ 普通的 .js 文件: 是普通的功能模块文件，用来封装公共的函数或属性供页面使用 2. 小程序的宿主环境2.1 宿主环境宿主环境（host environment）指的是程序运行所必须的依赖环境。例如： Android 系统和 iOS 系统是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行 的，所以，Android 是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！ 小程序的宿主环境包含以下几部分内容 ① 通信模型 ② 运行机制 ③ 组件 ④ API 2.2 通信模型小程序中通信的主体是渲染层和逻辑层，其中： ① WXML 模板和 WXSS 样式工作在渲染层 ② JS 脚本工作在逻辑层 而所谓的通信模型指的是: ① 渲染层和逻辑层之间的通信 ② 逻辑层和第三方服务器之间的通信 这两部分的通信都是通过微信客户端进行转发 2.3 运行机制小程序的运行机制主要讲两部分 ① 小程序启动的过程 1.把小程序的代码包下载到本地 2.解析 app.json 全局配置文件 3.执行 app.js 小程序入口文件，调用 App() 创建小程序实例 4.渲染小程序首页 5.小程序启动完成 ② 某个页面渲染的过程 1.加载解析页面的 .json 配置文件 2.加载页面的 .wxml 模板和 .wxss 样式 3.执行页面的 .js 文件，调用 Page() 创建页面实例 4.页面渲染完成 3. 组件小程序中的组件也是由宿主环境提供的，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程 序的组 件分为了 9 大类，分别是： ① 视图容器 ② 基础内容 ③ 表单组件 ④ 导航组件 ⑤ 媒体组件 ⑥ map 地图组件 ⑦ canvas 画布组件 ⑧ 开放能力 ⑨ 无障碍访问 常用的有以下3个 3.1.view普通视图区域 类似于 HTML 中的 div，是一个块级元素 常用来实现页面的布局效果 12345&lt;view class=&quot;container1&quot;&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt; &lt;/view&gt; 12345678910111213.container1 &#123; display: flex; justify-content: space-around; align-items: flex-start; &#125;.container1 view &#123; width: 100px; height: 100px; line-height: 100px; text-align: center; background-color: yellowgreen; color: #fff; &#125; 3.2.scroll-view可滚动的视图区域 常用来实现滚动列表效果 1234567&lt;!-- scorll-y 允许纵向滚动 --&gt; &lt;!-- scorll-x 允许横向滚动 --&gt; &lt;scroll-view class=&quot;container1&quot; scroll-y&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt; &lt;/scroll-view&gt; 12345678910111213141516171819202122232425.container1 &#123; /* display: flex; justify-content: space-around; align-items: flex-start; */ border: 2px dashed lightgreen; /* 给父盒子添加固定高度，内部的元素就可以滚动 */ width: 100px; height: 130px; &#125;.container1 view &#123; width: 100px; height: 100px; line-height: 100px; text-align: center; color: #fff; &#125;.container1 view:nth-child(1) &#123; background-color: yellowgreen; &#125;.container1 view:nth-child(2) &#123; background-color: lightskyblue; &#125;.container1 view:nth-child(3) &#123; background-color: lightcoral; &#125; 3.3.swiper 和 swiper-item轮播图容器组件 和 轮播图 item 组件 123456789&lt;!-- 轮播图的结构 --&gt;&lt;swiper class=&quot;swiper-container&quot;&gt;&lt;!-- 第一个轮播图 --&gt;&lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;A&lt;/view&gt; &lt;/swiper-item&gt;&lt;!-- 第二个轮播图 --&gt;&lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;B&lt;/view&gt; &lt;/swiper-item&gt;&lt;!-- 第三个轮播图 --&gt;&lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;C&lt;/view&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; 1234567891011121314151617.swiper-container &#123; height: 150px; &#125;.item &#123; height: 100%; line-height: 150px; text-align: center; &#125;swiper-item:nth-child(1) .item &#123; background-color: lightcoral; &#125;swiper-item:nth-child(2) .item &#123; background-color: lightseagreen; &#125;swiper-item:nth-child(3) .item &#123; background-color: lightpink; &#125; swiper 还有其他相应的属性, 如下: indicator-dots 是否显示面板指示点 indicator-color 指示点颜色 indicator-active-color 激活指示点颜色 autoplay 是否自动切换 interval 自动切换时间间隔 circular 是否采用衔接滑动 3.4 text 组件和 rich-text 组件text 组件 文本组件 类似于 HTML 中的 span 标签，是一个行内元素 rich-text 组件 富文本组件 支持把 HTML 字符串渲染为 WXML 结构 通过 text 组件的 selectable 属性，实现长按选中文本内容的效果 1234&lt;!-- 只有在text组件中添加selectable 属性支持长按选中效果 --&gt;&lt;view&gt; &lt;text selectable&gt;手机号码支持长按选中效果：13333333333&lt;/text&gt;&lt;/view&gt; 通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构 12&lt;!-- rich-text组件中添加 nodes节点可以把 HTML 字符串渲染为对应的 UI 结构 --&gt; &lt;rich-text nodes=&quot;&lt;h1 style=&#x27;color: red;&#x27;&gt;标题&lt;/h1&gt;&quot;&gt; &lt;/rich-text&gt; 注意: 小程序默认是识别不了 HTML 的, 小程序默认只识别 WXML , 所以如果我们从服务器上获取到了包含HTML 字符串的数据, 并且想展示出来, 应该使用到 rich-text 组件的 nodes 属性。 3.5 button 组件button 是按钮组件,它的功能比 HTML 中的 button 按钮丰富,我们可以通过 open-type 属性可以调用 微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等） 123456789101112&lt;!-- 通过type属性指定按钮颜色类型 --&gt; &lt;button&gt;普通按钮&lt;/button&gt; &lt;button type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt; &lt;button type=&quot;warn&quot;&gt;警告按钮&lt;/button&gt; &lt;!-- 通过size属性指定按钮尺寸 --&gt; &lt;button size=&quot;mini&quot;&gt;普通按钮&lt;/button&gt; &lt;button size=&quot;mini&quot; type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt; &lt;button size=&quot;mini&quot; type=&quot;warn&quot;&gt;警告按钮&lt;/button&gt; &lt;!-- 通过plain属性指定按钮的镂空效果 --&gt; &lt;button plain&gt;普通按钮&lt;/button&gt; &lt;button plain type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt; &lt;button plain type=&quot;warn&quot;&gt;警告按钮&lt;/button&gt; 3.6 image 组件image 是图片组件(注意,不是 img 哦, 是 image ), 用来展示图片的, 它也是通过 src 属性来指明图片的路 径。 有一个属性叫做 mode , 它是用来控制图片的裁剪和缩放形式 scaleToFill ：(默认值)缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满image元素。 aspectFit：缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来可以完整的将图片显示出来。 aspectFill：缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来图片通常旨在水平或垂直方向是完整的，另一个方向将发生截取。 widthFix ：缩放模式，宽度不变，高度自动变化，保持原图宽高比不变。 heightFix ：缩放模式，高度不变，宽度自动变化，保持原图宽高比不变。 3.7 小程序API 的3大分类小程序中的 API 是由宿主环境提供的，通过这些丰富的小程序 API ，开发者可以方便的调用微信提供 的能力， 例如：获取用户信息、本地存储、支付功能等。 小程序 API 分为3大类, 分别是: ① 事件监听 API 特点：以 on 开头，用来监听某些事件的触发 举例： wx.onWindowResize(function callback) 监听窗口尺寸变化的事件 ② 同步 API 特点1：以 Sync 结尾的 API 都是同步 API 特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常 举例： wx.setStorageSync(‘key’, ‘value’) 向本地存储中写入内容 ③ 异步 API 特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调 用的结果 举例： wx.request() 发起网络数据请求，通过 success 回调函数接收数据 4. WXML 模板语法4.1 数据绑定小程序中, 数据绑定分为2个步骤: ① 在 data 中定义数据 ② 在 WXML 中使用数据 在 data 中定义页面的数据 在页面对应的 .js 文件中，把数据定义到 data 对象中即可 123456789101112Page(&#123; /** 页面的初始数据 */ data: &#123; info: &#x27;Hello World&#x27;, // 如果是短横线的形式声明数据，需要使用双引号包裹 &quot;user-name&quot;: &#x27;XX&#x27; , imgSrc: &#x27;xxxxxx&#x27;, randomNum: Math.random() * 10 // 生成 10 以内的随机数 &#125;, /** 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, &#125;) 2.在 WXML 中使用数据 把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来即可。 语法格式为: 12345&lt;!-- 插值表达式/大胡子语法 --&gt; &lt;view&gt;&#123;&#123; info &#125;&#125;&lt;/view&gt;&lt;!-- 动态绑定数据 --&gt; &lt;image src=&quot;&#123;&#123; imgSrc &#125;&#125;&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;&lt;view&gt; &#123;&#123; randomNum &gt;= 5 ? &#x27;数字大于或等于5&#x27; : &#x27;数字小于5&#x27; &#125;&#125; &lt;/view&gt; 4.2 事件绑定事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务 的处理。小程序中常用的事件如下： 类型: tap 绑定方法:bindtap 或 bind:tap 描述:手指触摸后马上离开，类似于 HTML 中的 click 事件 类型:input 绑定方法:bindinput 或 bind:input 描述:文本框的输入事件 类型:change 绑定方法:bindchange 或 bind:change 描述:状态改变时触发 当事件回调触发的时候，会收到一个事件对象 event ，它的详细属性如下表所示： 属性:type 类型:String 说明:事件类型 属性:timeStamp 类型:Integer 说明:页面打开到触发事件所经过的毫秒数 属性:target 类型:Object 说明:触发事件的组件的一些属性值集合 属性:currentTarget 类型:Object 说明:当前组件的一些属性值集合 属性:detail 类型:Object 说明:额外的信息 属性:touches 类型:Array 说明:触摸事件，当前停留在屏幕中的触摸点信息的数组 属性:changedTouches 类型:Array 说明:触摸事件，当前变化的触摸点信息的数组 关于 target 属性, 它经常会和 currentTarget 容易混淆 target 是触发该事件的源头组件 currentTarget 则是当前事件所绑定的组件 e.target 指向的是触发事件的源头组件，因此， e.target 是内部的按钮组件 e.currentTarget 指向的是当前正在触发事件的那个组件，因此， e.currentTarget 是当前的 view组件 4.2.1 bindtap 的使用① 通过 bindtap ，可以为组件绑定 tap 触摸事件 12345&lt;!-- tap触摸事件 --&gt; &lt;button type=&quot;primary&quot; bindtap=&quot;onHandleTap&quot;&gt;按钮&lt;/button&gt; &lt;!-- +1按钮的事件 --&gt; &lt;view class=&quot;countBox&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/view&gt; &lt;button bindtap=&quot;onAddHandle&quot;&gt;点我试试&lt;/button&gt; ② 在页面的 .js 文件中定义对应的事件处理函数，事件参数通过形参 event （一般简写成 e ） 来接收, 注意,事件处理函数需要和 data 平级。 12345678Page(&#123; data: &#123; &#125;, onHandleTap : function (e) &#123; // 事件对象e console.log(e); &#125;, onAddHandle: function () &#123; &#125;&#125;) 4.2.2 js 中访问 data 中的数据在 js 代码中, 如果想要访问 data中 的数据, 是通过 this.data.xxx 的方式进行访问 4.2.3 js 中修改 data 中的数据通过调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值 12345onAddHandle: function () &#123; this.setData(&#123; count: this.data.count + 1 // 在原来值基础上+1 &#125;) &#125; 4.2.4 事件传参小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。 我们可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字 123456&lt;!-- 事件传参 data-*自定义属性传参，*代表参数名字 info 会被解析为参数的数字 数值2 会被解析为参数的值 --&gt; &lt;button bindtap=&quot;onBtnString&quot; data-info=&quot;2&quot;&gt;事件传参-拼接字符串&lt;/button&gt; info 会作为名字存储在事件对象的 target 中的 dataset 中, 2 会被解析为值在事件处理函数中，通过 event.target.dataset.info 即可获取到值 1234567// 事件传参-拼接字符串 onBtnString (e) &#123; this.setData(&#123; // this.data.count就是旧值 count: this.data.count + e.target.dataset.info &#125;) &#125; 4.2.5 bindinput 的使用在小程序中，通过 input 事件来响应文本框的输入事件 ① 通过 bindinput ，可以为文本框绑定输入事件 1234&lt;view class=&quot;iptBox&quot;&gt; &lt;!-- input事件 --&gt; &lt;input class=&quot;ipt1&quot; bindinput=&quot;inputValue&quot; focus&gt;&lt;/input&gt; &lt;/view&gt; ② 在页面的 .js 文件中定义事件处理函数 1234inputValue (e) &#123; console.log(e); console.log(e.detail.value); &#125; 4.2.6 实现小程序中的双向数据绑定实现步骤： ① 定义数据 ② 渲染结构, 绑定 data 中的数据 ③ 美化样式 ④ 监听 input 事件 1234/** 页面的初始数据 */data: &#123; msg: &#x27;请输入...&#x27; &#125; 1234&lt;!-- 渲染结构：将data中的 msg 绑定到输入框的 value 属性 input和data中的数据同步-双向数据绑定 --&gt; &lt;view class=&quot;iptBox&quot;&gt; &lt;input value=&quot;&#123;&#123; msg &#125;&#125;&quot; bindinput=&quot;inputHandle&quot; class=&quot;ipt2&quot; type=&quot;checkbox&quot;&gt;&lt;/input&gt; &lt;/view&gt; 123456// 实现input的数据和data数据同步 inputHandle(e) &#123; this.setData(&#123; msg: e.detail.value &#125;) &#125; 4.3 条件渲染在小程序中，使用 wx:if&#x3D;”“ 来判断是否需要渲染该代码块 也可以配合 wx:elif 和 wx:else 来添加 else 判断： 1234&lt;!-- wx:if wx:else-if wx:else 条件渲染 --&gt; &lt;view wx:if=&quot;&#123;&#123; type === 1 &#125;&#125;&quot; class=&quot;text&quot;&gt;男&lt;/view&gt; &lt;view wx:elif=&quot;&#123;&#123; type === 2 &#125;&#125;&quot; class=&quot;text&quot;&gt;女&lt;/view&gt; &lt;view wx:else&gt;保密&lt;/view&gt; 如果要一次性控制多个组件的展示与隐藏，可以使用一个 标签将多个组件包装起来，并在标签上使用 wx:if 控制属性，使用block标签进行包裹，只是包裹性值，不会再页面渲染，类似于template 标签示例如下 12345&lt;block wx:if=&quot;&#123;&#123; true &#125;&#125;&quot;&gt; &lt;view&gt;显示&lt;/view&gt; &lt;view&gt;多个&lt;/view&gt; &lt;view&gt;组件&lt;/view&gt;&lt;/block&gt; 注意： 并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。 4.3.1 \u0001hidden在小程序中，直接使用 hidden&#x3D;”“ 也能控制元素的显示与隐藏 12&lt;!-- 使用 hidden=&quot;&#123;&#123; condition &#125;&#125;&quot; 也能控制元素的显示与隐藏 --&gt;&lt;view hidden=&quot;&#123;&#123; flag &#125;&#125;&quot;&gt;条件位 true 时，隐藏元素&lt;/view&gt; 4.3.2 wx:if 与 hidden 的对比① 运行方式不同 wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏 hidden 以切换样式的方式（ display: none&#x2F;block; ），控制元素的显示与隐藏 ② 使用建议 频繁切换时，建议使用 hidden 控制条件复杂时，建议使用 wx:if 搭配 wx:elif 、 wx:else 进行展示与隐藏的切换 4.4 列表渲染在小程序中, 可以通过 wx:for 指定数组，进行循环渲染重复的组件结构，语法示例如下： 123data: &#123; arr1: [ &#x27;苹果&#x27;, &#x27;华为&#x27;, &#x27;小米&#x27; ] &#125; 1234&lt;!-- 循环渲染模板语法 --&gt;&lt;view wx:for=&quot;&#123;&#123; arr1 &#125;&#125;&quot; class=&quot;text&quot;&gt; 索引是 &#123;&#123; index &#125;&#125; 当前项是： &#123;&#123; item &#125;&#125;&lt;/view&gt; 默认情况下，当前循环项的索引用 index 表示；当前循环项用 item 表示。 我们也可以手动指定索引和当前项的变量名 使用 wx:for-index 可以指定当前循环项的索引的变量名 使用 wx:for-item 可以指定当前项的变量名 1234&lt;!-- 手动指定索引和当前项的变量名 --&gt;&lt;view wx:for=&quot;&#123;&#123; arr1 &#125;&#125;&quot; class=&quot;text&quot; wx:for-index=&quot;i&quot; wx:for-item=&quot;item&quot;&gt; 索引是 &#123;&#123; i &#125;&#125; 当前项是： &#123;&#123; item &#125;&#125;&lt;/view&gt; 小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的 key 值，从而提高渲染的效率，示例代码如下 12345678&lt;!-- 手动指定索引和当前项的变量名 --&gt;&lt;view wx:key=&quot;index&quot; wx:for=&quot;&#123;&#123; arr1 &#125;&#125;&quot; class=&quot;text&quot; wx:for-index=&quot;i&quot; wx:for-item=&quot;item&quot;&gt; 索引是 &#123;&#123; i &#125;&#125; 当前项是： &#123;&#123; item &#125;&#125; &lt;/view&gt; &lt;!-- wx:key 提高渲染效率 --&gt; &lt;view wx:key=&quot;id&quot; wx:for=&quot;&#123;&#123; arr2 &#125;&#125;&quot; class=&quot;text1&quot;&gt; 当前项是： &#123;&#123; item.username &#125;&#125; &lt;/view&gt; 4.5 rpx4.5.1 什么是 rpx 尺寸单位rpx （ responsive pixel ）是微信小程序独有的，用来解决屏适配的尺寸单位。 4.5.2 rpx 的实现原理rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配， rpx 把所有设 备的屏幕，在宽度上等分为 750 份, 1份就是1 rpx , 所以: 在较小的设备上，1 rpx 所代表的宽度较小 在较大的设备上，1 rpx 所代表的宽度较大 小程序在不同设备上运行的时候，会自动把 rpx 的样式单位换算成对应的像素单位来渲染，从而实现 屏幕适配。 4.5.3 rpx 与 px 之间的单位换算在 iPhone6 上， CSS 像素屏幕宽度为375 px ，共有 750 个物理像素，等分为 750rpx 。则： 750 rpx &#x3D; 375 px &#x3D; 750 物理像素 1 rpx &#x3D; 0.5 px &#x3D; 1物理像素 5. 全局配置5.1 window导航栏 - 顶部导航栏区域 背景区 - 默认不可见，下拉才显示 页面主体区 - 页面主体用来显示 wxml 中的布局 12345678910111213141516&quot;window&quot;:&#123; // 下拉loading的样式，仅支持dark/light &quot;backgroundTextStyle&quot;:&quot;light&quot;, // 配置导航栏背景色,仅支持16进制的颜色 &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, // 导航栏标题文本 &quot;navigationBarTitleText&quot;: &quot;微信读书&quot;, // 导航栏标题颜色，仅支持 black/white &quot;navigationBarTextStyle&quot;:&quot;black&quot;, // 开启下拉刷新 &quot;enablePullDownRefresh&quot;: true, // 下拉窗口的背景色 &quot;backgroundColor&quot;: &quot;#efefef&quot;, // 上拉触底的距离：默认50像素，单位省去,我们会在触发了上拉触底事件时获取下一页的数据 &quot;onReachBottomDistance&quot;: 50&#125;, 5.2 tabBartabBar 是移动端应用常见的页面效果，用于实现多页面的快速切换。小程序中通常将其分为： 底部 tabBar 顶部 tabBar 注意：tabBar 中只能配置最少 2 个、最多 5 个 tab 页签，当渲染顶部 tabBar 时，不显示 icon ，只显示文本。 tabBar 的 6 个组成部分 ① backgroundColor ： tabBar 的背景色 ② selectedIconPath ：选中时的图片路径 ③ borderStyle：tabBar 上边框的颜色 ④ iconPath ：未选中时的图片路径 ⑤ selectedColor：tab 上的文字选中时的颜色 ⑥ color：tab 上文字的默认（未选中）颜色 5.2.1 tabBar 节点的配置项pagePath String 必填 页面路径，页面必须在pages中预先定义 test String 必填 tab上显示的文字 iconPath String 选填 未选中时的图片路径 selectedIconPath String 选填 选中时的图片路径 123456789101112131415&quot;tabBar&quot;: &#123; &quot;list&quot;: [ &#123; &quot;pagePath&quot;: &quot;pages/home/home&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;/images/tabs/home.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabs/home-active.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/message/message&quot;, &quot;text&quot;: &quot;消息&quot;, &quot;iconPath&quot;: &quot;/images/tabs/message.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabs/message-active.png&quot; &#125; &#125; 6.网络数据请求6.1 小程序中网络数据请求的限制出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下 两个限制： ① 只能请求 HTTPS 类型的接口 ② 必须将接口的域名添加到信任列表中 6.2 配置 request 合法域名需求描述：假设在自己的微信小程序中，希望请求 https://www.escook.cn/ 域名下的接口 配置步骤：登录微信小程序管理后台 -&gt; 开发 -&gt; 开发设置 -&gt; 服务器域名 -&gt; 修改 request 合法域名 注意事项： ① 域名只支持 https 协议 ② 域名不能使用 IP 地址或 localhost ③ 域名必须经过 ICP 备案 ④ 服务器域名一个月内最多可申请 5 次修改 6.3 发起 GET 请求调用微信小程序提供的 wx.request() 方法，可以发起 GET 数据请求，示例代码如下： 1234567891011121314151617// 发起GET请求 onTapGet () &#123; wx.request(&#123; // 请求地址，必须是以https://开头 // 必须是配置在request合法域名 url: &#x27;https://xxxxxx&#x27;, // 请求方式 method: &#x27;GET&#x27;, // 请求参数 data: &#123; name: &#x27;zs&#x27;, age: 22 &#125;, // 请求成功的回调 success: (res) =&gt; &#123; console.log(res) &#125; &#125;) 6.4 发起 POST 请求调用微信小程序提供的 wx.request() 方法，可以发起 GET 数据请求，示例代码如下： 1234567891011121314151617// 发起GET请求 onTapGet () &#123; wx.request(&#123; // 请求地址，必须是以https://开头 // 必须是配置在request合法域名 url: &#x27;https://xxxxxx&#x27;, // 请求方式 method: &#x27;POST&#x27;, // 请求参数 data: &#123; name: &#x27;zs&#x27;, age: 22 &#125;, // 请求成功的回调 success: (res) =&gt; &#123; console.log(res) &#125; &#125;) 6.5 在页面刚加载时请求数据在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的onLoad 事件中调用获取数据的函数，示例代码如下： 1234567/*** 生命周期函数--监听页面加载--初始化页面的数据 */ onLoad: function (options) &#123; // 通过 this 关键字 调用上述两个方法 // 可以自动发起请求，而不需要点击事件来触发 this.onTapGet() this.onTapPost() &#125;, 12345678910111213141516171819&lt;!--pages/home/home.wxml--&gt; &lt;!-- 轮播图区域 --&gt; &lt;swiper indicator-dots circular autoplay&gt; &lt;swiper-item wx:for=&quot;&#123;&#123; swiperList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;image src=&quot;&#123;&#123; item.image &#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;!-- 九宫格区域 --&gt; &lt;view class=&quot;gird-list&quot;&gt; &lt;view class=&quot;gird-item&quot; wx:for=&quot;&#123;&#123;girdList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;image src=&quot;&#123;&#123; item.icon &#125;&#125;&quot;&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123; item.name &#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 图片区域 --&gt; &lt;view class=&quot;img-box&quot;&gt; &lt;image src=&quot;/images/link-01.png&quot;&gt;&lt;/image&gt; &lt;image src=&quot;/images/link-02.png&quot;&gt;&lt;/image&gt; &lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142/* pages/home/home.wxss */ swiper &#123; height: 350rpx; &#125;swiper image &#123; width: 100%; height: 100%; &#125;.gird-list &#123; display: flex; flex-wrap: wrap; border-left: 1rpx solid #efefef; border-top: 1rpx solid #efefef; &#125;.gird-item &#123; display: flex; box-sizing: border-box; flex-direction: column; align-items: center; justify-content: center; border-right: 1rpx solid #efefef; border-bottom: 1rpx solid #efefef; width: 33.33%; height: 200rpx;&#125;.gird-item image &#123; width: 60rpx; height: 60rpx; &#125;.gird-item text &#123; font-size: 24rpx; margin-top: 10rpx;&#125;.img-box &#123; display: flex; justify-content: space-around; padding: 20rpx 10rpx; &#125;.img-box image &#123; width: 45%; height: 256rpx; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/*** 页面的初始数据 */ data: &#123; // 存放轮播图数据的列表 swiperList: [], // 存放九宫格的数据 girdList: [] &#125;,/*** 生命周期函数--监听页面加载 */onLoad: function (options) &#123; // 初始化页面，调用方法 this.getSwiperList() this.getGirdList() &#125;, // 获取轮播图数据的方法 getSwiperList () &#123; // 发起请求 wx.request(&#123; url: &#x27;https://xxx&#x27;, method: &#x27;GET&#x27;, success: (res) =&gt; &#123; // console.log(res) // 修改data中的数据 this.setData(&#123; swiperList: res.data &#125;) &#125; &#125;)&#125;,// 获取九宫格数据的方法getGirdList () &#123; wx.request(&#123; url: &#x27;https:xxx&#x27;, method: &#x27;GET&#x27;, success: (res) =&gt; &#123; // console.log(res) // 修改data中的数据 this.setData(&#123; girdList: res.data &#125;) &#125; &#125;) &#125;, 7. 首页导航7.1 声明式导航 导航到 tabBar 页面 tabBar 页面指的是被配置为 tabBar 的页面。 在使用 组件跳转到指定的 tabBar 页面时，需要指定 url 属性和 open-type 属性，其中： url 表示要跳转的页面的地址，必须以 &#x2F; 开头 open-type 表示跳转的方式，必须为 switchTab 123&lt;!-- 声明式导航 --&gt; &lt;!--导航到 tabBar页面的方法： url必须以“/”根路径开头 并且必须配置open-type属性值为switchTab --&gt; &lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt;导航到消息页面 &lt;/navigator&gt; 导航到非 tabBar 页面 非 tabBar 页面指的是没有被配置为 tabBar 的页面。 在使用 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中： url 表示要跳转的页面的地址，必须以 &#x2F; 开头 open-type 表示跳转的方式，必须为 navigate 为了方便, 非 tabBar 页码的跳转时 open-type 也可以省略 123&lt;!--导航到非tabBar页面 也就是没有被配置为tabBar的页面 url必须以“/”根路径开头 如果配置了open-type属性，值为navigate,也可省略不写 --&gt; &lt;navigator url=&quot;/pages/info/info&quot; open-type=&quot;navigate&quot;&gt;跳转到info页面 &lt;/navigator&gt; &lt;navigator url=&quot;/pages/info/info&quot; &gt;跳转到info页面&lt;/navigator&gt; 后退导航 如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中： open-type 的值必须是 navigateBack ，表示要进行后退导航 delta 的值必须是数字，表示要后退的层级 12&lt;!--后退导航 open-type属性值为：navigateBack 结合delta属性：表示后退的层级，默认为1，为1时该属性可省略不写 --&gt; &lt;navigator open-type=&quot;navigateBack&quot; delta=&quot;1&quot;&gt;后退&lt;/navigator&gt; &lt;navigator open-type=&quot;navigateBack&quot;&gt;后退&lt;/navigator&gt; 注意：为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1 tabBar 页面是不能实现后退的效果的. 因为, 当我们跳转到 tabBar 页面，会关闭其他所有非 tabBar 页面,所以当处于 tabBar 页面时, 无页面可退 7.2 编程式导航 导航到 tabBar 页面 调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下 属性 类型 是否必选 说明 url string 是 需要跳转的 tabBar 页面的路径，路径后不能带参数 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 12&lt;!--编程式导航 跳转至tabBar页面 --&gt; &lt;button bindtap=&quot;gotoMessage&quot;&gt;跳转到messae页面&lt;/button&gt; 1234567/*通过编程式导航 跳转至tabBar页面 message页面 */gotoMessage () &#123; wx.switchTab(&#123; // 代表要跳转的路径 url: &#x27;/pages/message/message&#x27;, &#125;) &#125;, 导航到非 tabBar 页面 调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。 其中 Object 参数对象的属性列表, 如下： 属性 类型 是否必选 说明 url string 是 需要跳转的 tabBar 页面的路径，路径后不能带参数 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 12&lt;!-- 编程式导航 跳转至非 tabBar页面 --&gt; &lt;button bindtap=&quot;gotoInfo&quot;&gt;跳转到Info页面&lt;/button&gt; 123456/*通过编程式导航 跳转至非tabBar页面 Info页面 */gotoInfo () &#123; wx.navigateTo(&#123; url: &#x27;/pages/info/info&#x27;, &#125;) &#125;, 后退导航 调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。 其中 Object 参数对象可选的, 属性列表如下： 属性 类型 是否必选 说明 delta number 是 返回的页面数，如果 delta 大于现有页面数，则返回到首页默认1 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 12&lt;!-- 通过编程式导航实现后退导航 --&gt;&lt;button bindtap=&quot;goBack&quot;&gt;编程式导航实现后退&lt;/button&gt; 123456/* 通过编程式导航实现后退导航*/goBack () &#123; // 如果不传递参数就是返回上一页 // 如果要传递参数则是传递 delta数字型， 代表返回的层级。 wx.navigateBack() &#125;, 注意： tabBar 页面是不能实现后退的效果的. 因为, 当我们跳转到 tabBar 页面，会关闭其他所有非 tabBar 页面,所以当处于 tabBar 页面时, 无页面可退 7.3 导航传参 声明式导航传参 navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数： 参数与路径之间使用 ? 分隔 参数键与参数值用 &#x3D; 相连 不同参数用 &amp; 分隔 12&lt;!--声明式导航传参 参数与路径之间使用 ? 分隔 参数键与参数值用 = 相连 不同参数用 &amp; 分隔 --&gt; &lt;navigator url=&quot;/pages/info/info?name=zs&amp;age=20&quot;&gt;跳转至info页面&lt;/navigator&gt; 编程式导航传参 调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数，代码示例如下 12&lt;!--编程式导航传参 --&gt;&lt;button bindtap=&quot;gotoInfo2&quot;&gt;跳转到info页面&lt;/button&gt; 123456/*编程式导航传递参数 */ gotoInfo2 () &#123; wx.navigateTo(&#123; url: &#x27;/pages/info/info?name=李&amp;gender=男&#x27;, &#125;) &#125;, 在 onLoad 中接收导航参数 通过声明式导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 事件中直接获取到 123456789101112131415/*** 页面的初始数据*/ data: &#123; // 导航传递的参数 query: &#123;&#125; &#125;, /*** 生命周期函数--监听页面加载 */onLoad: function (options) &#123; // 通过声明式导航和编程式导航 都可以 // 在onLoad声明周期函数中获取传递的参数 console.log(options); // 将导航传递的参数转存在data中 this.setData(&#123; query: options &#125;) &#125;, 8. 页面事件8.1 下拉刷新事件 什么是下拉刷新 下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行 为。 启用下拉刷新 启用下拉刷新有两种方式： ① 全局开启下拉刷新 在 app.json 的 window 节点中，将 enablePullDownRefresh 设置为 true ② 局部开启下拉刷新 在页面的 .json 配置文件中，将 enablePullDownRefresh 设置为 true 在实际开发中，推荐使用第 2 种方式，为需要的页面单独开启下拉刷新的效果。 配置下拉刷新窗口的样式 在全局或页面的 .json 配置文件中，通过 backgroundColor 和 backgroundTextStyle 来配置下拉 刷新窗口 的样式，其中： backgroundColor 用来配置下拉刷新窗口的背景颜色，仅支持16 进制的颜色值 backgroundTextStyle 用来配置下拉刷新 loading 的样式，仅支持 dark 和 light 监听页面的下拉刷新事件 在页面的 .js 文件中，通过 onPullDownRefresh() 函数即可监听当前页面的下拉刷新事件。 例如，在页面的 wxml 中有如下的 UI 结构，点击按钮可以让 count 值自增 +1 12&lt;view&gt; count的值为： &#123;&#123;count&#125;&#125; &lt;/view&gt;&lt;button bindtap=&quot;addCount&quot;&gt;+1&lt;/button&gt; 123456789101112Page(&#123; /** * 页面的初始数据 */ data: &#123; count: 0 &#125;, // 点击按钮 count自增加1事件 addCount () &#123; this.setData(&#123; count: this.data.count +1 &#125;) &#125; &#125;) 在触发页面的下拉刷新事件的时候，如果要把 count 的值重置为 0 123456789/*** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; // 触发了下拉刷新事件就会立即调用该方法 console.log(&quot;触发了下拉刷新&quot;); // 触发了下拉刷洗就将data中的count重置为0 this.setData(&#123; count: 0 &#125;) &#125;, 停止下拉刷新的效果 当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以需要手动隐藏下拉 刷新的loading 效果。此时，调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新。 12345678910111213/*** 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; wx.request(&#123; url: &#x27;&#x27;, method: &#x27;GET&#x27;, success: (res) =&gt; &#123; this.setData(&#123; XXX: res.data // 数值处理完毕，就可以关闭下拉刷新的事件了 wx.stopPullDownRefresh() &#125;) &#125; &#125;) &#125;, 8.2 上拉触底事件 什么是上拉触底 上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。 监听页面的上拉触底事件 在页面的 .js 文件中，通过 onReachBottom() 函数即可监听当前页面的上拉触底事件。 123456789/*** 页面上拉触底事件的处理函数 */onReachBottom: function () &#123; /*上拉触底事件不需要开启，直接监听就可以 在全局配置的window节点中或者页面的配置文件中可设置触底距离： 上拉触底的距离：默认50像素，单位省去,我们会在触发了上拉触底事件时获取下一页的数据 &quot;onReachBottomDistance&quot;: 50 */ console.log(&quot;触发了上拉触底事件&quot;); /*在上拉触底事件中，需要做节流处理 防止频繁触发该事件导致频繁发起请求 */ &#125;, 配置上拉触底距离 上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。 可以在全局或页面的 .json 配置文件中，通过 onReachBottomDistance 节点来配置上拉触底的距 离。小程序默认的触底距离是 50px ，在实际开发中，可以根据自己的需求修改这个默认值。 12&lt;!--pages/contact/contact.wxml--&gt;&lt;view class=&quot;num-item&quot; wx:for=&quot;&#123;&#123;colorList&#125;&#125;&quot; wx:key=&quot;index&quot; style=&quot;background-color: rgba(&#123;&#123;item&#125;&#125;);&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; 1234567891011/* pages/contact/contact.wxss */.num-item &#123; border: 1rpx solid #efefef; border-radius: 8rpx; line-height: 200rpx; height: 200rpx; margin: 15rpx; text-align: center; text-shadow: 0rpx 0rpx 5rpx #fff; box-shadow: 1rpx 1rpx 5rpx #efefef;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// pages/contact/contact.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; colorList: [], isLoading: false &#125;, getColor() &#123; // 展示loading wx.showLoading(&#123; title: &#x27;数据加载中...&#x27;, &#125;) // 开启节流阀 this.setData(&#123; isLoading: true &#125;) // 发起网络请求 wx.request(&#123; url: &#x27;https://applet-base-api-t.itheima.net/api/color&#x27;, success: (&#123; data: res &#125;) =&gt; &#123; console.log(res); this.setData(&#123; // 使用展开运算符获取到每一个数据，再将数据进行拼接 colorList: [...this.data.colorList, ...res.data] &#125;) &#125;, // 无论成功与否都会调用该方法 complete: () =&gt; &#123; // 隐藏loading效果 wx.hideLoading() // 关闭节流阀 this.setData(&#123; isLoading: false &#125;) &#125; &#125;) &#125;, /** * 生命周期函数--监听页面加载 */ onLoad(options) &#123; this.getColor() &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom() &#123; if (this.data.isLoading) return this.getColor() &#125;, 9. 生命周期9.1 生命周期函数的分类小程序中的生命周期函数分为两类，分别是： ① 应用的生命周期函数 特指小程序从启动 -&gt; 运行 -&gt; 销毁期间依次调用的那些函数 ② 页面的生命周期函数 特指小程序中，每个页面从加载 -&gt; 渲染 -&gt; 销毁期间依次调用的那些函数 小程序的应用生命周期函数需要在 app.js 中进行声明 123456789101112/*** 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） */onLaunch: function () &#123; console.log(&quot;onLaunch&quot;) &#125;,/*** 当小程序启动，或从后台进入前台显示，会触发 onShow * 前台：手机打开该小程序就处于前台运行 * 后台：手机回到主页，且未关闭小程序，此时小程序就处于后台运行 */onShow: function (options) &#123; console.log(&quot;onShow&quot;)&#125;,/*** 当小程序从前台进入后台，会触发 onHide */onHide: function () &#123; console.log(&quot;onHide&quot;)&#125;, 小程序的页面生命周期函数需要在页面的 .js 文件中进行声明 12345678910/*** 生命周期函数--监听页面加载,一个页面只调用一次 */onLoad: function (options) &#123; &#125;,/*** 生命周期函数--监听页面初次渲染完成，一个页面只调用一次 */onReady: function () &#123; &#125;,/*** 生命周期函数--监听页面显示 */onShow: function () &#123; &#125;,/*** 生命周期函数--监听页面隐藏 */onHide: function () &#123; &#125;,/*** 生命周期函数--监听页面卸载，一个页面只调用一次 */onUnload: function () &#123; &#125;, 10.wxs10.1 wxs 的应用场景wxml 中无法调用在页面的 .js 中定义的函数（不包括事件绑定），但是， wxml 中可以调用 wxs 中 定义的函数。因此，小程序中 wxs 的典型应用场景就是“过滤器”。 10.2 wxs 和 JavaScript 的关系虽然 wxs 的语法类似于 JavaScript ，但是 wxs 和 JavaScript 是完全不同的两种语言： ① wxs 有自己的数据类型 number 数值类型、 string 字符串类型、 boolean 布尔类型、 object 对象类型、 function 函数类型、 array 数组类型、 date 日期类型、 regexp 正则 ② wxs 不支持类似于 ES6 及以上的语法形式 不支持： let 、 const 、解构赋值、展开运算符、箭头函数、对象属性简写、etc… 支持： var 定义变量、普通 function 函数等类似于 ES5 的语法 ③ wxs 遵循 CommonJS 规范 module 对象 require() 函数 module.exports 对象 10.3 基础语法 内嵌 wxs 脚本 wxs 代码可以编写在 wxml 文件中的 标签内，就像 Javascript 代码可以编写在 html 文件中的 标 签内一样。 wxml 文件中的每个 标签，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在 wxml 中访问模块中的成员： 123456789&lt;!-- 定义一个文本，调用wxs中的方法 --&gt;&lt;view&gt;&#123;&#123; m1.toUpper(username) &#125;&#125;&lt;/view&gt;&lt;!-- 定义一个wxs的标签，并指定module模块名称 --&gt;&lt;wxs module=&quot;m1&quot;&gt; &lt;!-- 向外暴露一个方法 --&gt; module.exports.toUpper = function(str) &#123; return str.toUpperCase() &#125; &lt;/wxs&gt; 外联的 wxs 脚本 wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 Javascript 代码可以编写在以 .js 为后缀名的文件中一样。 12345678// 1.定义方法 function toLower(str) &#123; return str.toLowerCase() &#125;// 2.暴露成员 module.exports = &#123; toLower: toLower &#125; 在 wxml 中引入外联的 wxs 脚本时，必须为 标签添加 module 和 src 属性，其中： module 用来指定模块的名称 src 用来指定要引入的脚本的路径，且必须是相对路径 1234&lt;!-- 1.使用外联式引入外部的wxs文件 --&gt;&lt;wxs module=&quot;m2&quot; src=&quot;../../utils/tools.wxs&quot;&gt;&lt;/wxs&gt; &lt;!-- 2.调用 m2 模块的方法 --&gt;&lt;view&gt;&#123;&#123; m2.toLower(country) &#125;&#125;&lt;/view&gt; 10.4 WXS 的特点 与 JavaScript 不同 为了降低 wxs （ WeiXin Script ）的学习成本， wxs 语言在设计时借大量鉴了 JavaScript 的语 法。但是本质上， wxs 和 JavaScript 是完全不同的两种语言！ 不能作为组件的事件回调 wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用，例如： 但是，在 wxs 中定义的函数不能作为组件的事件回调函数。例如，下面的用法是错误的： 隔离性 隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的。体现在如下两方面： ① wxs 不能调用 js 中定义的函数 ② wxs 不能调用小程序提供的 API 性能好 在 iOS 设备上，小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍 在 Android 设备上，二者的运行效率无差异 12345678910111213141516171819&lt;!--pages/home/home.wxml--&gt;&lt;!-- 轮播图 --&gt;&lt;swiper indicator-dots circular autoplay&gt; &lt;swiper-item wx:for=&quot;&#123;&#123; swiperList &#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;image src=&quot;&#123;&#123;item.image&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/swiper-item&gt;&lt;/swiper&gt;&lt;!-- 九宫格 --&gt;&lt;view class=&quot;gird-list&quot;&gt; &lt;navigator class=&quot;gird-item&quot; wx:for=&quot;&#123;&#123;girdList&#125;&#125;&quot; wx:key=&quot;id&quot; url=&quot;/pages/shopList/shopList?id=&#123;&#123;item.id&#125;&#125;&amp;title=&#123;&#123;item.name&#125;&#125;&quot;&gt; &lt;image src=&quot;&#123;&#123;item.icon&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;/navigator&gt;&lt;/view&gt;&lt;!-- 图片 --&gt;&lt;view class=&quot;img-box&quot;&gt; &lt;image src=&quot;/images/link-01.png&quot;&gt;&lt;/image&gt; &lt;image src=&quot;/images/link-02.png&quot;&gt;&lt;/image&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// pages/home/home.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; swiperList: [], girdList: [] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad(options) &#123; this.getSwiperList() this.getGirdList() &#125;, /** * 轮播图 */ getSwiperList() &#123; wx.request(&#123; url: &#x27;https://applet-base-api-t.itheima.net/slides&#x27;, success: (res) =&gt; &#123; this.setData(&#123; swiperList: res.data &#125;) &#125; &#125;) &#125;, /** * 九宫格 */ getGirdList() &#123; wx.request(&#123; url: &#x27;https://applet-base-api-t.itheima.net/categories&#x27;, success: (res) =&gt; &#123; this.setData(&#123; girdList: res.data &#125;) wx.stopPullDownRefresh() &#125; &#125;) &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh() &#123; this.getGirdList() &#125;&#125;) 12345678910111213// pages/shopList/shopList.wxml&lt;view wx:for=&quot;&#123;&#123;shopList&#125;&#125;&quot; wx:key=&quot;index&quot; class=&quot;shop-item&quot;&gt; &lt;view class=&quot;thumb&quot;&gt; &lt;image src=&quot;&#123;&#123;item.images[0]&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&quot;info&quot;&gt; &lt;text class=&quot;shop-title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;text&gt;电话：&#123;&#123;tools.splitPhone(item.phone)&#125;&#125;&lt;/text&gt; &lt;text&gt;地址：&#123;&#123;item.address&#125;&#125;&lt;/text&gt; &lt;text&gt;营业时间：&#123;&#123;item.businessHours&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt;&lt;wxs module=&quot;tools&quot; src=&quot;../../utils/tools.wxs&quot;&gt;&lt;/wxs&gt; 1234567891011121314151617181920212223242526272829303132333435/* pages/shopList/shopList.wxss */page &#123; background: #efefef;&#125;.shop-item &#123; display: flex; padding: 15rpx; margin: 15rpx; border: 1px solid #efefef; border-radius: 10rpx; background: #fff; box-shadow: 1rpx 1rpx 15rpx #ddd;&#125;.thumb image &#123; width: 250rpx; height: 250rpx; display: block; margin-right: 10rpx;&#125;.info &#123; margin-left: 10rpx; display: flex; flex-direction: column; justify-content: space-between; font-size: 24rpx; /* font-weight: 700; */&#125;.shop-title &#123; /* font-size: 32rpx; */ font-weight: 700;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// pages/shopList/shopList.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; query: &#123;&#125;, shopList: [], page: 1, pageSize: 10, total: 0, isLoading: false &#125;, getShopList() &#123; wx.showLoading(&#123; title: &#x27;数据加载中...&#x27;, &#125;) this.setData(&#123; isLoading: true &#125;) wx.request(&#123; url: `https://applet-base-api-t.itheima.net/categories/$&#123;this.data.query.id&#125;/shops`, method: &#x27;GET&#x27;, data: &#123; _page: this.data.page, _limit: this.data.pageSize &#125;, success: (res) =&gt; &#123; this.setData(&#123; shopList: [...this.data.shopList, ...res.data], total: res.header[&#x27;X-Total-Count&#x27;] - 0, &#125;) wx.stopPullDownRefresh() &#125;, complete: () =&gt; &#123; wx.hideLoading() this.setData(&#123; isLoading: false &#125;) &#125; &#125;) &#125;, /** * 生命周期函数--监听页面加载 */ onLoad(options) &#123; this.setData(&#123; query: options &#125;) this.getShopList() &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady() &#123; wx.setNavigationBarTitle(&#123; title: this.data.query.title, &#125;) &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh() &#123; this.setData(&#123; // 重置页码为1 page: 1, // 清空原有数据，否则我们获取的数据会被追加在末尾 shopList: [], // 清空总数 total: 0 &#125;) this.getShopList() &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom() &#123; if (this.data.shopList.length &gt;= this.data.total) return wx.showToast(&#123; title: &#x27;没有更多了...&#x27;, icon: &#x27;none&#x27; &#125;) if (this.data.isLoading) return this.setData(&#123; page: this.data.page + 1 &#125;) this.getShopList() &#125;,&#125;) 11. 组件11.1 创建组件① 在项目的根目录中，鼠标右键，创建 components -&gt; test 文件夹 ② 在新建的 components -&gt; test 文件夹上，鼠标右键，点击“新建 Component ” ③ 键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js ， .json ， .wxml 和 .wxss 11.2 局部引用组件在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。 12345&#123; &quot;usingComponents&quot;: &#123; &quot;my-test1&quot;: &quot;/components/test/test&quot; &#125; &#125; 其中 my-test1 就是组件使用时的标签名, 而 &#x2F;components&#x2F;test&#x2F;test 就是组件的路径 11.3 全局引用组件在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。 123&quot;usingComponents&quot;: &#123; &quot;my-test2&quot;: &quot;/components/test2/test2&quot; &#125; 11.4 组件和页面的区别从表面来看，组件和页面都是由 .js 、 .json 、 .wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同： 1.组件的 .json 文件中需要声明 “component”: true 属性 2.组件的 .js 文件中调用的是 Component() 函数 ​ 整个程序启动调用的是 App() ​ 某个页面的渲染调用的是 Page() ​ 某个组件的渲染调用的是 Component() 3.组件的事件处理函数需要定义到 methods 节点中 11.5 组件的样式11.5.1 组件样式隔离默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构 ​ 组件 A 的样式不会影响组件 C 的样式 ​ 组件 A 的样式不会影响小程序页面的样式 ​ 小程序页面的样式不会影响组件 A 和 C 的样式 组件样式的隔离性的好处有： ① 防止外界的样式影响组件内部的样式 ② 防止组件的样式破坏外界的样式 11.5.2 组件样式隔离的注意点app.wxss 中的全局样式对组件无效 只有 class 选择器会有样式隔离效果， id 选择器、属性选择器、标签选择器不受样式隔离的影 响 建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器！因为在绝 大多数情况下, 我们希望组件的样式是隔离开的 11.5.3 修改组件的样式隔离选项默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。 但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样式隔离选项 12345678910111213// 在组件的.js 文件中新增加如下配置Component(&#123; options: &#123; // 默认值isolated: 代表启动样式隔离 // apply-shared: 代表页面wxss样式将影响自定义组件 // shared: 代表双向的影响 styleIsolation: &#x27;isolated&#x27; &#125; &#125;)// 或在组件的.json 文件中新增加如下配置 &#123; &quot;styleIsolation&quot;: &quot;isolated&quot; &#125; 11.5.4 styleIsolation 的可选值可选值 默认值 描述 isolated 是 表示启用样式隔离，在自定义组件内外，使用class指定的样式将不会互相影响 apply-shared 否 表示页面wxss样式将影响到自定义组件 ，但自定义组件wxss中指定的样式不会影响页面 shared 否 表示页面wxss样式将影响到自定义组件，自定义组件wxss中指定的样式也会影响页面和其他设置了apply-shared或shared的自定义组件 11.6 组件的数据、方法和属性11.6.1 data 数据在小程序组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中 \u0003\u000211.6.2 methods 方法在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中 11.6.3 properties 属性在小程序组件中， properties 是组件的对外属性，用来接收外界(父组件)传递到组件中的数据 \u0001当子组件接收到父组件传递过来的数据, 就可以通过判断父组件传递的数据，来控制事件的处理 11.6.4 data 和 properties 的区别在小程序的组件中， properties 属性和 data 数据的用法相同，它们都是可读可写的，只不过： ​ data 更倾向于存储组件的私有数据 ​ properties 更倾向于存储外界传递到组件中的数据 ​ 所以, 也不太建议修改 properties 数据, ​ 如果要修改 properties 的数据, 最好通过子组件通信给父组件的方式实现 11.6.5 修改 properties 的值由于 data 数据和 properties 属性在本质上没有任何区别，因此 properties 属性的值也可以用于页面渲染，或使用 setData 为 properties 中的属性重新赋值 12.数据监听器数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 vue 中的 watch 侦听器 1234567Components(&#123; // observers: 观察者 observers: &#123; &#x27;字段A， 字段B&#x27;: function(字段A的新值， 字段B的新值) &#123; // do something &#125; &#125;) 监听对象属性的变化 数据监听器支持监听对象中单个或多个属性的变化 方式1: 普通方式 12345678910Components(&#123; // observers: 观察者 observers: &#123; &#x27;对象.属性A， 对象.属性B&#x27;: function(属性A的新值， 属性B的新值) &#123; // 触发此侦听器的 3 种情况： // 【为属性A赋值】：使用setData 设置this.data.对象.属性A 时触发 // 【为属性B赋值】：使用setData 设置this.data.对象.属性B 时触发 // 【为对象赋值】：使用setData 设置this.data.对象 时触发 &#125; &#125;) 方式2: 通配符方式, 监听对象中所有属性的变化 1234567observers: &#123; &#x27;_rgb.**&#x27;: function (obj) &#123; this.setData(&#123; fullColor:`$&#123;obj.r&#125;, $&#123;obj.g&#125;, $&#123;obj.b&#125;` &#125;) &#125;&#125; 13. 纯数据字段概念：纯数据字段指的是那些不用于界面渲染的 data 字段。 应用场景：例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。例如之前控制上拉加载更多的节流阀 isLoading 这种类型的数据。 使用纯数据的好处:纯数据字段有助于提升页面更新的性能。 因为在小程序中， data 中声明的数据，会具备一个响应式的效果，系统的底层会对数据进行值变化的监听，如果，该数据只是纯数据，没有必要进行响应式的监听，因此定义为纯数据能够提高页面的性能。 13.1 使用规则在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个 正则表达式 ，字段名符合 这个正则 表达式的字段将会被视为纯数据字段 12345678910Component(&#123; options: &#123; // 指定所有_开头的数据字段为 纯数据字段 pureDataPattern: /^_/ &#125;, data: &#123; a: true, // 普通数据字段 _b: true // 纯数据字段 &#125;&#125;) 14.组件的生命周期14.1 组件自身的声明周期在小程序组件中，最重要的生命周期函数是 created 、 attached 、 ready 、 detached。 ① 组件实例刚被创建好的时候， created 生命周期函数会被触发 此时调用 setData 不会有效果 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段 ② 在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发 此时， this.data 已被初始化完毕 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据） ③ 在组件离开页面节点树后， detached 生命周期函数会被触发 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数 此时适合做一些清理性质的工作,例如,清除定时器 ④ 代表组件渲染完成的生命周期函数为 ready 可以操作页面 lifetimes 节点在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高） 14.2 组件所在页面的生命周期自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。 组件所在页面的生命周期函数有如下 3 个，分别是： 声明周期函数 参数 描述 show 无 组件所在的页面被展示是执行 hide 无 组件所在的页面被隐藏是执行 resize Object Size 组件所在的页面尺寸变化是执行 14.2.1 pageLifetimes 节点组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中 12345678Component(&#123; // 组件在页面的生命周期函数在该节点定义 pageLifetimes: &#123; show () &#123;&#125;, // 页面被展示 hide () &#123;&#125;, // 页面被隐藏 resize () &#123;&#125; // 页面尺寸变化 &#125;&#125;) 15.插槽插槽：在自定义组件的 wxml 结构中，可以提供一个 节点（插槽），用于承载组件使用者提供的 wxml 结构。 15.1启用 多个插槽在小程序的自定义组件中，需要使用多 插槽时，可以在组件的 .js 文件中，通过如下方式进行启用。 12345678Component(&#123; options: &#123; multipleSolts: true // 在组件定义时的选项中启用多 slot支持 &#125;, properties: &#123; /* ...*/ &#125;, methods: &#123; /* ...*/ &#125;&#125;) 一旦开启了多个插槽的配置, 就意味着在组件内部可能会有多个标签, 那我们在定义这多个标签的时候, 需要给每一个起名字.而组件使用者在填充的时候, 需要指明填充哪一个 15.2定义 多个插槽可以在组件的 .wxml 中使用多个 标签，以不同的 name 来区分不同的插槽。 1234567&lt;view class=&quot;wrapper&quot;&gt; &lt;!-- name 为 before 的第一个 插槽 --&gt; &lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt; &lt;view&gt;这是一段固定的文本内容&lt;/view&gt; &lt;!-- name 为 after 的第一个 插槽 --&gt; &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;&lt;/view&gt; 在使用带有多个插槽的自定义组件时，需要用 slot 属性来将节点插入到不同的中。 123456&lt;!-- 组件的使用者 --&gt;&lt;component-tag-name&gt; &lt;!-- 这部分内容将被放置在组件的&lt;slot&gt;的位置上 --&gt; &lt;view slot=&quot;before&quot;&gt;这是通过插槽填充的内容,name为before&lt;/view&gt; &lt;view slot=&quot;after&quot;&gt;这是通过插槽填充的内容,name为after&lt;/view&gt;&lt;/component-tag-name&gt; 16.父子组件之间的通信\u000116.1 父子组件之间通信的 3 种方式① 属性绑定 用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据(只能传递数据，不能传递方法) ② 事件绑定 用于子组件向父组件传递数据，可以传递任意数据(包括数据和方法) ③ 获取组件实例 父组件还可以通过 this.selectComponent() 获取子组件实例对象 这样就可以直接访问子组件的任意数据和方法 16.2 属性绑定属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。 12345678data: &#123; // 父组件中的data节点count: 0&#125;// 父组件的wxml结构&lt;my-test3 count=&quot;&#123;&#123;count&#125;&#125;&quot;&gt;&lt;/my-test3&gt;&lt;view&gt;------&lt;/view&gt;&lt;view&gt;父组件中，count值为 &#123;&#123;count&#125;&#125;&lt;/view&gt; 123456// 子组件的properties 节点properties: &#123;count: Number&#125;// 子组件的wxml结构&lt;text&gt;子组件中， count值为：&#123;&#123;count&#125;&#125;&lt;/text&gt; 16.3 事件绑定事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下： ① 在子组件的 js 中，在特定的时机通过调用 this.triggerEvent (‘自定义事件名称’, { &#x2F;* 参数对象*&#x2F; })产生一个自定义事件, 并且可以带上事件参数对象. ② 在父组件的 wxml 中的子组件标签中，使用 bind :自定义事件名称&#x3D;”事件处理函数”监听自定义事件。 ③ 在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件 ④ 在父组件的 事件处理函数中，通过 e.detail 获取到子组件传递过来的数据 16.4 获取组件实例可在父组件里调用 this.selectComponent(“id或class选择器”) ，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(“.my- component”) 。 17. behaviors17.1 什么是 behaviorsbehaviors 是小程序中，用于实现组件间代码共享的特性，类似于 Vue.js 中的 “mixins” 。 17.2 behaviors 的工作方式每个 behaviors 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和 方法会被合并到组件中。 每个组件可以引用多个 behaviors ， behaviors 也可以引用其它 behaviors 。 只有当组件共享的代码就可以使用 behaviors 来共享，如果是组件私有的代码，就不需要放在 behaviors 中 17.3 创建 behaviors调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使 用： 创建一个文件夹 behaviors 新建 js 文件 my-behavior.js 1234567891011// 调用 Behavior()方法， 创建实例对象 // 并使用 module.exports 将 behavior 实例对象共享出去 module.exports = Behavior(&#123; // 属性节点 properties: &#123;&#125;, // 私有数据节点 data: &#123; username: &#x27;zs&#x27; &#125;, // 事件处理函数和自定义方法节点 methods: &#123;&#125;, // 其他节点... &#125;) 17.4 导入并使用 behavior在组件中，使用 require() 方法导入需要的 behavior ，挂载后即可访问 behavior 中的数据或方法 123456789// 1.使用 required() 导入需要的自定义 behavior 模块const myBehavior = required(&quot;../../behaviors/my-behavior&quot;) // 2.将导入的behavior 实例对象， 挂载在 behaviors 数组节点中， 即可生效 Component(&#123; // 在组件内部 与data节点平级的位置定义该属性，挂载behavior模块 behaviors: [myBehavior] &#125;)// 3.在子组件中使用behavior中的东西 &lt;view&gt;在组件中共享的behavior是： &#123;&#123;username&#125;&#125;&lt;/view&gt; 18 使用 npm 包18.1 小程序对 npm 的支持与限制目前，小程序中已经支持使用 npm 安装第三方包，从而来提高小程序的开发效率。 但是，在小程序中使用 npm 包有如下 3 个限制： ① 不支持依赖于 Node.js 内置库的包 ② 不支持依赖于浏览器内置对象的包 ③ 不支持依赖于 C++ 插件的包 18.2 Vant WeappVant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 MIT 开源许可协议。 18.2.1 安装 Vant 组件库在小程序项目中，安装 Vant 组件库主要分为如下几 步： ① 首先要初始化 package.json 文件 在项目根目录执行 npm init -y ，-y 意思是快速下载，不必询问，都是 yes ② 通过 npm 安装（建议指定版本为@1.3.3）,下载到了项目根目录下的 node-modules npm i @vant&#x2F;&#x77;&#x65;&#97;&#x70;&#112;&#64;&#49;&#x2e;&#51;&#x2e;&#x33; -S –production ③ 构建 npm 包 ，使用 npm 模块 ④ 修改 app.json 将 app.json 中的 “style”: “v2” 去除，小程序的新版基础组件强行加上了许多样式，难以去除，不关闭将造成部分组件样式混乱。 18.2.2 使用 Vant 组件安装完 Vant 组件库之后，可以在 app.json 的 usingComponents 节点中引入需要的组件，即可在wxml 中 12// app.json &quot;usingComponents&quot;: &#123; &quot;van-button&quot;: &quot;@vant/weapp/bitton/index&quot; &#125;// 页面的.wxml 结构 &lt;van-button type=&quot;primary&quot;&gt;按钮&lt;/van-button&gt; 18.2.3 定制全局主题样式\u0002在 app.wxss 中，写入 CSS 变量，即可对全局生效 123456/* app.wxss */ page: &#123; /* 定制警告按钮的背景颜色 和边框颜色*/ --button-danger-background-color: #c00000; --button-danger-border-color: #d60000;&#125; 18.3 API PromiseAPI Promise 化，指的是通过额外的配置，将官方提供的、基于回调函数的异步 API ，升级改造为基于 Promise 的异步 API ，从而提高代码的可读性、维护性，避免回调地狱的问题。 在小程序中，实现 API Promise 化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包。 1.安装构建 npm i –save &#109;&#x69;&#x6e;&#x69;&#112;&#114;&#111;&#103;&#114;&#x61;&#x6d;&#45;&#x61;&#112;&#105;&#x2d;&#112;&#114;&#x6f;&#x6d;&#x69;&#115;&#101;&#64;&#x31;&#46;&#x30;&#x2e;&#52; 2.导入并执行代码 1234567891011// 在小程序入口文件中（app.js),只需要调用一次 promisifyAll()方法 // 即可实现异步API 的Promise化 // 按需导入一个方法 import &#123; promisifyAll &#125; from &#x27;miniprogram-api-promise&#x27; // 声明一个常量，为一个空对象， // 并在wx顶级对象下添加一个属性p也指向该空对象，使所有成员都可以使用该对象 const wxp = wx.p = &#123;&#125; // promisify all wx&#x27;s api // 参数1： wx顶级对象 // 参数2： wxp指向一个空对象 promisifyAll(wx, wxp) 解释上述代码: promisifyAll : 做的事就是将 wx 拥有的属性方法都copy并改造了一份给了 wxp 这个对象 然而, wxp 只是当前 js 文件的一个常量，只能在当前文件使用 因此：我们在 wx 上挂载一个属性 p 让他和 wxp 指向同一个空对象 在其他页面或者组件就可以通过全局对象 wx 点出 p 来访问到 wxp 此时 wx.p 发起异步的请求时，得到的是一个 promise 对象 那么我们就可以使用 async&#x2F;await 简化Promise语法 19 全局数据共享 全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。 开发中常用的全局数据共享方案有： Vuex 、 Redux 、 MobX 等。 在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。 其中： mobx-miniprogram 用来创建 Store 实例对象 mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用 1.安装MobX npm install –save &#109;&#111;&#98;&#x78;&#x2d;&#x6d;&#x69;&#110;&#105;&#x70;&#114;&#111;&#x67;&#x72;&#x61;&#x6d;&#x40;&#x34;&#46;&#x31;&#x33;&#46;&#50; &#x6d;&#x6f;&#x62;&#x78;&#x2d;&#x6d;&#105;&#110;&#105;&#112;&#x72;&#x6f;&#x67;&#x72;&#97;&#109;&#x2d;&#x62;&#105;&#x6e;&#100;&#105;&#110;&#x67;&#x73;&#x40;&#49;&#x2e;&#50;&#x2e;&#49; 2.创建 MobX 的 Store 实例 在项目根目录下新建store文件夹，并且新建 store.js 文件 12345678910111213141516171819// 按需导入第三方包的方法observable, action import &#123; observable, action &#125; from &#x27;mobx-miniprogram&#x27; // 创建 Store实例对象,并将其导出 export const store = observable(&#123; // 数据字段 numA: 1, numB: 2, // 计算属性 // 在计算属性的方法前，必须加 get修饰符，代表sum的值是只读的，无法进行修改 // 计算属性sum 依赖于numA和numB的值，因此sum函数的返回值就是最终的值 get sum() &#123; return this.numA + this.numB &#125;, // 定义actions方法, 用来修改 store中的数据 updateNum1: action(function (step) &#123; this.numA += step &#125;), updateNum2: action(function(step) &#123; this.numB += step &#125;) &#125;) 3.在页面中使用 123456789101112131415161718192021222324252627// 1.首先 导入第三方包，将数据绑定到页面 import &#123; createStoreBindings &#125; from &#x27;mobx-miniprogram-bindings&#x27; // 2.其次 在页面的js文件的头部区域导入容器的数据 import &#123; store &#125; from &#x27;../../store/store&#x27; // 3. 绑定操作：将仓库的东西绑定到当前的页面中，在页面的js文件的Page方法中 Page(&#123; // 上面周期函数--监听页面的加载 onLoad: function() &#123; // 调用createStoreBindings方法 // 参数1： 绑定给谁：当前页面this // 参数2： 对象&#123; store(容器)， fields(数据)， actions(修改方法) this.storeBindings = createStoreBindings(this, &#123; // 映射容器的实例 store, // 映射容器的数据字段 fields: [&#x27;numA&#x27;, &#x27;numB&#x27;, &#x27;sum&#x27;], // 映射容器修改的方法 actions: [&#x27;updateNum1&#x27;] &#125;) &#125;, // 生命周期函数--监听页面的卸载 onUnload: function () &#123; // 使用this.storeBindings，得到调用createStoreBindings方法的返回值 //调用destroyStoreBindings 方法，进行清理销毁的工作 this.storeBindings.destroyStoreBindings() &#125; &#125;) 123&lt;!-- 使用仓库中的数据 --&gt;&lt;view&gt;&#123;&#123;numA&#125;&#125; + &#123;&#123;numB&#125;&#125; = &#123;&#123;sum&#125;&#125;&lt;/view&gt;&lt;van-button type=&quot;primary&quot; bindtap=&quot;btnHnadler1&quot;&gt;numA+1&lt;/van-button&gt; 监听函数btnHandler1的代码 123456// 页面的js文件中的 tap事件处理函数 btnHnadler1 (e) &#123; console.log(e) // 使用仓库中的方法，并传递数据 this.updateNum1(e.target.dataset.step) &#125; 4.在组件中使用 1.新建组件文件夹以及组件文件 numbers 2.全局注册这个组件 3.在 message 页面中使用子组件 1234567891011121314151617//组件的 js 文件import &#123; storeBindingsBehavior &#125; from &#x27;mobx-miniprogram-bindings&#x27;import &#123; store &#125; from &#x27;../../store/store&#x27;Component(&#123; behaviors: [storeBindingsBehavior], storeBindings: &#123; store, fields: &#123; numA: &#x27;numA&#x27;, numB: &#x27;numB&#x27;, sum: &#x27;sum&#x27; &#125;, actions: &#123; updateNum2: &#x27;updateNum2&#x27; &#125; &#125;,&#125;) 1234//组件的wxml&lt;view&gt;&#123;&#123;numA&#125;&#125;+&#123;&#123;numB&#125;&#125;=&#123;&#123;sum&#125;&#125;&lt;/view&gt;&lt;van-button type=&quot;primary&quot; bindtap=&quot;btnHandler2&quot; data-step=&quot;&#123;&#123;1&#125;&#125;&quot;&gt;numB+1&lt;/van-button&gt;&lt;van-button type=&quot;primary&quot; bindtap=&quot;btnHandler2&quot; data-step=&quot;&#123;&#123;-1&#125;&#125;&quot;&gt;numB-1&lt;/van-button&gt; 123456//事件处理函数 btnHandler2btnHnadler2 (e) &#123; console.log(e) // 使用仓库中的方法，并传递数据 this.updateNum2(e.target.dataset.step) &#125; 20 分包分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。 对小程序进行分包的好处主要有以下两点： 可以优化小程序首次启动的下载时间 在多团队共同开发时可以更好的解耦协作 1.分包前项目的构成 分包前，小程序项目中所有的页面和资源都被打包到了一起，导致整个项目体积过大，影响小程序首次启动的下载时间。 2.分包后 项目的构成 分包后，小程序项目由 1 个主包 + 多个分包组成： 主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源 分包：只包含和当前分包有关的页面和私有资源 3.分包的加载规则 ① 在小程序启动时，默认会下载主包并启动主包内页面 tabBar 页面需要放到主包中 ② 当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示 非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载 4.分包的体积限制 目前，小程序分包的大小有以下两个限制： 整个小程序所有分包大小不超过 16M （主包 + 所有分包） 单个分包&#x2F;主包大小不能超过 2M 20.1使用分包1.配置方法 在 app.json 配置文件中, 新增 subpackages 的节点, 将希望放到分包的页面,写入 subpackages 数组的元素中。 2.打包原则 ① 小程序会按 subpackages 的配置进行分包， subpackages 之外的目录将被打包到主包中 ② 主包也可以有自己的 pages （即最外层的 pages 字段） ③ tabBar 页面必须在主包内 ④ 分包之间不能互相嵌套 3.引用原则 ① 主包无法引用分包内的私有资源 ② 分包之间不能相互引用私有资源 ③ 分包可以引用主包内的公共资源 20.2独立分包独立分包本质上也是分包，只不过它比较特殊，可以独立于主包和其他分包而单独运行。 1.独立分包和普通分包的区别 最主要的区别：是否依赖于主包才能运行 普通分包必须依赖于主包才能运行 独立分包可以在不下载主包的情况下，独立运行 2.独立分包的应用场景 开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。原因如下： 当小程序从普通的分包页面启动时，需要首先下载主包 而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度 注意：一个小程序中可以有多个独立分包。 3.独立分包的配置方法 和普通分包对比, 独立分包就是在 subpackages 数组的某个元素中, 配置 independent 为true即可 12345678910111213141516&#123; &quot;subPackages&quot;: [&#123; &quot;root&quot;: &quot;pkgA&quot;, &quot;pages&quot;: [ &quot;pages/cat/cat&quot;, &quot;pages/dog/dog&quot; ] &#125;, &#123; &quot;root&quot;: &quot;pkgB&quot;, &quot;pages&quot;: [ &quot;pages/apple/apple&quot; ] &#125; ]&#125; 4.引用原则 独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源！例如： ① 主包无法引用独立分包内的私有资源 ② 独立分包之间，不能相互引用私有资源 ③ 独立分包和普通分包之间，不能相互引用私有资源 ④ 特别注意：独立分包中不能引用主包内的公共资源 20.3 分包预下载分包预下载指的是：在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包页面时的启动速度。 1.配置分包的预下载 预下载分包的行为，会在进入指定的页面时触发。在 app.json 中，使用 preloadRule 节点定义分包的预下载规则 123456789101112131415&#123; 分包预下载的规则 &quot;preloadRule&quot;: &#123; 触发分包预下载的页面路径 &quot;page/concact/concact&quot;: &#123; network 表示在指定的网络模式下进行预下载 可选值有： all(不限网络)和wifi(仅 wifi 模式下进行预下载) 默认值为： wifi &quot;network&quot;: &quot;all&quot;, packages 表示进入页面后， 预下载哪些分包 可以通过root 或name 指定预下载哪些分包 &quot;packages&quot;: [&quot;pkgA&quot;] &#125; &#125; &#125; 2.分包预下载的限制 同一个分包中的页面享有共同的预下载大小限额 2M","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"初识(十)","slug":"初识-十","date":"2022-11-06T03:51:31.000Z","updated":"2022-11-06T03:56:20.483Z","comments":true,"path":"2022/11/06/初识-十/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E5%8D%81/","excerpt":"","text":"webpack基本使用Webpack 是一个静态资源打包工具。 它会以一个或多个文件作为打包的入口，将我们整个项目所有文件编译组合成一个或多个文件输出出去。 输出的文件就是编译好的文件，就可以在浏览器段运行了。 我们将 Webpack 输出的文件叫做 bundle。 功能介绍Webpack 本身功能是有限的: 开发模式：仅能编译 JS 中的 ES Module 语法 生产模式：能编译 JS 中的 ES Module 语法，还能压缩 JS 代码 开始使用1. 资源目录123456webpack_code # 项目根目录（所有指令必须在这个目录运行） └── src # 项目源码目录 ├── js # js文件目录 │ ├── count.js │ └── sum.js └── main.js # 项目主文件 2. 创建文件 count.js 123export default function sum(...args) &#123; return args.reduce((p, c) =&gt; p + c, 0);&#125; sum.js 123export default function sum(...args) &#123; return args.reduce((p, c) =&gt; p + c, 0);&#125; main.js 12345import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); 3. 下载依赖打开终端，来到项目根目录。运行以下指令： 初始化package.json 1npm init -y 此时会生成一个基础的 package.json 文件。 需要注意的是 package.json 中 name 字段不能叫做 webpack, 否则下一步会报错 下载依赖 1npm i webpack webpack-cli -D 4. 启用 Webpack执行命令如果报错，可以考虑尝试把node_modules文件夹删掉，重新安装依赖包，然后重试 开发模式 1npx webpack ./src/main.js --mode=development 生产模式 1npx webpack ./src/main.js --mode=production npx webpack: 是用来运行本地安装 Webpack 包的。 ./src/main.js: 指定 Webpack 从 main.js 文件开始打包，不但会打包 main.js，还会将其依赖也一起打包进来。 --mode=xxx：指定模式（环境）。 5. 观察输出文件默认 Webpack 会将文件打包输出到 dist 目录下，我们查看 dist 目录下文件情况就好了 基本配置在开始使用 Webpack 之前，我们需要对 Webpack 的配置有一定的认识。 5 大核心概念 entry（入口） 指示 Webpack 从哪个文件开始打包 output（输出） 指示 Webpack 打包完的文件输出到哪里去，如何命名等 loader（加载器） webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析 plugins（插件） 扩展 Webpack 的功能 mode（模式） 主要由两种模式： 开发模式：development 生产模式：production 准备 Webpack 配置文件在项目根目录下新建文件：webpack.config.js 1234567891011121314module.exports = &#123; // 入口 entry: &quot;&quot;, // 输出 output: &#123;&#125;, // 加载器 module: &#123; rules: [], &#125;, // 插件 plugins: [], // 模式 mode: &quot;&quot;,&#125;; Webpack 是基于 Node.js 运行的，所以采用 Common.js 模块化规范 修改配置文件 配置文件 12345678910111213141516171819202122232425// Node.js的核心模块，专门用来处理文件路径const path = require(&quot;path&quot;);module.exports = &#123; // 入口 // 相对路径和绝对路径都行 entry: &quot;./src/main.js&quot;, // 输出 output: &#123; // path: 文件输出目录，必须是绝对路径 // path.resolve()方法返回一个绝对路径 // __dirname 当前文件的文件夹绝对路径 path: path.resolve(__dirname, &quot;dist&quot;), // filename: 输出文件名 filename: &quot;main.js&quot;, &#125;, // 加载器 module: &#123; rules: [], &#125;, // 插件 plugins: [], // 模式 mode: &quot;development&quot;, // 开发模式&#125;; 运行指令 1npx webpack 处理样式资源Webpack 本身是不能识别样式资源的，所以我们需要借助 Loader 来帮助 Webpack 解析样式资源 我们找 Loader 都应该去官方文档中找到对应的 Loader，然后使用 官方文档找不到的话，可以从社区 Github 中搜索查询 Webpack 官方 Loader 文档 处理 Css 资源1. 下载包1npm i css-loader style-loader -D 注意：需要下载两个 loader 2. 功能介绍 css-loader：负责将 Css 文件编译成 Webpack 能识别的模块 style-loader：会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容 3. 配置12345678910111213141516171819202122232425const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ // +新增 &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 4. 添加 Css 资源 src&#x2F;css&#x2F;index.css 12345.box1 &#123; width: 100px; height: 100px; background-color: pink;&#125; src&#x2F;main.js 1234567891011import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// +新增// 引入 Css 资源，Webpack才会对其打包import &quot;./css/index.css&quot;;console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); public&#x2F;index.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;!-- 准备一个使用样式的 DOM 容器 --&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;!-- 引入打包后的js文件，才能看到效果 --&gt; &lt;script src=&quot;../dist/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5. 运行指令1npx webpack 处理 Less 资源1. 下载包1npm i less-loader less -D 2. 功能介绍 less-loader：负责将 Less 文件编译成 Css 文件 3. 配置1234567891011121314151617181920212223242526272829const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, // +新增 &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 4. 添加 Less 资源 src&#x2F;css&#x2F;index.less 12345.box2 &#123; width: 100px; height: 100px; background-color: deeppink;&#125; src&#x2F;main.js 123456789101112import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/index.css&quot;;// +新增import &quot;./css/index.less&quot;;console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); public&#x2F;index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../dist/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5. 运行指令1npx webpack 处理样式资源less、sass、styl汇总1. 下载包1npm i less-loader less sass-loader sass stylus-loader stylus -D 2. 功能介绍 负责将样式文件编译成 Css 文件 3. 配置12345678910111213141516171819202122232425262728293031323334353637const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, // +新增 &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 4. 添加 Styl 资源 src&#x2F;css&#x2F;index.less 12345.box2 &#123; width: 100px; height: 100px; background-color: deeppink;&#125; src&#x2F;css&#x2F;index.sass 12345/* 可以省略大括号、分号、冒号 */.box3 width: 100px height: 100px background-color: hotpink src&#x2F;css&#x2F;index.scss 12345.box4 &#123; width: 100px; height: 100px; background-color: lightpink; &#125; src&#x2F;css&#x2F;index.styl 12345/* 可以省略大括号、分号、冒号 */.box5 width 100px height 100px background-color pink src&#x2F;main.js 12345678910111213141516import &#123; add &#125; from &quot;./math&quot;;import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/index.css&quot;;// +新增import &quot;./css/index.less&quot;;import &quot;./css/index.sass&quot;;import &quot;./css/index.scss&quot;;import &quot;./css/index.styl&quot;;console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); public&#x2F;index.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;!-- 准备一个使用样式的 DOM 容器 --&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; // +新增 &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../dist/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5. 运行指令1npx webpack 处理图片资源过去在 Webpack4 时，我们处理图片资源通过 file-loader 和 url-loader 进行处理 现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源 1. 配置1234567891011121314151617181920212223242526272829303132333435363738394041const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, // +新增 &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 2. 添加图片资源 src&#x2F;images&#x2F;1.jpeg src&#x2F;images&#x2F;2.png src&#x2F;images&#x2F;3.gif 3. 使用图片资源 src&#x2F;less&#x2F;index.less 123456.box2 &#123; width: 100px; height: 100px; background-image: url(&quot;../images/1.jpeg&quot;); background-size: cover;&#125; src&#x2F;sass&#x2F;index.sass 12345.box3 width: 100px height: 100px background-image: url(&quot;../images/2.png&quot;) background-size: cover src&#x2F;styl&#x2F;index.styl 12345.box5 width 100px height 100px background-image url(&quot;../images/3.gif&quot;) background-size cover 4. 运行指令1npx webpack 5. 输出资源情况此时如果查看 dist 目录的话，会发现多了三张图片资源 因为 Webpack 会将所有打包好的资源输出到 dist 目录下 为什么样式资源没有呢？ 因为经过 style-loader 的处理，样式资源打包到 main.js 里面去了，所以没有额外输出出来 6. 对图片资源进行优化将小于某个大小的图片转化成 data URI 形式（Base64 格式） 参考Webpack 官方文档 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;main.js&quot;, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, // +新增 parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024 // 小于10kb的图片会被base64处理 &#125; &#125; &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 优点：减少请求数量 缺点：体积变得更大 此时输出的图片文件就只有两张，有一张图片以 data URI 形式内置到 js 中了 （注意：需要将上次打包生成的文件清空，再重新打包才有效果） 修改输出资源的名称和路径1. 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 +新增 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, // +新增 generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 2. 修改 index.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;!-- 修改 js 资源路径 --&gt; &lt;script src=&quot;../dist/static/js/main.js&quot;&gt;&lt;/script&gt; // +新增 &lt;/body&gt;&lt;/html&gt; 3. 运行指令1npx webpack 自动清空上次打包资源1. 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, clean: true, // 自动将上次打包目录资源清空 +新增 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 40 * 1024, // 小于40kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 2. 运行指令1npx webpack 处理字体图标资源1. 下载字体图标文件 打开阿里巴巴矢量图标库open in new window 选择想要的图标添加到购物车，统一下载到本地 2. 添加字体图标资源 src&#x2F;fonts&#x2F;iconfont.ttf src&#x2F;fonts&#x2F;iconfont.woff src&#x2F;fonts&#x2F;iconfont.woff2 src&#x2F;css&#x2F;iconfont.css 注意字体文件路径需要修改 src&#x2F;main.js 1234567891011121314151617import &#123; add &#125; from &quot;./math&quot;;import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/iconfont.css&quot;; // +新增import &quot;./css/index.css&quot;;import &quot;./css/index.less&quot;;import &quot;./css/index.sass&quot;;import &quot;./css/index.scss&quot;;import &quot;./css/index.styl&quot;;console.log(count(2, 1));console.log(sum(1, 2, 3, 4)); public&#x2F;index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; // +新增 &lt;!-- 使用字体图标 --&gt; &lt;i class=&quot;iconfont icon-aixin&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-bianji&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-caidan&quot;&gt;&lt;/i&gt; &lt;script src=&quot;../dist/static/js/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3. 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, // +新增 &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; type: &quot;asset/resource&quot;和type: &quot;asset&quot;的区别： type: &quot;asset/resource&quot; 相当于file-loader, 将文件转化成 Webpack 能识别的资源，其他不做处理 type: &quot;asset&quot; 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式 4. 运行指令1npx webpack 处理其他资源开发中可能还存在一些其他资源，如音视频等，我们也一起处理了 1. 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const path = require(&quot;path&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?|map4|map3|avi)$/, // +新增 type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [], mode: &quot;development&quot;,&#125;; 就是在处理字体图标资源基础上增加其他文件类型，统一处理即可 2. 运行指令1npx webpack 处理 js 资源有人可能会问，js 资源 Webpack 不能已经处理了吗，为什么我们还要处理呢？ 原因是 Webpack 对 js 处理是有限的，只能编译 js 中 ES 模块化语法，不能编译其他语法，导致 js 不能在 IE 等浏览器运行，所以我们希望做一些兼容性处理。 其次开发中，团队对代码格式是有严格要求的，我们不能由肉眼去检测代码格式，需要使用专业的工具来检测。 针对 js 兼容性处理，我们使用 Babel 来完成 针对代码格式，我们使用 Eslint 来完成 我们先完成 Eslint，检测代码格式无误后，在由 Babel 做代码兼容性处理 Eslint可组装的 JavaScript 和 JSX 检查工具。 这句话意思就是：它是用来检测 js 和 jsx 语法的工具，可以配置各项功能 我们使用 Eslint，关键是写 Eslint 配置文件，里面写上各种 rules 规则，将来运行 Eslint 时就会以写的规则对代码进行检查 1. 配置文件配置文件由很多种写法： .eslintrc.*：新建文件，位于项目根目录.eslintrc``.eslintrc.js``.eslintrc.json区别在于配置格式不一样 package.json 中 eslintConfig：不需要创建文件，在原有文件基础上写 ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可 2.具体配置我们以 .eslintrc.js 配置文件为例： 12345678910module.exports = &#123; // 解析选项 parserOptions: &#123;&#125;, // 具体检查规则 rules: &#123;&#125;, // 继承其他规则 extends: [], // ... // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring&#125;; parserOptions 解析选项 1234567parserOptions: &#123; ecmaVersion: 6, // ES 语法版本 sourceType: &quot;module&quot;, // ES 模块化 ecmaFeatures: &#123; // ES 其他特性 jsx: true // 如果是 React 项目，就需要开启 jsx 语法 &#125;&#125; rules 具体规则 &quot;off&quot; 或 0 - 关闭规则 &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出) &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) 123456789101112rules: &#123; semi: &quot;error&quot;, // 禁止使用分号 &#x27;array-callback-return&#x27;: &#x27;warn&#x27;, // 强制数组方法的回调函数中有 return 语句，否则警告 &#x27;default-case&#x27;: [ &#x27;warn&#x27;, // 要求 switch 语句中有 default 分支，否则警告 &#123; commentPattern: &#x27;^no default$&#x27; &#125; // 允许在最后注释 no default, 就不会有警告了 ], eqeqeq: [ &#x27;warn&#x27;, // 强制使用 === 和 !==，否则警告 &#x27;smart&#x27; // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告 ],&#125; 更多规则详见：规则文档open in new window extends 继承 开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。 现有以下较为有名的规则： Eslint 官方的规则open in new window：eslint:recommended Vue Cli 官方的规则open in new window：plugin:vue/essential React Cli 官方的规则open in new window：react-app 123456789// 例如在React项目中，我们可以这样写配置module.exports = &#123; extends: [&quot;react-app&quot;], rules: &#123; // 我们的规则会覆盖掉react-app的规则 // 所以想要修改规则直接改就是了 eqeqeq: [&quot;warn&quot;, &quot;smart&quot;], &#125;,&#125;; 3. 在 Webpack 中使用 下载包 1npm i eslint-webpack-plugin eslint -D 定义 Eslint 配置文件 .eslintrc.js 123456789101112131415module.exports = &#123; // 继承 Eslint 规则 extends: [&quot;eslint:recommended&quot;], env: &#123; node: true, // 启用node中全局变量 browser: true, // 启用浏览器中全局变量 &#125;, parserOptions: &#123; ecmaVersion: 6, sourceType: &quot;module&quot;, &#125;, rules: &#123; &quot;no-var&quot;: 2, // 不能使用 var 定义变量 &#125;,&#125;; 修改 js 文件代码 main.js 1234567891011121314151617import count from &quot;./js/count&quot;;import sum from &quot;./js/sum&quot;;// 引入资源，Webpack才会对其打包import &quot;./css/iconfont.css&quot;;import &quot;./css/index.css&quot;;import &quot;./less/index.less&quot;;import &quot;./sass/index.sass&quot;;import &quot;./sass/index.scss&quot;;import &quot;./styl/index.styl&quot;;// +新增var result1 = count(2, 1);console.log(result1);var result2 = sum(1, 2, 3, 4);console.log(result2); 配置 webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;); // +新增module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, ], &#125;, plugins: [ // +新增 new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), ], mode: &quot;development&quot;,&#125;; 运行指令 1npx webpack 4. VSCode Eslint 插件打开 VSCode，下载 Eslint 插件，即可不用编译就能看到错误，可以提前解决 但是此时就会对项目所有文件默认进行 Eslint 检查了，我们 dist 目录下的打包后文件就会报错。但是我们只需要检查 src 下面的文件，不需要检查 dist 下面的文件。 所以可以使用 Eslint 忽略文件解决。在项目根目录新建下面文件: .eslintignore 12# 忽略dist目录下所有文件dist BabelJavaScript 编译器。 主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中 1.配置文件配置文件由很多种写法： babel.config.*：新建文件，位于项目根目录babel.config.js``babel.config.json .babelrc.*：新建文件，位于项目根目录.babelrc``.babelrc.js``.babelrc.json package.json 中 babel：不需要创建文件，在原有文件基础上写 Babel 会查找和自动读取它们，所以以上配置文件只需要存在一个即可 2.具体配置我们以 babel.config.js 配置文件为例： 1234module.exports = &#123; // 预设 presets: [],&#125;; presets 预设 简单理解：就是一组 Babel 插件, 扩展 Babel 功能 @babel/preset-env: 一个智能预设，允许您使用最新的 JavaScript。 @babel/preset-react：一个用来编译 React jsx 语法的预设 @babel/preset-typescript：一个用来编译 TypeScript 语法的预设 3.在 Webpack 中使用（练习）下载包 1npm i babel-loader @babel/core @babel/preset-env -D 定义 Babel 配置文件 babel.config.js 123module.exports = &#123; presets: [&quot;@babel/preset-env&quot;],&#125;; 配置 webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, // +新增 &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), ], mode: &quot;development&quot;,&#125;; 运行指令 1npx webpack 处理 Html 资源1. 下载包1npm i html-webpack-plugin -D 2. 配置 webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); // +新增module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), // +新增 new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;public/index.html&quot;), &#125;), ], mode: &quot;development&quot;,&#125;; 3. 修改 index.html去掉引入的 js 文件，因为 HtmlWebpackPlugin 会自动引入 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;webpack5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Webpack5&lt;/h1&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; &lt;i class=&quot;iconfont icon-arrow-down&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-ashbin&quot;&gt;&lt;/i&gt; &lt;i class=&quot;iconfont icon-browse&quot;&gt;&lt;/i&gt; &lt;/body&gt;&lt;/html&gt; 4. 运行指令1npx webpack 开发服务器&amp;自动化1. 下载包1npm i webpack-dev-server -D 2. 配置 webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;dist&quot;), filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, // 自动将上次打包目录资源清空 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;public/index.html&quot;), &#125;), ], // +新增 // 开发服务器 devServer: &#123; host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器 &#125;, mode: &quot;development&quot;,&#125;; 3. 运行指令1npx webpack serve 生产模式介绍生产模式是开发完成代码后，我们需要得到代码将来部署上线。 这个模式下我们主要对代码进行优化，让其运行性能更好。 优化主要从两个角度出发: 优化代码运行性能 优化代码打包速度 生产模式准备我们分别准备两个配置文件来放不同的配置 1. 文件目录123456789101112├── webpack-test (项目根目录) ├── config (Webpack配置文件目录) │ ├── webpack.dev.js(开发模式配置文件) │ └── webpack.prod.js(生产模式配置文件) ├── node_modules (下载包存放目录) ├── src (项目源码目录，除了html其他都在src里面) │ └── 略 ├── public (项目html文件) │ └── index.html ├── .eslintrc.js(Eslint配置文件) ├── babel.config.js(Babel配置文件) └── package.json (包的依赖管理配置文件) 2. 修改 webpack.dev.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: undefined, // 开发模式没有输出，不需要指定输出目录 +新增 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 // clean: true, // 开发模式没有输出，不需要清空输出结果 +新增 &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), // +新增 &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), // +新增 &#125;), ], // 其他省略 devServer: &#123; host: &quot;localhost&quot;, // 启动服务器域名 port: &quot;3000&quot;, // 启动服务器端口号 open: true, // 是否自动打开浏览器 &#125;, mode: &quot;development&quot;,&#125;; 运行开发模式的指令： 1npx webpack serve --config ./config/webpack.dev.js 3. 修改 webpack.prod.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 +新增 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), ], // +新增 // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 运行生产模式的指令 1npx webpack --config ./config/webpack.prod.js 4. 配置运行指令为了方便运行不同模式的指令，我们将指令定义在 package.json 中 scripts 里面 123456789// package.json&#123; // 其他省略 &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run dev&quot;, &quot;dev&quot;: &quot;npx webpack serve --config ./config/webpack.dev.js&quot;, &quot;build&quot;: &quot;npx webpack --config ./config/webpack.prod.js&quot; &#125;&#125; 以后启动指令： 开发模式：npm start 或 npm run dev 生产模式：npm run build Css 处理提取 Css 成单独文件Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式 这样对于网站来说，会出现闪屏现象，用户体验不好 我们应该是单独的 Css 文件，通过 link 标签加载性能才好 1. 下载包1npm i mini-css-extract-plugin -D 2. 配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);// +新增const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], // +新增 &#125;, &#123; test: /\\.less$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;less-loader&quot;], // +新增 &#125;, &#123; test: /\\.s[ac]ss$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;], // +新增 &#125;, &#123; test: /\\.styl$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;stylus-loader&quot;], // +新增 &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // +新增 // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 3. 运行指令1npm run build Css 兼容性处理1. 下载包1npm i postcss-loader postcss postcss-preset-env -D 2. 配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, ], &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;less-loader&quot;, ], &#125;, &#123; test: /\\.s[ac]ss$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;sass-loader&quot;, ], &#125;, &#123; test: /\\.styl$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;stylus-loader&quot;, ], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 3. 控制兼容性我们可以在 package.json 文件中添加 browserslist 来控制样式的兼容性做到什么程度。 1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;ie &gt;= 8&quot;]&#125; 想要知道更多的 browserslist 配置，查看browserslist 文档open in new window 以上为了测试兼容性所以设置兼容浏览器 ie8 以上。 实际开发中我们一般不考虑旧版本浏览器了，所以我们可以这样设置： 1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]&#125; 4. 合并配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);// +新增// 处理css的loadersconst cssLoaders = [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;,]module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [...cssLoaders], // +新增 &#125;, &#123; test: /\\.less$/, use: [...cssLoaders, &quot;less-loader&quot;], //+新增 &#125;, &#123; test: /\\.s[ac]ss$/, use: [...cssLoaders, &quot;sass-loader&quot;], // +新增 &#125;, &#123; test: /\\.styl$/, use: [...cssLoaders, &quot;stylus-loader&quot;], // +新增 &#125;,&#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 5. 运行指令1npm run build Css 压缩开发中不需要压缩，部署的时候压缩即可 1. 下载包1npm i css-minimizer-webpack-plugin -D 2. 配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;); // +新增// 获取处理样式的Loadersconst getStyleLoaders = (preProcessor) =&gt; &#123; return [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, preProcessor, ].filter(Boolean);&#125;;module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: getStyleLoaders(), &#125;, &#123; test: /\\.less$/, use: getStyleLoaders(&quot;less-loader&quot;), &#125;, &#123; test: /\\.s[ac]ss$/, use: getStyleLoaders(&quot;sass-loader&quot;), &#125;, &#123; test: /\\.styl$/, use: getStyleLoaders(&quot;stylus-loader&quot;), &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), // +新增 // css压缩 new CssMinimizerPlugin(), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 提取 Css 成单独文件Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式 这样对于网站来说，会出现闪屏现象，用户体验不好 我们应该是单独的 Css 文件，通过 link 标签加载性能才好 1. 下载包1npm i mini-css-extract-plugin -D 2. 配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 // +新增 use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;], &#125;, &#123; test: /\\.less$/, //+新增 use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, // +新增 use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, // +新增 use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;stylus-loader&quot;], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // +新增 // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 3. 运行指令1npm run build Css 兼容性处理1. 下载包1npm i postcss-loader postcss postcss-preset-env -D 2. 配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, ], &#125;, &#123; test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;less-loader&quot;, ], &#125;, &#123; test: /\\.s[ac]ss$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;sass-loader&quot;, ], &#125;, &#123; test: /\\.styl$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, // +新增 &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;, &quot;stylus-loader&quot;, ], &#125;, &#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 3. 控制兼容性我们可以在 package.json 文件中添加 browserslist 来控制样式的兼容性做到什么程度。 1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;ie &gt;= 8&quot;]&#125; 想要知道更多的 browserslist 配置，查看browserslist 文档open in new window 以上为了测试兼容性所以设置兼容浏览器 ie8 以上。 实际开发中我们一般不考虑旧版本浏览器了，所以我们可以这样设置： 1234&#123; // 其他省略 &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]&#125; 4. 合并配置 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119const path = require(&quot;path&quot;);const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);// +新增// 处理css的loadersconst cssLoaders = [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; plugins: [ &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题 ], &#125;, &#125;, &#125;,]module.exports = &#123; entry: &quot;./src/main.js&quot;, output: &#123; path: path.resolve(__dirname, &quot;../dist&quot;), // 生产模式需要输出 filename: &quot;static/js/main.js&quot;, // 将 js 文件输出到 static/js 目录中 clean: true, &#125;, module: &#123; rules: [ &#123; // 用来匹配 .css 结尾的文件 test: /\\.css$/, // use 数组里面 Loader 执行顺序是从右到左 // +新增 use: [...cssLoaders], &#125;, &#123; test: /\\.less$/, // +新增 use: [...cssLoaders, &quot;less-loader&quot;], &#125;, &#123; test: /\\.s[ac]ss$/, // +新增 use: [...cssLoaders, &quot;sass-loader&quot;], &#125;, &#123; test: /\\.styl$/, // +新增 use: [...cssLoaders, &quot;stylus-loader&quot;], &#125;,&#123; test: /\\.(png|jpe?g|gif|webp)$/, type: &quot;asset&quot;, parser: &#123; dataUrlCondition: &#123; maxSize: 10 * 1024, // 小于10kb的图片会被base64处理 &#125;, &#125;, generator: &#123; // 将图片文件输出到 static/imgs 目录中 // 将图片文件命名 [hash:8][ext][query] // [hash:8]: hash值取8位 // [ext]: 使用之前的文件扩展名 // [query]: 添加之前的query参数 filename: &quot;static/imgs/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.(ttf|woff2?)$/, type: &quot;asset/resource&quot;, generator: &#123; filename: &quot;static/media/[hash:8][ext][query]&quot;, &#125;, &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, // 排除node_modules代码不编译 loader: &quot;babel-loader&quot;, &#125;, ], &#125;, plugins: [ new ESLintWebpackPlugin(&#123; // 指定检查文件的根目录 context: path.resolve(__dirname, &quot;../src&quot;), &#125;), new HtmlWebpackPlugin(&#123; // 以 public/index.html 为模板创建文件 // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源 template: path.resolve(__dirname, &quot;../public/index.html&quot;), &#125;), // 提取css成单独文件 new MiniCssExtractPlugin(&#123; // 定义输出文件名和目录 filename: &quot;static/css/main.css&quot;, &#125;), ], // devServer: &#123; // host: &quot;localhost&quot;, // 启动服务器域名 // port: &quot;3000&quot;, // 启动服务器端口号 // open: true, // 是否自动打开浏览器 // &#125;, mode: &quot;production&quot;,&#125;; 3. 运行指令1npm run build","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"}]},{"title":"初识(九)","slug":"初识-九","date":"2022-11-06T03:51:22.000Z","updated":"2022-11-06T03:56:09.742Z","comments":true,"path":"2022/11/06/初识-九/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E4%B9%9D/","excerpt":"","text":"Vuex起因：vue组件通信有父传子、子传父、eventBus这些方式进行组件通信 概念：vuex是为了解决跨组件数据通信，vuex是一个集中式数据化管理模式，实现数据共享，所有组件都能共享。 vuex使用1.安装 npm i vuex@3 2.在项目中创建一个文件夹 store 在文件夹中创建js文件来处理vuex相关的内容。 3.在store&#x2F;index.js 文件中编写 vuex 相关代码 123456789import Vue from &#x27;vue&#x27;import vuex from &#x27;vuex&#x27;Vue.use(vuex)const store = new vuex.Store( &#123; state: &#123; &#125; &#125; )export default store 在 mian.js 文件中导入 store&#x2F;index.js 12345import store from &#x27;@/store&#x27;new Vue(&#123; store, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) vuex基础-statestate是放置所有公共状态的属性，如果你有一个公共状态数据 ， 你只需要定义在 state对象中 定义state 1234567// 初始化vuex对象const store = new Vuex.Store(&#123; state: &#123; // 管理数据 count: 0 &#125;&#125;) 如何在组件中获取count? 原始形式- 插值表达式App.vue 组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下 1&lt;div&gt; state的数据：&#123;&#123; $store.state.count &#125;&#125;&lt;/div&gt; 计算属性 - 将state属性定义在计算属性中 123456// 把state中数据，定义在组件内的计算属性中 computed: &#123; count () &#123; return this.$store.state.count &#125; &#125; 1&lt;div&gt; state的数据：&#123;&#123; count &#125;&#125;&lt;/div&gt; 辅助函数 - mapState mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便用法 用法 ： 第一步：导入mapState 1import &#123; mapState &#125; from &#x27;vuex&#x27; 第二步：采用数组形式引入state属性 1mapState([&#x27;count&#x27;]) 上面代码的最终得到的是 类似 123count () &#123; return this.$store.state.count&#125; 第三步：利用延展运算符将导出的状态映射给计算属性 123computed: &#123; ...mapState([&#x27;count&#x27;])&#125; 1&lt;div&gt; state的数据：&#123;&#123; count &#125;&#125;&lt;/div&gt; vuex基础-mutations state数据的修改只能通过mutations，并且mutations必须是同步更新，目的是形成**数据快照** 数据快照：一次mutation的执行，立刻得到一种视图状态，因为是立刻，所以必须是同步 定义mutations 123456789const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, // 定义mutations mutations: &#123; &#125;&#125;) 格式说明 mutations是一个对象，对象中存放修改state的方法 1234567mutations: &#123; // 方法里参数 第一个参数是当前store的state属性 // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷 addCount (state) &#123; state.count += 1 &#125; &#125;, 如何在组件中调用mutations 原始形式-$store 新建组件child-a.vue，内容为一个button按钮，点击按钮调用mutations 12345678910111213141516&lt;template&gt; &lt;button @click=&quot;addCount&quot;&gt;+1&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; // 调用方法 addCount () &#123; // 调用store中的mutations 提交给muations // commit(&#x27;muations名称&#x27;, 2) this.$store.commit(&#x27;addCount&#x27;, 10) // 直接调用mutations &#125; &#125;&#125;&lt;/script&gt; 带参数的传递 1234addCount (state, payload) &#123; state.count += payload&#125;this.$store.commit(&#x27;addCount&#x27;, 10) 辅助函数 - mapMutations mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入 1234import &#123; mapMutations &#125; from &#x27;vuex&#x27;methods: &#123; ...mapMutations([&#x27;addCount&#x27;])&#125; 上面代码的含义是将mutations的方法导入了methods中，等同于 123456methods: &#123; // commit(方法名, 载荷参数) addCount () &#123; this.$store.commit(&#x27;addCount&#x27;) &#125; &#125; 此时，就可以直接通过this.addCount调用了 1&lt;button @click=&quot;addCount(100)&quot;&gt;+100&lt;/button&gt; 但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中 vuex基础-actions state是存放数据的，mutations是同步更新数据，actions则负责进行异步操作 定义actions 12345678910111213141516actions: &#123; // 获取异步的数据 context表示当前的store的实例 可以通过 context.state 获取状态 也可以通过context.commit 来提交mutations， 也可以 context.diapatch调用其他的action async getAsyncCount (context) &#123; setTimeout(function()&#123; // 一秒钟之后 要给一个数 去修改state context.commit(&#x27;addCount&#x27;, 123) &#125;, 1000) //axios(&#123;.....&#125;).then(res=&gt;&#123; // context.commit(&quot;xxx&quot;.res.data) //&#125;) //const &#123;data:result&#125; = await axios(&#123;...&#125;) //context.commit(&quot;xxx&quot;.res.data) &#125;&#125; 原始调用 - $store123addAsyncCount () &#123; this.$store.dispatch(&#x27;getAsyncCount&#x27;)&#125; 传参调用 123addAsyncCount () &#123; this.$store.dispatch(&#x27;getAsyncCount&#x27;, 123)&#125; 辅助函数 -mapActions actions也有辅助函数，可以将action导入到组件中 1234import &#123; mapActions &#125; from &#x27;vuex&#x27;methods: &#123; ...mapActions([&#x27;getAsyncCount&#x27;])&#125; 直接通过 this.方法就可以调用 1&lt;button @click=&quot;getAsyncCount(111)&quot;&gt;+异步&lt;/button&gt; vuex基础-getters 除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters 例如，state中定义了list，为1-10的数组， 123state: &#123; list: [1,2,3,4,5,6,7,8,9,10]&#125; 组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它 定义getters 12345getters: &#123; // getters函数的第一个参数是 state // 必须要有返回值 filterList: state =&gt; state.list.filter(item =&gt; item &gt; 5)&#125; 使用getters 原始方式 -$store1&lt;div&gt;&#123;&#123; $store.getters.filterList &#125;&#125;&lt;/div&gt; 辅助函数 - mapGetters123computed: &#123; ...mapGetters([&#x27;filterList&#x27;])&#125; 1&lt;div&gt;&#123;&#123; filterList &#125;&#125;&lt;/div&gt; Vuex中的模块化-Module定义两个模块 user 和 setting user中管理用户的状态 token setting中管理 应用的名称 name 12345678910111213const store = new Vuex.Store(&#123; modules: &#123; user: &#123; state: &#123; token: &#x27;12345&#x27; &#125; &#125;, setting: &#123; state: &#123; name: &#x27;Vuex实例&#x27; &#125; &#125; &#125;) 定义child-b组件，分别显示用户的token和应用名称name 123456&lt;template&gt; &lt;div&gt; &lt;div&gt;用户token &#123;&#123; $store.state.user.token &#125;&#125;&lt;/div&gt; &lt;div&gt;网站名称 &#123;&#123; $store.state.setting.name &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 请注意： 此时要获取子模块的状态 需要通过 $store.state.模块名称.属性名 来获取 看着获取有点麻烦，我们可以通过之前学过的getters来改变一下 1234getters: &#123; token: state =&gt; state.user.token, name: state =&gt; state.setting.name&#125; 请注意：这个getters是根级别的getters哦 通过mapGetters引用 123computed: &#123; ...mapGetters([&#x27;token&#x27;, &#x27;name&#x27;])&#125; 模块化中的命名空间命名空间 namespaced 这里注意理解 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 这句话的意思是 刚才的user模块还是setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用 1234567891011 user: &#123; state: &#123; token: &#x27;12345&#x27; &#125;, mutations: &#123; // 这里的state表示的是user的state updateToken (state) &#123; state.token = 678910 &#125; &#125;&#125;, 通过mapMutations调用 1234methods: &#123; ...mapMutations([&#x27;updateToken&#x27;]) &#125;&lt;button @click=&quot;updateToken&quot;&gt;修改token&lt;/button&gt; 但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置 高封闭性？可以理解成 一家人如果分家了，此时，你的爸妈可以随意的进出分给你的小家，你觉得自己没什么隐私了，我们可以给自己的房门加一道锁（命名空间 namespaced）,你的父母再也不能进出你的小家了 如 123456789101112user: &#123; namespaced: true, state: &#123; token: &#x27;12345&#x27; &#125;, mutations: &#123; // 这里的state表示的是user的state updateToken (state) &#123; state.token = 678910 &#125; &#125; &#125;, 使用带命名空间的模块 action/mutations 方案1：直接调用-带上模块的属性名路径 123test () &#123; this.$store.dispatch(&#x27;user/updateToken&#x27;) // 直接调用方法&#125; 方案2：辅助函数-带上模块的属性名路径 1234567methods: &#123; ...mapMutations([&#x27;user/updateToken&#x27;]), test () &#123; this[&#x27;user/updateToken&#x27;]() &#125; &#125;&lt;button @click=&quot;test&quot;&gt;修改token&lt;/button&gt; 方案3： createNamespacedHelpers 创建基于某个命名空间辅助函数 123import &#123; mapGetters, createNamespacedHelpers &#125; from &#x27;vuex&#x27;const &#123; mapMutations &#125; = createNamespacedHelpers(&#x27;user&#x27;)&lt;button @click=&quot;updateToken&quot;&gt;修改token2&lt;/button&gt;","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"}]},{"title":"初识(八)","slug":"初识-八","date":"2022-11-06T03:49:12.000Z","updated":"2022-11-06T04:03:23.693Z","comments":true,"path":"2022/11/06/初识-八/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E5%85%AB/","excerpt":"","text":"Vue1. 基础使用1.1.把@vue&#x2F;cli模块包按到全局, 电脑拥有vue命令, 才能创建脚手架工程 12345yarn global add @vue/cli# ORnpm install -g @vue/cli查看vue脚手架版本vue -V 1.2.创建项目 12# vue和create是命令, vuecli-demo是文件夹名vue create vuecli-demo 1.3.进入脚手架项目下, 启动内置的热更新本地服务器 12345cd vuecil-demonpm run serve# 或yarn serve 1.4.设置src并列处新建vue.config.js 1234567/* 覆盖webpack的配置 */module.exports = &#123; devServer: &#123; // 自定义服务配置 open: true, // 自动打开浏览器 port: 3000 &#125;&#125; 1.5.暂时关闭eslint检查 123module.exports = &#123; lintOnSave: false&#125; 1.1 yarn的基本使用与npm类似 12345678910111213141516171819202122# 1. 初始化, 得到package.json文件(终端路径所在文件夹下)yarn init# 2. 添加依赖(下包)# 命令: yarn add [package]# 命令: yarn add [package]@[version]yarn add jqueryyarn add jquery@3.5.1# 3. 移除包# 命令: yarn remove [package]yarn remove jquery # 4. 安装项目全部依赖(一般拿到别人的项目时, 缺少node_modules) yarn# 会根据当前项目package.json记录的包名和版本, 全部下载到当前工程中# 5. 全局# 安装: yarn global add [package]# 卸载: yarn global remove [package]# 注意: global一定在add左边yarn global add @vue/cli package.json中的dependencies和 devDependencies区别和作用 123dependencies 别人使用你的包必须下载的依赖, 比如yarn add jquery devDependencies 开发你的包需要依赖的包, 比如yarn add webpack webpack-cli -D (-D 相当于 --save-dev) 2.3 v-on2.3.1 给标签绑定事件 语法 v-on:事件名&#x3D;”要执行的&#x3D;&#x3D;少量代码&#x3D;&#x3D;” v-on:事件名&#x3D;”methods中的函数” v-on:事件名&#x3D;”methods中的函数(实参)” 简写: @事件名&#x3D;”methods中的函数” 123456789101112131415161718192021222324&lt;!-- vue指令: v-on事件绑定--&gt;&lt;p&gt;你要买商品的数量: &#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count = count + 1&quot;&gt;增加1&lt;/button&gt;&lt;button v-on:click=&quot;addFn&quot;&gt;增加1个&lt;/button&gt;&lt;button v-on:click=&quot;addCountFn(5)&quot;&gt;一次加5件&lt;/button&gt;&lt;button @click=&quot;subFn&quot;&gt;减少&lt;/button&gt;&lt;script&gt; export default &#123; // ...其他省略 methods: &#123; addFn()&#123; // this代表export default后面的组件对象(下属有data里return出来的属性) this.count++ &#125;, addCountFn(num)&#123; this.count += num &#125;, subFn()&#123; this.count-- &#125; &#125; &#125;&lt;/script&gt; 2.3.2 v-on事件对象 vue事件处理函数中, 拿到事件对象 语法: 无传参, 通过形参直接接收 传参, 通过$event指代事件对象传给事件处理函数 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止百度&lt;/a&gt; &lt;hr&gt; &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止去百度&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; one(e)&#123; e.preventDefault() &#125;, two(num, e)&#123; e.preventDefault() &#125; &#125;&#125;&lt;/script&gt; 2.3.3 v-on修饰符语法: @事件名.修饰符&#x3D;”methods里函数” .stop - 阻止事件冒泡 .prevent - 阻止默认行为 .once - 程序运行期间, 只触发一次事件处理函数 123456789101112131415161718192021&lt;template&gt; &lt;div @click=&quot;fatherFn&quot;&gt; &lt;!-- vue对事件进行了修饰符设置, 在事件后面.修饰符名即可使用更多的功能 --&gt; &lt;button @click.stop=&quot;btn&quot;&gt;.stop阻止事件冒泡&lt;/button&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;.prevent阻止默认行为&lt;/a&gt; &lt;button @click.once=&quot;btn&quot;&gt;.once程序运行期间, 只触发一次事件处理函数&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fatherFn()&#123; console.log(&quot;father被触发&quot;); &#125;, btn()&#123; console.log(1); &#125; &#125;&#125;&lt;/script&gt; 2.3.4 v-on按键修饰符 给键盘事件, 添加修饰符, 增强能力 语法: @keyup.enter - 监测回车按键 @keyup.esc - 监测返回按键 https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; enterFn()&#123; console.log(&quot;enter回车按键了&quot;); &#125;, escFn()&#123; console.log(&quot;esc按键了&quot;); &#125; &#125;&#125;&lt;/script&gt; 2.4 v-model 把value属性和vue数据变量, 双向绑定到一起 语法: v-model&#x3D;”vue数据变量” 双向数据绑定 数据变化 -&gt; 视图自动同步 视图变化 -&gt; 数据自动同步 特别注意: v-model, 在input[checkbox]的多选框状态 变量为非数组, 则绑定的是checked的属性(true&#x2F;false) - 常用于: 单个绑定使用 变量为数组, 则绑定的是他们的value属性里的值 - 常用于: 收集勾选了哪些值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;!-- v-model:是实现vuejs变量和表单标签value属性, 双向绑定的指令 --&gt; &lt;div&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; v-model=&quot;pass&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;来自于: &lt;/span&gt; &lt;!-- 下拉菜单要绑定在select上 --&gt; &lt;select v-model=&quot;from&quot;&gt; &lt;option value=&quot;北京市&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;南京市&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;天津市&quot;&gt;天津&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- (重要) 遇到复选框, v-model的变量值 非数组 - 关联的是复选框的checked属性 数组 - 关联的是复选框的value属性 --&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;抽烟&quot;&gt;抽烟 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;喝酒&quot;&gt;喝酒 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;写代码&quot;&gt;写代码 &lt;/div&gt; &lt;div&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;男 &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;女 &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍&lt;/span&gt; &lt;textarea v-model=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; username: &quot;&quot;, pass: &quot;&quot;, from: &quot;&quot;, hobby: [], sex: &quot;&quot;, intro: &quot;&quot;, &#125;; // 总结: // 特别注意: v-model, 在input[checkbox]的多选框状态 // 变量为非数组, 则绑定的是checked的属性(true/false) - 常用于: 单个绑定使用 // 变量为数组, 则绑定的是他们的value属性里的值 - 常用于: 收集勾选了哪些值 &#125;&#125;;&lt;/script&gt; 2.4.1 v-model修饰符语法: v-model.修饰符&#x3D;”vue数据变量” .number 以parseFloat转成数字类型 .trim 去除首尾空白字符 .lazy 在change时触发而非inupt时 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span&gt;年龄:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;人生格言:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;motto&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍:&lt;/span&gt; &lt;textarea v-model.lazy=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; age: &quot;&quot;, motto: &quot;&quot;, intro: &quot;&quot; &#125; &#125;&#125;&lt;/script&gt; 2.5 v-text和v-html 语法: v-text&#x3D;”vue数据变量” v-html&#x3D;”vue数据变量” 注意: 会覆盖插值表达式 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; str: &quot;&lt;span&gt;我是一个span标签&lt;/span&gt;&quot; &#125; &#125;&#125;&lt;/script&gt; v-text把值当成普通字符串显示, v-html把值当做html解析 2.6 v-show和v-if 控制标签的隐藏或出现 语法: v-show&#x3D;”vue变量” v-if&#x3D;”vue变量” 原理 v-show 用的display:none隐藏 (频繁切换使用) v-if 直接从DOM树上移除 高级 v-else使用 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 v-show=&quot;isOk&quot;&gt;v-show的盒子&lt;/h1&gt; &lt;h1 v-if=&quot;isOk&quot;&gt;v-if的盒子&lt;/h1&gt; &lt;div&gt; &lt;p v-if=&quot;age &gt; 18&quot;&gt;我成年了&lt;/p&gt; &lt;p v-else&gt;还得多吃饭&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isOk: true, age: 15 &#125; &#125;&#125;&lt;/script&gt; 2.7 折叠案例1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;div&gt; &lt;div class=&quot;title&quot;&gt; &lt;h4&gt;芙蓉楼送辛渐&lt;/h4&gt; &lt;span class=&quot;btn&quot; @click=&quot;isShow = !isShow&quot;&gt; &#123;&#123; isShow ? &#x27;收起&#x27; : &#x27;展开&#x27; &#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot; v-show=&quot;isShow&quot;&gt; &lt;p&gt;寒雨连江夜入吴, &lt;/p&gt; &lt;p&gt;平明送客楚山孤。&lt;/p&gt; &lt;p&gt;洛阳亲友如相问，&lt;/p&gt; &lt;p&gt;一片冰心在玉壶。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isShow: false &#125; &#125;&#125;&lt;/script&gt; 2.8 v-for 列表渲染, 所在标签结构, 按照数据数量, 循环生成 语法 v-for&#x3D;”(值, 索引) in 目标结构” v-for&#x3D;”值 in 目标结构” 目标结构: 可以遍历数组 &#x2F; 对象 &#x2F; 数字 &#x2F; 字符串 (可遍历结构) 注意: v-for的临时变量名不能用到v-for范围外 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-for 把一组数据, 渲染成一组DOM --&gt; &lt;!-- 口诀: 让谁循环生成, v-for就写谁身上 --&gt; &lt;p&gt;学生姓名&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;item&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;学生详细信息&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;obj in stuArr&quot; :key=&quot;obj.id&quot;&gt; &lt;span&gt;&#123;&#123; obj.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.sex &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.hobby &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- v-for遍历对象(了解) --&gt; &lt;p&gt;老师信息&lt;/p&gt; &lt;div v-for=&quot;(value, key) in tObj&quot; :key=&quot;value&quot;&gt; &#123;&#123; key &#125;&#125; -- &#123;&#123; value &#125;&#125; &lt;/div&gt; &lt;!-- v-for遍历整数(了解) - 从1开始 --&gt; &lt;p&gt;序号&lt;/p&gt; &lt;div v-for=&quot;i in count&quot; :key=&quot;i&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; arr: [&quot;小明&quot;, &quot;小欢欢&quot;, &quot;大黄&quot;], stuArr: [ &#123; id: 1001, name: &quot;孙悟空&quot;, sex: &quot;男&quot;, hobby: &quot;吃桃子&quot;, &#125;, &#123; id: 1002, name: &quot;猪八戒&quot;, sex: &quot;男&quot;, hobby: &quot;背媳妇&quot;, &#125;, ], tObj: &#123; name: &quot;小黑&quot;, age: 18, class: &quot;1期&quot;, &#125;, count: 10, &#125;; &#125;,&#125;;&lt;/script&gt; 2.9 总结2.9.1. Vue的最大优势是什么?​ 简单易学, 轻量级整个源码js文件不大, 双向数据绑定, 数据驱动视图, 组件化, 数据和视图分离, ​ vue负责关联视图和数据, 作者中国人(尤雨溪), 文档都是中文的, 入门教程非常多, 上手简单. ​ 相比传统网页, vue是单页面可以只刷新某一部分 2.9.2. Vue和jQuery区别是什么?​ jQuery应该算是一个插件, 里面封装了各种易用的方法, 方便你使用更少的代码来操作dom标签 ​ Vue是一套框架, 有自己的规则和体系与语法, 特别是设计思想MVVM, 让数据和视频关联绑定, 省略了很多DOM操作. 然后指令还给标签注入了更多的功能 2.9.3. mvvm和mvc区别是什么?​ MVC: 也是一种设计模式, 组织代码的结构, 是model数据模型, view视图, Controller控制器, 在控制器这层里编写js代码, 来控制数据和视图关联 ​ MVVM: 即Model-View-ViewModel的简写。即模型-视图-视图模型, VM是这个设计模式的核心, 连接v和m的桥梁, 内部会监听DOM事件, 监听数据对象变化来影响对方. 我们称之为数据绑定 2.9.4. Vue常用修饰符有哪些?​ .prevent: 提交事件不再重载页面； ​ .stop: 阻止单击事件冒泡； ​ .once: 只执行一次这个事件 2.9.5. Vue2.x兼容IE哪个版本以上​ 不支持ie8及以下，部分兼容ie9 ，完全兼容10以上， 因为vue的响应式原理是基于es5的Object.defineProperty(),而这个方法不支持ie8及以下。 2.9.6. 对Vue渐进式的理解​ 渐进式代表的含义是：主张最少, 自底向上, 增量开发, 组件集合, 便于复用 2.9.7. v-show和v-if的区别​ v-show和v-if的区别? 分别说明其使用场景? ​ v-show 和v-if都是true的时候显示，false的时候隐藏 ​ 但是：false的情况下， ​ v-show是采用的display:none ​ v-if采用惰性加载 ​ 如果需要频繁切换显示隐藏需要使用v-show 2.9.8. 说出至少4个Vue指令及作用​ v-for 根据数组的个数, 循环数组元素的同时还生成所在的标签 ​ v-show 显示内容 ​ v-if 显示与隐藏 ​ v-else 必须和v-if连用 不能单独使用 否则报错 ​ v-bind 动态绑定 作用： 及时对页面的数据进行更改, 可以简写成:分号 ​ v-on 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面 ​ v-text 解析文本 ​ v-html 解析html标签 2.9.9. 为什么避免v-for和v-if在一起使用​ Vue 处理指令时，v-for 比 v-if 具有更高的优先级, 虽然用起来也没报错好使, 但是性能不高, 如果你有5个元素被v-for循环, v-if也会分别执行5次. 3. v-for更新监测这些方法会触发数组改变, v-for会监测到并更新页面 push() pop() shift() unshift() splice() sort() reverse() 这些方法不会触发v-for更新 slice() filter() concat() 注意: vue不能监测到数组里赋值的动作而更新, 如果需要请使用Vue.set() 或者this.$set(), 或者覆盖整个数组 总结: 改变原数组的方法才能让v-for更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(val, index) in arr&quot; :key=&quot;index&quot;&gt; &#123;&#123; val &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;revBtn&quot;&gt;数组翻转&lt;/button&gt; &lt;button @click=&quot;sliceBtn&quot;&gt;截取前3个&lt;/button&gt; &lt;button @click=&quot;updateBtn&quot;&gt;更新第一个元素值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; arr: [5, 3, 9, 2, 1] &#125; &#125;, methods: &#123; revBtn()&#123; // 1. 数组翻转可以让v-for更新 this.arr.reverse() &#125;, sliceBtn()&#123; // 2. 数组slice方法不会造成v-for更新 // slice不会改变原始数组 // this.arr.slice(0, 3) // 解决v-for更新 - 覆盖原始数组 let newArr = this.arr.slice(0, 3) this.arr = newArr &#125;, updateBtn()&#123; // 3. 更新某个值的时候, v-for是监测不到的 // this.arr[0] = 1000; // 解决-this.$set() // 参数1: 更新目标结构 // 参数2: 更新位置 // 参数3: 更新值 this.$set(this.arr, 0, 1000) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.1 diff算法-key:key 有id用id,无id用索引动态class 3.2 动态class 用v-bind给标签class设置动态的值 语法: :class&#x3D;”{类名: 布尔值}” 总结: 就是把类名保存在vue变量中赋予给标签 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;!-- 语法: :class=&quot;&#123;类名: 布尔值&#125;&quot; 使用场景: vue变量控制标签是否应该有类名 --&gt; &lt;p :class=&quot;&#123;red_str: bool&#125;&quot;&gt;动态class&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; bool: true &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .red_str&#123; color: red; &#125;&lt;/style&gt; 3.3动态style 目标: 给标签动态设置style的值 语法 :style&#x3D;”{css属性: 值}” 总结: 动态style的key都是css属性名 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;!-- 动态style语法 :style=&quot;&#123;css属性名: 值&#125;&quot; --&gt; &lt;p :style=&quot;&#123;backgroundColor: colorStr&#125;&quot;&gt;动态style&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; colorStr: &#x27;red&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.4 vue过滤器转换格式, 过滤器就是一个函数, 传入值返回处理后的值 过滤器只能用在, &#x3D;&#x3D;插值表达式和v-bind表达式&#x3D;&#x3D; 语法: Vue.filter(“过滤器名”, (值) &#x3D;&gt; {return “返回处理后的值”}) filters: {过滤器名字: (值) &#x3D;&gt; {return “返回处理后的值”} 总结: 把值转成另一种形式, 使用过滤器, Vue3用函数替代了过滤器. 全局注册最好在main.js中注册, 一处注册到处使用 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div&gt; &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;!-- 2. 过滤器使用 语法: &#123;&#123; 值 | 过滤器名字 &#125;&#125; --&gt; &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse &#125;&#125;&lt;/p&gt; &lt;p :title=&quot;msg | toUp&quot;&gt;鼠标长停&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; msg: &#x27;Hello, Vue&#x27; &#125; &#125;, // 方式2: 局部 - 过滤器 // 只能在当前vue文件内使用 /* 语法: filters: &#123; 过滤器名字 (val) &#123; return 处理后的值 &#125; &#125; */ filters: &#123; toUp (val) &#123; return val.toUpperCase() &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.5 vue过滤器-传参和多过滤器 可同时使用多个过滤器, 或者给过滤器传参 语法: 过滤器传参: vue变量 | 过滤器(实参) 多个过滤器: vue变量 | 过滤器1 | 过滤器2 总结: 过滤器可以传参, 还可以对某个过滤器结果, 后面在使用一个过滤器 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;p&gt;原来的样子: &#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;!-- 1. 给过滤器传值 语法: vue变量 | 过滤器名(值) --&gt; &lt;p&gt;使用翻转过滤器: &#123;&#123; msg | reverse(&#x27;|&#x27;) &#125;&#125;&lt;/p&gt; &lt;!-- 2. 多个过滤利使用 语法: vue变量 | 过滤器1 | 过滤器2 --&gt; &lt;p :title=&quot;msg | toUp | reverse(&#x27;|&#x27;)&quot;&gt;鼠标长停&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; msg: &#x27;Hello, Vue&#x27; &#125; &#125;, filters: &#123; toUp (val) &#123; return val.toUpperCase() &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.6 vue计算属性-computed 一个数据, 依赖另外一些数据计算而来的结果 语法: 12345computed: &#123; &quot;计算属性名&quot; () &#123; return &quot;值&quot; &#125;&#125; 注意: 计算属性也是vue数据变量, 所以不要和data里重名, 用法和data相同 总结: 一个数据, 依赖另外一些数据计算而来的结果 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; a: 10, b: 20 &#125; &#125;, // 计算属性: // 场景: 一个变量的值, 需要用另外变量计算而得来 /* 语法: computed: &#123; 计算属性名 () &#123; return 值 &#125; &#125; */ // 注意: 计算属性和data属性都是变量-不能重名 // 注意2: 函数内变量变化, 会自动重新计算结果返回 computed: &#123; num()&#123; return this.a + this.b &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.6.1 vue计算属性-完整写法计算属性也是变量, 如果想要直接赋值, 需要使用完整写法 语法: 12345678910computed: &#123; &quot;属性名&quot;: &#123; set(值)&#123; &#125;, get() &#123; return &quot;值&quot; &#125; &#125;&#125; 总结: 想要给计算属性赋值, 需要使用set方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span&gt;姓名:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&quot;full&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 问题: 给计算属性赋值 - 需要setter// 解决:/* 完整语法: computed: &#123; &quot;计算属性名&quot; ()&#123;&#125;, &quot;计算属性名&quot;: &#123; set(值)&#123; &#125;, get()&#123; return 值 &#125; &#125; &#125;*/export default &#123; computed: &#123; full: &#123; // 给full赋值触发set方法 set(val)&#123; console.log(val) &#125;, // 使用full的值触发get方法 get()&#123; return &quot;无名氏&quot; &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.7 vue侦听器-watch 可以侦听data&#x2F;computed属性值改变 语法: 12345watch: &#123; &quot;被侦听的属性名&quot; (newVal, oldVal)&#123; &#125;&#125; 总结: 想要侦听一个属性变化, 可使用侦听属性watch 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; name: &quot;&quot; &#125; &#125;, // 目标: 侦听到name值的改变 /* 语法: watch: &#123; 变量名 (newVal, oldVal)&#123; // 变量名对应值改变这里自动触发 &#125; &#125; */ watch: &#123; // newVal: 当前最新值 // oldVal: 上一刻值 name(newVal, oldVal)&#123; console.log(newVal, oldVal); &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.8 vue侦听器-深度侦听和立即执行123456789watch: &#123; &quot;要侦听的属性名&quot;: &#123; immediate: true, // 立即执行 deep: true, // 深度侦听复杂类型内变化 handler (newVal, oldVal) &#123; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;user.name&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;user.age&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; user: &#123; name: &quot;&quot;, age: 0 &#125; &#125; &#125;, // 目标: 侦听对象 /* 语法: watch: &#123; 变量名 (newVal, oldVal)&#123; // 变量名对应值改变这里自动触发 &#125;, 变量名: &#123; handler(newVal, oldVal)&#123; &#125;, deep: true, // 深度侦听(对象里面层的值改变) immediate: true // 立即侦听(网页打开handler执行一次) &#125; &#125; */ watch: &#123; user: &#123; handler(newVal, oldVal)&#123; // user里的对象 console.log(newVal, oldVal); &#125;, deep: true, immediate: true &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.9 Vue 中怎么自定义过滤器​ Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式 ​ 全局的用Vue.filter() ​ 局部的用filters属性 3.10 总结3.10.1 Vue中:key作用, 为什么不能用索引​ :key是给v-for循环生成标签颁发唯一标识的, 用于性能的优化 ​ 因为v-for数据项的顺序改变，Vue 也不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素 ​ :key如果是索引, 因为索引是连续的, 如果删除其中某一个, 会导致最后一个被删除 ​ 当我们再删除的时候, :key再根据数据来把新旧的dom对比时, 删除:key不存在的对应的标签(添加也是一样的插入到指定位置, 别的都不会动) 3.10.2 数组更新有的时候v-for不渲染​ 因为vue内部只能监测到数组顺序&#x2F;位置的改变&#x2F;数量的改变, 但是值被重新赋予监测不到变更, 可以用 Vue.set() &#x2F; vm.$set() 4. vue组件组件是可复用的 Vue 实例, 封装标签, 样式和JS代码 组件化 ：封装的思想，把页面上 可重用的部分 封装为 组件，从而方便项目的 开发 和 维护 一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为(html, css和js) 口诀: 哪部分标签复用, 就把哪部分封装到组件内 &#x3D;&#x3D;(重要): 组件内template只能有一个根标签&#x3D;&#x3D; &#x3D;&#x3D;(重要): 组件内data必须是一个函数, 独立作用域&#x3D;&#x3D; 4.1 组件使用4.1.1全局 - 注册使用全局入口在main.js, 在new Vue之上注册 语法: 1234import Vue from &#x27;vue&#x27;import 组件对象 from &#x27;vue文件路径&#x27;Vue.component(&quot;组件名&quot;, 组件对象) main.js - 立即演示 12345678910// 目标: 全局注册 (一处定义到处使用)// 1. 创建组件 - 文件名.vue// 2. 引入组件import Pannel from &#x27;./components/Pannel&#x27;// 3. 全局 - 注册组件/* 语法: Vue.component(&quot;组件名&quot;, 组件对象)*/Vue.component(&quot;PannelG&quot;, Pannel) 全局注册PannelG组件名后, 就可以当做标签在任意Vue文件中template里用 单双标签都可以或者小写加-形式, 运行后, 会把这个自定义标签当做组件解析, 使用&#x3D;&#x3D;组件里封装的标签替换到这个位置&#x3D;&#x3D; 123&lt;PannelG&gt;&lt;/PannelG&gt;&lt;PannelG/&gt;&lt;pannel-g&gt;&lt;/pannel-g&gt; 4.1.2 局部 - 注册使用语法: 1234567import 组件对象 from &#x27;vue文件路径&#x27;export default &#123; components: &#123; &quot;组件名&quot;: 组件对象 &#125;&#125; 任意vue文件中中引入, 注册, 使用 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;案例：折叠面板&lt;/h3&gt; &lt;!-- 4. 组件名当做标签使用 --&gt; &lt;!-- &lt;组件名&gt;&lt;/组件名&gt; --&gt; &lt;PannelG&gt;&lt;/PannelG&gt; &lt;PannelL&gt;&lt;/PannelL&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 局部注册 (用的多)// 1. 创建组件 - 文件名.vue// 2. 引入组件import Pannel from &#x27;./components/Pannel_1&#x27;export default &#123; // 3. 局部 - 注册组件 /* 语法: components: &#123; &quot;组件名&quot;: 组件对象 &#125; */ components: &#123; PannelL: Pannel &#125;&#125;&lt;/script&gt; 组件使用总结: (创建)封装html+css+vue到独立的.vue文件中 (引入注册)组件文件 &#x3D;&gt; 得到组件配置对象 (使用)当前页面当做标签使用 4.1.3 vue组件-scoped作用 解决多个组件样式名相同, 冲突问题 需求: div标签名选择器, 设置背景色 问题: 发现组件里的div和外面的div都生效了 解决: 给Pannel.vue组件里style标签上加scoped属性即可 1&lt;style scoped&gt; 在style上加入scoped属性, 就会在此组件的标签上加上一个随机生成的data-v开头的属性 而且必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到 4.2 vue组件通信因为每个组件的变量和值都是独立的 组件通信先暂时关注父传子, 子传父 父: 使用其他组件的vue文件 子: 被引入的组件(嵌入) 例如: App.vue(父) MyProduct.vue(子) 组件内在props定义变量, 用于接收外部传入的值 12345父(App.vue) -&gt; 子(MyProduct.vue) 分别传值进入需求: 每次组件显示不同的数据信息步骤(口诀): 1. 子组件 - props - 变量 (准备接收) 2. 父组件 - 传值进去 123456789101112131415161718192021222324//MyProduct.vue&lt;template&gt; &lt;div class=&quot;my-product&quot;&gt; &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt; &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;]&#125;&lt;/script&gt;&lt;style&gt;.my-product &#123; width: 400px; padding: 20px; border: 2px solid #000; border-radius: 5px; margin: 10px;&#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637//App.vue&lt;template&gt; &lt;div&gt; &lt;!-- 目标: 父(App.vue) -&gt; 子(MyProduct.vue) 分别传值进入 需求: 每次组件显示不同的数据信息 步骤(口诀): 1. 子组件 - props - 变量 (准备接收) 2. 父组件 - 传值进去 --&gt; &lt;Product title=&quot;好吃的口水鸡&quot; price=&quot;50&quot; intro=&quot;开业大酬宾, 全场8折&quot;&gt;&lt;/Product&gt; &lt;Product title=&quot;好可爱的可爱多&quot; price=&quot;20&quot; intro=&quot;老板不在家, 全场1折&quot;&gt;&lt;/Product&gt; &lt;Product title=&quot;好贵的北京烤鸭&quot; price=&quot;290&quot; :intro=&quot;str&quot;&gt;&lt;/Product&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 1. 创建组件 (.vue文件)// 2. 引入组件import Product from &#x27;./components/MyProduct&#x27;export default &#123; data()&#123; return &#123; str: &quot;好贵啊, 快来啊, 好吃&quot; &#125; &#125;, // 3. 注册组件 components: &#123; // Product: Product // key和value变量名同名 - 简写 Product &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 4.3 单向数据流在vue中需要遵循单向数据流原则 父组件的数据发生了改变，子组件会自动跟着变 子组件不能直接修改父组件传递过来的props props是只读的 &#x3D;&#x3D;父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，对象是引用类型, 互相更新&#x3D;&#x3D; 总结: props的值不能重新赋值, 对象引用关系属性值改变, 互相影响 那我怎么才能修改子组件接收到的值呢? - 其实要影响父亲, 然后数据响应式来影响儿子们 从&#x3D;&#x3D;父到子&#x3D;&#x3D;的数据流向,叫&#x3D;&#x3D;单向数据流&#x3D;&#x3D; 原因: 子组件修改, 不通知父级, 造成数据不一致性 如果第一个MyProduct.vue内自己修改商品价格为5.5, 但是App.vue里原来还记着18.8 - 数据 不一致了 所以: Vue规定&#x3D;&#x3D;props&#x3D;&#x3D;里的变量, &#x3D;&#x3D;本身是只读&#x3D;&#x3D;的 _4.4 vue组件通信_子向父 目标: 从子组件把值传出来给外面使用 语法: 父: @自定义事件名&#x3D;”父methods函数” 子: this.$emit(“自定义事件名”, 传值) - 执行父methods里函数代码 1234567891011121314151617181920212223242526272829303132//MyProduct_sub.vue&lt;template&gt; &lt;div class=&quot;my-product&quot;&gt; &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt; &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &#x27;../EventBus&#x27;export default &#123; props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;], methods: &#123; subFn()&#123; this.$emit(&#x27;subprice&#x27;, this.index, 1) // 子向父 eventBus.$emit(&quot;send&quot;, this.index, 1) // 跨组件 &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.my-product &#123; width: 400px; padding: 20px; border: 2px solid #000; border-radius: 5px; margin: 10px;&#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//App.vue&lt;template&gt; &lt;div&gt; &lt;!-- 目标: 子传父 --&gt; &lt;!-- 1. 父组件, @自定义事件名=&quot;父methods函数&quot; --&gt; &lt;MyProduct v-for=&quot;(obj, ind) in list&quot; :key=&quot;obj.id&quot; :title=&quot;obj.proname&quot; :price=&quot;obj.proprice&quot; :intro=&quot;obj.info&quot; :index=&quot;ind&quot; @subprice=&quot;fn&quot; &gt;&lt;/MyProduct&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyProduct from &#x27;./components/MyProduct_sub&#x27;export default &#123; data() &#123; return &#123; list: [ &#123; id: 1, proname: &quot;超级好吃的棒棒糖&quot;, proprice: 18.8, info: &quot;开业大酬宾, 全场8折&quot;, &#125;, &#123; id: 2, proname: &quot;超级好吃的大鸡腿&quot;, proprice: 34.2, info: &quot;好吃不腻, 快来买啊&quot;, &#125;, &#123; id: 3, proname: &quot;超级无敌的冰激凌&quot;, proprice: 14.2, info: &quot;炎热的夏天, 来个冰激凌了&quot;, &#125;, ], &#125;; &#125;, components: &#123; MyProduct &#125;, methods: &#123; fn(inde, price)&#123; // 逻辑代码 this.list[inde].proprice &gt; 1 &amp;&amp; (this.list[inde].proprice = (this.list[inde].proprice - price).toFixed(2)) &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 4.5 vue组件通信-EventBus 常用于跨组件通信时使用 两个组件的关系非常的复杂，通过父子组件通讯是非常麻烦的。这时候可以使用通用的组件通讯方案：事件总线（event-bus) 123import Vue from &#x27;vue&#x27;// 导出空白vue对象export default new Vue() 1234567891011121314151617181920212223242526272829303132//MyProduct_sub.vue&lt;template&gt; &lt;div class=&quot;my-product&quot;&gt; &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt; &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &#x27;../EventBus&#x27;export default &#123; props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;], methods: &#123; subFn()&#123; this.$emit(&#x27;subprice&#x27;, this.index, 1) // 子向父 eventBus.$emit(&quot;send&quot;, this.index, 1) // 跨组件 &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.my-product &#123; width: 400px; padding: 20px; border: 2px solid #000; border-radius: 5px; margin: 10px;&#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536//List.vue&lt;template&gt; &lt;ul class=&quot;my-product&quot;&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt; &lt;span&gt;&#123;&#123; item.proname &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; item.proprice &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;// 目标: 跨组件传值// 1. 引入空白vue对象(EventBus)// 2. 接收方 - $on监听事件import eventBus from &quot;../EventBus&quot;;export default &#123; props: [&quot;arr&quot;], // 3. 组件创建完毕, 监听send事件 created() &#123; eventBus.$on(&quot;send&quot;, (index, price) =&gt; &#123; this.arr[index].proprice &gt; 1 &amp;&amp; (this.arr[index].proprice = (this.arr[index].proprice - price).toFixed(2)); &#125;); &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.my-product &#123; width: 400px; padding: 20px; border: 2px solid #000; border-radius: 5px; margin: 10px;&#125;&lt;/style&gt; findIndex()** 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。 4.6 总结4.6.1. 请说下封装 vue 组件的过程​ 首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。 分析需求：确定业务需求，把页面中可以复用的结构，样式以及功能，单独抽离成一个组件，实现复用 具体步骤：Vue.component 或者在new Vue配置项components中, 定义组件名, 可以在props中接受给组件传的参数和值，子组件修改好数据后，想把数据传递给父组件。可以采用$emit方法。 4.6.2. Vue组件如何进行传值的父向子 -&gt; props定义变量 -&gt; 父在使用组件用属性给props变量传值 子向父 -&gt; $emit触发父的事件 -&gt; 父在使用组件用@自定义事件名&#x3D;父的方法 (子把值带出来) 4.6.3. Vue 组件 data 为什么必须是函数每个组件都是 Vue 的实例, 为了独立作用域, 不让变量污染别人的变量 4.6.4. 讲一下组件的命名规范​ 给组件命名有两种方式(在Vue.Component&#x2F;components时)，一种是使用链式命名”my-component”，一种是使用大驼峰命名”MyComponent”， ​ 因为要遵循W3C规范中的自定义组件名 (字母全小写且必须包含一个连字符)，避免和当前以及未来的 HTML 元素相冲突 5 vue生命周期5.1 钩子函数特定的时间点，执行特定的操作 场景: 组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据 分类: 4大阶段8个方法 初始化 挂载 更新 销毁 销毁 阶段 方法名 方法名 初始化 beforeCreate created 挂载 beforeMount mounted 更新 beforeUpdate updated 销毁 beforeDestroy destroyed 6 axios基本使用6.1 axios的基本使用1234567891011121314axios(&#123; method: &#x27;请求方式&#x27;, // get post url: &#x27;请求地址&#x27;, data: &#123; // 拼接到请求体的参数, post请求的参数 xxx: xxx, &#125;, params: &#123; // 拼接到请求行的参数, get请求的参数 xxx: xxx &#125;&#125;).then(res =&gt; &#123; console.log(res.data) // 后台返回的结果&#125;).catch(err =&gt; &#123; console.log(err) // 后台报错返回&#125;) 6.2 axios 获取数据123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取所有图书信息&lt;/p&gt; &lt;button @click=&quot;getAllFn&quot;&gt;点击-查看控制台&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标1: 获取所有图书信息// 1. 下载axios// 2. 引入axios// 3. 发起axios请求import axios from &quot;axios&quot;;export default &#123; methods: &#123; getAllFn() &#123; axios(&#123; url: &quot;http://123.57.109.30:3006/api/getbooks&quot;, method: &quot;GET&quot;, // 默认就是GET方式请求, 可以省略不写 &#125;).then((res) =&gt; &#123; console.log(res); &#125;); // axios()-原地得到Promise对象 &#125;, &#125;&#125;;&lt;/script&gt; 6.3 axios 传参1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;p&gt;2. 查询某本书籍信息&lt;/p&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入要查询 的书名&quot; v-model=&quot;bName&quot; /&gt; &lt;button @click=&quot;findFn&quot;&gt;查询&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;export default &#123; data() &#123; return &#123; bName: &quot;&quot; &#125;; &#125;, methods: &#123; // ...省略了查询所有的代码 findFn() &#123; axios(&#123; url: &quot;/api/getbooks&quot;, method: &quot;GET&quot;, params: &#123; // 都会axios最终拼接到url?后面 bookname: this.bName &#125; &#125;).then(res =&gt; &#123; console.log(res); &#125;) &#125; &#125;,&#125;;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div&gt; &lt;p&gt;3. 新增图书信息&lt;/p&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;书名&quot; v-model=&quot;bookObj.bookname&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;作者&quot; v-model=&quot;bookObj.author&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;出版社&quot; v-model=&quot;bookObj.publisher&quot;&gt; &lt;/div&gt; &lt;button @click=&quot;sendFn&quot;&gt;发布&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;export default &#123; data() &#123; return &#123; bName: &quot;&quot;, bookObj: &#123; // 参数名提前和后台的参数名对上-发送请求就不用再次对接了 bookname: &quot;&quot;, author: &quot;&quot;, publisher: &quot;&quot; &#125; &#125;; &#125;, methods: &#123; // ...省略了其他代码 sendFn()&#123; axios(&#123; url: &quot;/api/addbook&quot;, method: &quot;POST&quot;, data: &#123; appkey: &quot;7250d3eb-18e1-41bc-8bb2-11483665535a&quot;, ...this.bookObj // 等同于下面 // bookname: this.bookObj.bookname, // author: this.bookObj.author, // publisher: this.bookObj.publisher &#125; &#125;) &#125; &#125;,&#125;;&lt;/script&gt; 6.4 axios基本使用-全局配置 目标: 避免前缀基地址, 暴露在逻辑页面里, 统一设置 123456789101112axios.defaults.baseURL = &quot;http://123.57.109.30:3006&quot;// 所有请求的url前置可以去掉, 请求时, axios会自动拼接baseURL的地址在前面getAllFn() &#123; axios(&#123; url: &quot;/api/getbooks&quot;, method: &quot;GET&quot;, // 默认就是GET方式请求, 可以省略不写 &#125;).then((res) =&gt; &#123; console.log(res); &#125;); // axios()-原地得到Promise对象&#125;, 7. nextTick和$refs知识7.1 $refs-获取DOM 目标: 利用 ref 和 $refs 可以用于获取 dom 元素 获取组件对象 1.创建组件&#x2F;引入组件&#x2F;注册组件&#x2F;使用组件 2.组件起别名ref 3.恰当时机, 获取组件对象 总结: 通过id &#x2F; ref, 都可以获取原生DOM标签 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt; &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象export default &#123; mounted()&#123; console.log(document.getElementById(&quot;h&quot;)); // h1 console.log(this.$refs.myH); // h1 &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 7.2$refs-获取组件对象总结: ref定义值, 通过$refs.值 来获取组件对象, 就能继续调用组件内的变量 12345678910111213141516//components/Child/Demo.vue&lt;template&gt; &lt;div&gt; &lt;p&gt;我是Demo组件&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fn()&#123; console.log(&quot;demo组件内的方法被调用了&quot;); &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829//More.vue - 获取组件对象 - 调用组件方法&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt; &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt; &lt;p&gt;2. 获取组件对象 - 可调用组件内一切&lt;/p&gt; &lt;Demo ref=&quot;de&quot;&gt;&lt;/Demo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123; mounted()&#123; console.log(document.getElementById(&quot;h&quot;)); // h1 console.log(this.$refs.myH); // h1 let demoObj = this.$refs.de; demoObj.fn() &#125;, components: &#123; Demo &#125;&#125;&lt;/script&gt; 7.3 $nextTick使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; &lt;p&gt;1. 获取原生DOM元素&lt;/p&gt; &lt;h1 id=&quot;h&quot; ref=&quot;myH&quot;&gt;我是一个孤独可怜又能吃的h1&lt;/h1&gt; &lt;p&gt;2. 获取组件对象 - 可调用组件内一切&lt;/p&gt; &lt;Demo ref=&quot;de&quot;&gt;&lt;/Demo&gt; &lt;p&gt;3. vue更新DOM是异步的&lt;/p&gt; &lt;p ref=&quot;myP&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;btn&quot;&gt;点击count+1, 马上提取p标签内容&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 获取组件对象// 1. 创建组件/引入组件/注册组件/使用组件// 2. 组件起别名ref// 3. 恰当时机, 获取组件对象import Demo from &#x27;./Child/Demo&#x27;export default &#123; mounted()&#123; console.log(document.getElementById(&quot;h&quot;)); // h1 console.log(this.$refs.myH); // h1 let demoObj = this.$refs.de; demoObj.fn() &#125;, components: &#123; Demo &#125;, data()&#123; return &#123; count: 0 &#125; &#125;, methods: &#123; btn()&#123; this.count++; // vue监测数据更新, 开启一个DOM更新队列(异步任务) console.log(this.$refs.myP.innerHTML); // 0 // 原因: Vue更新DOM异步 // 解决: this.$nextTick() // 过程: DOM更新完会挨个触发$nextTick里的函数体 this.$nextTick(() =&gt; &#123; console.log(this.$refs.myP.innerHTML); // 1 &#125;) &#125; &#125;&#125;&lt;/script&gt; 7.4 $nextTick使用场景1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;input ref=&quot;myInp&quot; type=&quot;text&quot; placeholder=&quot;这是一个输入框&quot; v-if=&quot;isShow&quot;&gt; &lt;button v-else @click=&quot;btn&quot;&gt;点击我进行搜索&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 点按钮(消失) - 输入框出现并聚焦// 1. 获取到输入框// 2. 输入框调用事件方法focus()达到聚焦行为export default &#123; data()&#123; return &#123; isShow: false &#125; &#125;, methods: &#123; async btn()&#123; this.isShow = true; // this.$refs.myInp.focus() // 原因: data变化更新DOM是异步的 // 输入框还没有挂载到真实DOM上 // 解决: // this.$nextTick(() =&gt; &#123; // this.$refs.myInp.focus() // &#125;) // 扩展: await取代回调函数 // $nextTick()原地返回Promise对象 await this.$nextTick() this.$refs.myInp.focus() &#125; &#125;&#125;&lt;/script&gt; 7.5 组件name属性使用 可以用组件的name属性值, 来注册组件名字 问题: 组件名不是可以随便写的? 答案: 我们封装的组件-可以自己定义name属性组件名-让使用者有个统一的前缀风格 123456789101112//components/Com.vue&lt;template&gt; &lt;div&gt; &lt;p&gt;我是一个Com组件&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ComNameHaHa&quot; // 注册时可以定义自己的名字&#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243//App.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;1. 生命周期&lt;/h1&gt; &lt;Life v-if=&quot;show&quot;&gt;&lt;/Life&gt; &lt;button @click=&quot;show = false&quot;&gt;销毁组件&lt;/button&gt; &lt;hr&gt; &lt;h1&gt;2. axios使用&lt;/h1&gt; &lt;UseAxios&gt;&lt;/UseAxios&gt; &lt;hr&gt; &lt;h1&gt;3. $refs的使用&lt;/h1&gt; &lt;More&gt;&lt;/More&gt; &lt;hr&gt; &lt;h1&gt;4. $nextTick使用场景&lt;/h1&gt; &lt;Tick&gt;&lt;/Tick&gt; &lt;hr&gt; &lt;h1&gt;5. 组件对象里name属性&lt;/h1&gt; &lt;ComNameHaHa&gt;&lt;/ComNameHaHa&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Life from &#x27;./components/Life&#x27;import UseAxios from &#x27;./components/UseAxios&#x27;import More from &#x27;./components/More&#x27;import Tick from &#x27;./components/Tick&#x27;import Com from &#x27;./components/Com&#x27;export default &#123; data()&#123; return &#123; show: true &#125; &#125;, components: &#123; Life, UseAxios, More, Tick, [Com.name]: Com // 对象里的key是变量的话[]属性名表达式 // &quot;ComNameHaHa&quot;: Com &#125;&#125;&lt;/script&gt; 7.6 总结7.6.1 Vue 的 nextTick 的原理是什么? （高薪常问）​ \\1. 为什么需要 nextTick ，Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改–刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。 ​ \\2. 理解原理前的准备 首先需要知道事件循环中宏任务和微任务这两个概念,常见的宏任务有 script, setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering 常见的微任务有 process.nextTick(Nodejs),Promise.then(), MutationObserver; ​ \\3. 理解 nextTick 的原理正是 vue 通过异步队列控制 DOM 更新和 nextTick 回调函数先后执行的方式。如果大家看过这部分的源码，会发现其中做了很多 isNative()的判断，因为这里还存在兼容性优雅降级的问题。可见 Vue 开发团队的深思熟虑，对性能的良苦用心。 7.6.2 vue生命周期总共分为几个阶段？（必会） Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 1****）beforeCreate ​ 在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。 2****）created ​ 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)， 属性和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 3****）beforeMount ​ 在挂载开始之前被调用：相关的 render 函数首次被调用。 4****）mounted ​ el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 5****）beforeUpdate ​ 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 6****）updated ​ 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 7****）activated ​ keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。 8****）deactivated ​ keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。 9****）beforeDestroy ​ 实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。 10****）destroyed ​ Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 11****）errorCaptured（2.5.0+ 新增） ​ 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 7.6.3 第一次加载页面会触发哪几个钩子函数？（必会） 当页面第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子函数 8 组件进阶8.1动态组件多个组件使用同一个挂载点，并动态切换，这就是动态组件 设置挂载点 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;comName = &#x27;UserName&#x27;&quot;&gt;账号密码填写&lt;/button&gt; &lt;button @click=&quot;comName = &#x27;UserInfo&#x27;&quot;&gt;个人信息填写&lt;/button&gt; &lt;p&gt;下面显示注册组件-动态切换:&lt;/p&gt; &lt;div style=&quot;border: 1px solid red;&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 动态组件 - 切换组件显示// 设置挂载点&lt;component&gt;, 使用is属性来设置要显示哪个组件// 场景: 同一个挂载点要切换 不同组件 显示// 1. 创建要被切换的组件 - 标签+样式// 2. 引入到要展示的vue文件内, 注册// 3. 变量-承载要显示的组件名// 4. 设置挂载点&lt;component :is=&quot;变量&quot;&gt;&lt;/component&gt;// 5. 点击按钮-切换comName的值为要显示的组件名import UserName from &#x27;../components/01/UserName&#x27;import UserInfo from &#x27;../components/01/UserInfo&#x27;export default &#123; data()&#123; return &#123; comName: &quot;UserName&quot; &#125; &#125;, components: &#123; UserName, UserInfo &#125;&#125;&lt;/script&gt; vue内置component组件, 配合is属性, 设置要显示的组件名字 8.2 组件缓存 组件切换会导致组件被频繁销毁和重新创建, 性能不高 使用Vue内置的keep-alive组件, 可以让包裹的组件保存在内存中不被销毁 演示1: 可以先给UserName.vue和UserInfo.vue 注册created和destroyed生命周期事件, 观察创建和销毁过程 演示2: 使用keep-alive内置的vue组件, 让动态组件缓存而不是销毁 语法: ​ Vue内置的keep-alive组件 包起来要频繁切换的组件 123456&lt;div style=&quot;border: 1px solid red;&quot;&gt; &lt;!-- Vue内置keep-alive组件, 把包起来的组件缓存起来 --&gt; &lt;keep-alive&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt; 补充生命周期: activated - 激活 deactivated - 失去激活状态 总结: keep-alive可以提高组件的性能, 内部包裹的标签不会被销毁和重新创建, 触发激活和非激活的生命周期方法 8.3 激活和非激活 标: 被缓存的组件不再创建和销毁, 而是激活和非激活 补充2个钩子方法名: ​ activated – 激活时触发 ​ deactivated – 失去激活状态触发 8.4 组件插槽vue提供组件插槽能力, 允许开发者在封装组件时，把不确定的部分定义为插槽 组件内用占位 8.4.1 插槽默认内容 如果外面不给传, 想给个默认显示内容 口诀: 夹着内容默认显示内容, 如果不给插槽slot传东西, 则使用夹着的内容在原地显示 1&lt;slot&gt;默认内容&lt;/slot&gt; 8.4.2 具名插槽当一个组件内有2处以上需要外部传入标签的地方 传入的标签可以分别派发给不同的slot位置 要求: v-slot一般用跟template标签使用 (template是html5新出标签内容模板元素, 不会渲染到页面上, 一般被vue解析内部标签) v-slot:title 简写 # 内容 &lt;template #title&gt;内容 8.4.3 作用域插槽目标: 子组件里值, 在给插槽赋值时在父组件环境下使用 复习: 插槽内slot中显示默认内容 例子: 默认内容在子组件中, 但是父亲在给插槽传值, 想要改变插槽显示的默认内容 口诀: 子组件, 在slot上绑定属性和子组件内的值 使用组件, 传入自定义标签, 用template和v-slot&#x3D;”自定义变量名” scope变量名自动绑定slot上所有属性和值 8.5 自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 v-xxx html+css的复用的主要形式是组件 你需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令 8.5.1 自定义指令-注册1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;!-- &lt;input type=&quot;text&quot; v-gfocus&gt; --&gt; &lt;input type=&quot;text&quot; v-focus&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 创建 &quot;自定义指令&quot;, 让输入框自动聚焦// 1. 创建自定义指令// 全局 / 局部// 2. 在标签上使用自定义指令 v-指令名// 注意:// inserted方法 - 指令所在标签, 被插入到网页上触发(一次)// update方法 - 指令对应数据/标签更新时, 此方法执行export default &#123; data()&#123; return &#123; colorStr: &#x27;red&#x27; &#125; &#125;, directives: &#123; focus: &#123; inserted(el)&#123; el.focus() &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456// 全局指令 - 到处&quot;直接&quot;使用Vue.directive(&quot;gfocus&quot;, &#123; inserted(el) &#123; el.focus() // 触发标签的事件方法 &#125;&#125;) 8.5.2 自定义指令-传值123456789// 目标: 自定义指令传值Vue.directive(&#x27;color&#x27;, &#123; inserted(el, binding) &#123; el.style.color = binding.value &#125;, update(el, binding) &#123; el.style.color = binding.value &#125;&#125;) 在main.js用 Vue.directive()方法来进行注册, 以后随便哪个.vue文件里都可以直接用v-fofo指令 directives&#x2F;&#x2F; 目标: 创建 “自定义指令”, 让输入框自动聚焦&#x2F;&#x2F; 1. 创建自定义指令&#x2F;&#x2F; 全局 &#x2F; 局部&#x2F;&#x2F; 2. 在标签上使用自定义指令 v-指令名&#x2F;&#x2F; 注意:&#x2F;&#x2F; inserted方法 - 指令所在标签, 被插入到网页上触发(一次)&#x2F;&#x2F; update方法 - 指令对应数据&#x2F;标签更新时, 此方法执行 1234567891011121314&lt;p v-color=&quot;colorStr&quot; @click=&quot;changeColor&quot;&gt;修改文字颜色&lt;/p&gt;&lt;script&gt; data() &#123; return &#123; theColor: &quot;red&quot;, &#125;; &#125;, methods: &#123; changeColor() &#123; this.theColor = &#x27;blue&#x27;; &#125;, &#125;,&lt;/script&gt; 8.6 总结8.6.1. vue中solt的使用方式，以及solt作用域插槽的用法 使用方式：当组件当做标签进行使用的时候，用slot可以用来接受组件标签包裹的内容，当给solt标签添加name属性的 时候，可以调换响应的位置 (高级用法) 插槽作用域： 当传递的不是单一的标签, 例如需要循环时, 把要循环的标签传入, 组件内使用v-for在slot标签上, 内部可以v-bind:把值传出来, 再外面把值赋予进去, 看示例 123456789101112&lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt;&lt;/current-user&gt;// current-user组件, user属性和值, 绑定给slotProps上&lt;span&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &#123;&#123; user.lastName &#125;&#125; &lt;/slot&gt;&lt;/span&gt; 扩展阅读: https://cn.vuejs.org/v2/guide/components-slots.html (了解即可, 一般用不上) 8.6.2. 跟keep-alive有关的生命周期是哪些？（必会）​ 1****）前言：在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染，在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染 ​ 2****）生命周期函数：在被keep-alive包含的组件&#x2F;路由中，会多出两个生命周期的钩子:activated 与 deactivated。 ​ 1****、activated钩子：在在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。 ​ 2****、Activated钩子调用时机： 第一次进入缓存路由&#x2F;组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用，并且给因为组件被缓存了，再次进入缓存路由、组件时，不会触发这些钩子函数，beforeCreate created beforeMount mounted 都不会触发 ​ 1****、deactivated钩子：组件被停用（离开路由）时调用。 ​ 2****、deactivated钩子调用时机：使用keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了，这个钩子可以看作beforeDestroy的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，可以放在这个钩子里，组件内的离开当前路由钩子beforeRouteLeave &#x3D;&gt; 路由前置守卫 beforeEach &#x3D;&gt;全局后置钩子afterEach &#x3D;&gt; deactivated 离开缓存组件 &#x3D;&gt; activated 进入缓存组件(如果你进入的也是缓存路由) 8.6.3. 自定义指令(v-check、v-focus)的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）​ 全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives ​ 钩子函数：bind(绑定事件触发)、inserted(节点插入的时候触发)、update(组件内相关更新) ​ 钩子函数参数：el、binding 8.6.4. is这个特性你有用过吗？主要用在哪些方面？（高薪常问） 1****）动态组件 ​ ， componentName可以是在本页面已经注册的局部组件名和全局组件名,也可以是一个组件的选项对象。 当控制componentName改变时就可以动态切换选择组件。  2****）is的用法 ​ 有些HTML元素，诸如 、、和，对于哪些元素可以出现在其内部是有严格限制的。 ​ 而有些HTML元素，诸如 、 和 ，只能出现在其它某些特定的元素内部。 ​ ​ ​ ​ 所以上面会被作为无效的内容提升到外部，并导致最终渲染结果出错。应该这么写： ​ ​ ​ 9 vue-router路由 安装 1yarn add vue-router 导入路由 1import VueRouter from &#x27;vue-router&#x27; 使用路由插件 12// 在vue中，使用使用vue的插件，都需要调用Vue.use()Vue.use(VueRouter) 创建路由规则数组 1234567891011121314const routes = [ &#123; path: &quot;/find&quot;, component: Find &#125;, &#123; path: &quot;/my&quot;, component: My &#125;, &#123; path: &quot;/part&quot;, component: Part &#125;] 创建路由对象 - 传入规则 123const router = new VueRouter(&#123; routes&#125;) 关联到vue实例 123new Vue(&#123; router&#125;) components换成router-view 1&lt;router-view&gt;&lt;/router-view&gt; 总结: 下载路由模块, 编写对应规则注入到vue实例上, 使用router-view挂载点显示切换的路由 9.1 声明式导航 可用全局组件router-link来替代a标签 vue-router提供了一个全局组件 router-link router-link实质上最终会渲染成a链接 to属性等价于提供 href属性(to无需#) router-link提供了声明式导航高亮的功能(自带类名) 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;div class=&quot;footer_wrap&quot;&gt; &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt; &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt; &lt;router-link to=&quot;/part&quot;&gt;朋友&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;top&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;/* 省略了 其他样式 */.footer_wrap .router-link-active&#123; color: white; background: black;&#125;&lt;/style&gt; 总结: 链接导航, 用router-link配合to, 实现点击切换路由 9.2 声明式导航 - 跳转传参 在跳转路由时, 可以给路由对应的组件内传值 在router-link上的to属性传值, 语法格式如下 &#x2F;path?参数名&#x3D;值 &#x2F;path&#x2F;值 – 需要路由对象提前配置 path: “&#x2F;path&#x2F;参数名” 对应页面组件接收传递过来的值 $route.query.参数名 $route.params.参数名 创建components&#x2F;Part.vue - 准备接收路由上传递的参数和值 123456789&lt;template&gt; &lt;div&gt; &lt;p&gt;关注明星&lt;/p&gt; &lt;p&gt;发现精彩&lt;/p&gt; &lt;p&gt;寻找伙伴&lt;/p&gt; &lt;p&gt;加入我们&lt;/p&gt; &lt;p&gt;人名: &#123;&#123; $route.query.name &#125;&#125; -- &#123;&#123; $route.params.username &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 路由定义 12345678&#123; path: &quot;/part&quot;, component: Part &#125;, &#123; path: &quot;/part/:username&quot;, // 有:的路径代表要接收具体的值 component: Part &#125;, 导航跳转, 传值给MyGoods.vue组件 12&lt;router-link to=&quot;/part?name=小传&quot;&gt;朋友-小传&lt;/router-link&gt;&lt;router-link to=&quot;/part/小智&quot;&gt;朋友-小智&lt;/router-link&gt; 总结: ?key&#x3D;value 用$route.query.key 取值 &#x2F;值 提前在路由规则&#x2F;path&#x2F;:key 用$route.params.key 取值 9.3 路由 - 重定向 匹配path后, 强制切换到目标path上 网页打开url默认hash值是&#x2F;路径 redirect是设置要重定向到哪个路由路径 例如: 网页默认打开, 匹配路由”&#x2F;“, 强制切换到”&#x2F;find”上 1234567const routes = [ &#123; path: &quot;/&quot;, // 默认hash值路径 redirect: &quot;/find&quot; // 重定向到/find // 浏览器url中#后的路径被改变成/find-重新匹配数组规则 &#125;] 总结: 强制重定向后, 还会重新来数组里匹配一次规则 9.4 路由 - 404页面 目标: 如果路由hash值, 没有和数组里规则匹配 默认给一个404页面 语法: 路由最后, path匹配*(任意路径) – 前面不匹配就命中最后这个, 显示对应组件页面 创建NotFound页面 123456789101112131415&lt;template&gt; &lt;img src=&quot;../assets/404.png&quot; alt=&quot;&quot;&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt; img&#123; width: 100%; &#125;&lt;/style&gt; 在main.js - 修改路由配置 12345678910import NotFound from &#x27;@/views/NotFound&#x27;const routes = [ // ...省略了其他配置 // 404在最后(规则是从前往后逐个比较path) &#123; path: &quot;*&quot;, component: NotFound &#125;] 总结: 如果路由未命中任何规则, 给出一个兜底的404页面 9.5 路由 - 模式设置 目标: 修改路由在地址栏的模式 hash路由例如: http://localhost:8080/#/home history路由例如: http://localhost:8080/home (以后上线需要服务器端支持, 否则找的是文件夹) 模式文档 router&#x2F;index.js 1234const router = new VueRouter(&#123; routes, mode: &quot;history&quot; // 打包上线后需要后台支持, 模式是hash&#125;) 9.6. vue路由 - 编程式导航 用JS代码来进行跳转 语法: 1234this.$router.push(&#123; path: &quot;路由路径&quot;, // 都去 router/index.js定义 name: &quot;路由名&quot;&#125;) main.js - 路由数组里, 给路由起名字 123456789101112131415&#123; path: &quot;/find&quot;, name: &quot;Find&quot;, component: Find&#125;,&#123; path: &quot;/my&quot;, name: &quot;My&quot;, component: My&#125;,&#123; path: &quot;/part&quot;, name: &quot;Part&quot;, component: Part&#125;, App.vue - 换成span 配合js的编程式导航跳转 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;div class=&quot;footer_wrap&quot;&gt; &lt;span @click=&quot;btn(&#x27;/find&#x27;, &#x27;Find&#x27;)&quot;&gt;发现音乐&lt;/span&gt; &lt;span @click=&quot;btn(&#x27;/my&#x27;, &#x27;My&#x27;)&quot;&gt;我的音乐&lt;/span&gt; &lt;span @click=&quot;btn(&#x27;/part&#x27;, &#x27;Part&#x27;)&quot;&gt;朋友&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;top&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 编程式导航 - js方式跳转路由// 语法:// this.$router.push(&#123;path: &quot;路由路径&quot;&#125;)// this.$router.push(&#123;name: &quot;路由名&quot;&#125;)// 注意:// 虽然用name跳转, 但是url的hash值还是切换path路径值// 场景:// 方便修改: name路由名(在页面上看不见随便定义)// path可以在url的hash值看到(尽量符合组内规范)export default &#123; methods: &#123; btn(targetPath, targetName)&#123; // 方式1: path跳转 this.$router.push(&#123; // path: targetPath, name: targetName &#125;) &#125; &#125;&#125;;&lt;/script&gt; 9.7 编程式导航 - 跳转传参 目标: JS跳转路由, 传参 语法 query &#x2F; params 任选 一个 12345678910111213this.$router.push(&#123; path: &quot;路由路径&quot; name: &quot;路由名&quot;, query: &#123; &quot;参数名&quot;: 值 &#125; params: &#123; &quot;参数名&quot;: 值 &#125;&#125;)// 对应路由接收 $route.params.参数名 取值// 对应路由接收 $route.query.参数名 取值 &#x3D;&#x3D;格外注意: 使用path会自动忽略params&#x3D;&#x3D; App.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;div class=&quot;footer_wrap&quot;&gt; &lt;span @click=&quot;btn(&#x27;/find&#x27;, &#x27;Find&#x27;)&quot;&gt;发现音乐&lt;/span&gt; &lt;span @click=&quot;btn(&#x27;/my&#x27;, &#x27;My&#x27;)&quot;&gt;我的音乐&lt;/span&gt; &lt;span @click=&quot;oneBtn&quot;&gt;朋友-小传&lt;/span&gt; &lt;span @click=&quot;twoBtn&quot;&gt;朋友-小智&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;top&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 目标: 编程式导航 - 跳转路由传参// 方式1:// params =&gt; $route.params.参数名// 方式2:// query =&gt; $route.query.参数名// 重要: path会自动忽略params// 推荐: name+query方式传参// 注意: 如果当前url上&quot;hash值和?参数&quot;与你要跳转到的&quot;hash值和?参数&quot;一致, 爆出冗余导航的问题, 不会跳转路由export default &#123; methods: &#123; btn(targetPath, targetName)&#123; // 方式1: path跳转 this.$router.push(&#123; // path: targetPath, name: targetName &#125;) &#125;, oneBtn()&#123; this.$router.push(&#123; name: &#x27;Part&#x27;, params: &#123; username: &#x27;小传&#x27; &#125; &#125;) &#125;, twoBtn()&#123; this.$router.push(&#123; name: &#x27;Part&#x27;, query: &#123; name: &#x27;小智&#x27; &#125; &#125;) &#125; &#125;&#125;;&lt;/script&gt; 总结: 传参2种方式 query方式 params方式 9.8 vue路由 - 路由嵌套 在现有的一级路由下, 再嵌套二级路由 二级路由示例-网易云音乐-发现音乐下 router-view嵌套架构图 创建需要用的所有组件 src&#x2F;views&#x2F;Find.vue – 发现音乐页 src&#x2F;views&#x2F;My.vue – 我的音乐页 src&#x2F;views&#x2F;Second&#x2F;Recommend.vue – 发现音乐页 &#x2F; 推荐页面 src&#x2F;views&#x2F;Second&#x2F;Ranking.vue – 发现音乐页 &#x2F; 排行榜页面 src&#x2F;views&#x2F;Second&#x2F;SongList.vue – 发现音乐页 &#x2F; 歌单页面 main.js– 继续配置2级路由 一级路由path从&#x2F;开始定义 二级路由往后path直接写名字, 无需&#x2F;开头 嵌套路由在上级路由的children数组里编写路由信息对象 说明： App.vue的router-view负责发现音乐和我的音乐页面, 切换 Find.vue的的router-view负责发现音乐下的, 三个页面, 切换 配置二级导航和样式(&#x3D;&#x3D;可直接复制&#x3D;&#x3D;) - 在Find.vue中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;!-- &lt;p&gt;推荐&lt;/p&gt; &lt;p&gt;排行榜&lt;/p&gt; &lt;p&gt;歌单&lt;/p&gt; --&gt; &lt;div class=&quot;nav_main&quot;&gt; &lt;router-link to=&quot;/find/recommend&quot;&gt;推荐&lt;/router-link&gt; &lt;router-link to=&quot;/find/ranking&quot;&gt;排行榜&lt;/router-link&gt; &lt;router-link to=&quot;/find/songlist&quot;&gt;歌单&lt;/router-link&gt; &lt;/div&gt; &lt;div style=&quot;1px solid red;&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style scoped&gt;.nav_main &#123; background-color: red; color: white; padding: 10px 0;&#125;.nav_main a &#123; text-align: center; text-decoration: none; color: white; font-size: 12px; margin: 7px 17px 0; padding: 0px 15px 2px 15px; height: 20px; display: inline-block; line-height: 20px; border-radius: 20px;&#125;.nav_main a:hover &#123; background-color: brown;&#125;.nav_main .router-link-active&#123; background-color: brown;&#125;&lt;/style&gt; 配置路由规则-二级路由展示 1234567891011121314151617181920212223const routes = [ // ...省略其他 &#123; path: &quot;/find&quot;, name: &quot;Find&quot;, component: Find, children: [ &#123; path: &quot;recommend&quot;, component: Recommend &#125;, &#123; path: &quot;ranking&quot;, component: Ranking &#125;, &#123; path: &quot;songlist&quot;, component: SongList &#125; ] &#125; // ...省略其他] 说明： App.vue, 外层的router-view负责发现音乐和我的音乐页面切换 Find.vue 内层的router-view负责发现音乐下的子tab对应的组件切换 运行 - 点击导航观察嵌套路由在哪里展示 总结: 嵌套路由, 找准在哪个页面里写router-view和对应规则里写children 9.8.1 声明导航 - 类名区别 目标: router-link自带的2个类名的区别是什么 观察路由嵌套导航的样式 router-link-exact-active (精确匹配) url中hash值路径, 与href属性值完全相同, 设置此类名 router-link-active (模糊匹配) url中hash值, 包含href属性值这个路径 9.9 全局前置守卫 目标: 路由跳转之前, 先执行一次前置守卫函数, 判断是否可以正常跳转 使用例子: 在跳转路由前, 判断用户登陆了才能去&lt;我的音乐&gt;页面, 未登录弹窗提示回到发现音乐页面 在路由对象上使用固定方法beforeEach 123456789101112131415161718// 目标: 路由守卫// 场景: 当你要对路由权限判断时// 语法: router.beforeEach((to, from, next)=&gt;&#123;//路由跳转&quot;之前&quot;先执行这里, 决定是否跳转&#125;)// 参数1: 要跳转到的路由 (路由对象信息) 目标// 参数2: 从哪里跳转的路由 (路由对象信息) 来源// 参数3: 函数体 - next()才会让路由正常的跳转切换, next(false)在原地停留, next(&quot;强制修改到另一个路由路径上&quot;)// 注意: 如果不调用next, 页面留在原地// 例子: 判断用户是否登录, 是否决定去&quot;我的音乐&quot;/myconst isLogin = true; // 登录状态(未登录)router.beforeEach((to, from, next) =&gt; &#123; if (to.path === &quot;/my&quot; &amp;&amp; isLogin === false) &#123; alert(&quot;请登录&quot;) next(false) // 阻止路由跳转 &#125; else &#123; next() // 正常放行 &#125;&#125;) 总结: next()放行, next(false)留在原地不跳转路由, next(path路径)强制换成对应path路径跳转 10 vant组件库官网vant2: https://vant-contrib.gitee.io/vant/v2/#/zh-CN/ 安装插件 1yarn add babel-plugin-import -D 在babel配置文件里 (babel.config.js) 123456789module.exports = &#123; plugins: [ [&#x27;import&#x27;, &#123; libraryName: &#x27;vant&#x27;, libraryDirectory: &#x27;es&#x27;, style: true &#125;, &#x27;vant&#x27;] ]&#125;; 全局注册 - 会自动按需引入 123456// 方式1: 全局 - 自动按需引入vant组件// (1): 下载 babel-plugin-import// (2): babel.config.js - 添加官网说的配置 (一定要重启服务器)// (3): main.js 按需引入某个组件, Vue.use全局注册 - 某个.vue文件中直接使用vant组件import &#123; Button &#125; from &#x27;vant&#x27;;Vue.use(Button) // Button组件全局注册, 真正注册的组件名VanButton 10.1 总结10.1. 路由之间是怎么跳转的？有哪些方式1、 2、this.$router.push()跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面 3、this.$router.replace()跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面 4、this.$touter.go(n)向前或者后跳转n个页面，n可以是正数也可以是负数 10.2. vue-router怎么配置路由在vue中配置路由分为5个步骤，分别是： 引入vue-router.js 配置路由path和组件, 和生成路由对象 把路由对象配置到new Vue中router选项下 页面使用 承载路由 设置路由导航(声明式导航方式&#x2F;编程式跳转) 10.3. vue-router的钩子函数都有哪些关于vue-router中的钩子函数主要分为3类 全局钩子函数要包含beforeEach beforeEach函数有三个参数,分别是: ​ to:router即将进入的路由对象​ from:当前导航即将离开的路由​ next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是 confirmed （确认的）否则为false,终止导航。 单独路由独享组件 ​ beforeEnter, 组件内钩子 beforeRouterEnter， beforeRouterUpdate, beforeRouterLeave 10.4. 路由传值的方式有哪几种Vue-router传参可以分为两大类，分别是编程式的导航 router.push和声明式的导航 router.push 字符串：直接传递路由地址，但是不能传递参数 ​ this.$router.push(“home”) ​ 对象： ​ 命名路由 这种方式传递参数，目标页面刷新会报错 - name+params ​ this.$router.push({name:”news”,params:{userId:123}) ​ 查询参数 和path配对的是query ​ this.$router.push({path:”&#x2F;news’,query:{uersId:123}) ​ 接收参数 this.$route.query 声明式导航 ​ 字符串 &lt;router-link to:”news”&gt; ​ 命名路由 &lt;router-link :to:”{name:’news’,params:{userid:1111}}”&gt; ​ 还可以to&#x3D;”&#x2F;path&#x2F;值” - 需要提前在路由 规则里值 &#x2F;path&#x2F;:key ​ 查询参数 ​ 还可以to&#x3D;”&#x2F;path?key&#x3D;value 10.5. 怎么定义vue-router的动态路由?怎么获取传过来的动态参数? 动态路由指的就是path路径上传智, 前提需要路由规则了提前配置&#x2F;path&#x2F;:key名, 可以写多个用&#x2F;隔开, 获取使用$route.params.key名来提取对应用路径传过来的值 10.6. Vue的路由实现模式：hash模式和history模式（必会）hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更 10.7. 请说出路由配置项常用的属性及作用（必会）​ 路由配置参数： ​ path : 跳转路径​ component : 路径相对于的组件​ name:命名路由​ children:子路由的配置参数(路由嵌套)​ props:路由解耦​ redirect : 重定向路由 10.8. 编程式导航使用的方法以及常用的方法（必会）​ 路由跳转 ： this.$router.push()​ 路由替换 : this.$router.replace()​ 后退： this.$router.back()​ 前进 ：this.$router.forward() 10.9. Vue如何去除URL中的#（必会）​ vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 URL 会自带 “#”。如果不想使用 “#”， 可以使用 vue-router 的另一种模式 history：new Router ({ mode : ‘history’, routes: [ ]}) ​ 需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 “404” 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 “index.html” 页面。 10.10. 说一下你在vue中踩过的坑（必会）​ 1、第一个是给对象添加属性的时候，直接通过给data里面的对象添加属性然后赋值，新添加的属性不是响应式的 ​ 【解决办法】通过Vue.set(对象，属性，值)这种方式就可以达到，对象新添加的属性是响应式的 2、 在created操作dom的时候，是报错的，获取不到dom，这个时候实例vue实例没有挂载 ​ 【解决办法】通过：Vue.nextTick(回调函数进行获取) 10.11 $route&#x2F;router的区别？$route是路由信息对象，包括‘path，hash，query，fullPath，matched，name’等路由信息参数；$router是路由实例对象，包括了路由的跳转方法，实例对象等 11. 补充扩展12345//自定义校验规则 validator ( value ) &#123; 内容&#125;参数 value:接收到的数组","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"初识(七)","slug":"初识-七","date":"2022-11-06T03:49:05.000Z","updated":"2022-11-06T03:55:53.148Z","comments":true,"path":"2022/11/06/初识-七/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E4%B8%83/","excerpt":"","text":"Vue基础yarn包管理器快速、可靠、安全的依赖管理工具。和 npm 类似, 都是包管理工具, 可以用于下载包, 就是比npm快 中文官网地址: https://yarn.bootcss.com/ 下载yarn下载地址: https://yarn.bootcss.com/docs/install/#windows-stable windows - 软件包(在笔记文件夹里) mac - 通过homebrew安装(看上面地址里) mac如果没安装过homeBrew先运行这个命令 1/usr/bin/ruby -e &quot;$(curl -fsSL http://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot; 上面命令不行: 试试这个: curl -o- -L https://yarnpkg.com/install.sh | bash (直接安装yarn) &#x3D;&#x3D;不要安到带中文的路径下, 建议在C盘&#x2F;&#x3D;&#x3D; 使用yarn与npm类似, 可以试试, 新建一个空白文件夹, 执行以下命令尝试一下 1234567891011121314151617181920212223# 1. 初始化, 得到package.json文件(终端路径所在文件夹下)yarn init# 2. 添加依赖(下包)# 命令: yarn add [package]# 命令: yarn add [package]@[version]yarn add jqueryyarn add jquery@3.5.1# 3. 移除包# 命令: yarn remove [package]yarn remove jquery # 4. 安装项目全部依赖(一般拿到别人的项目时, 缺少node_modules) yarn# 会根据当前项目package.json记录的包名和版本, 全部下载到当前工程中# 5. 全局# 安装: yarn global add [package]# 卸载: yarn global remove [package]# 注意: global一定在add左边yarn global add @vue/cli# 如何使用, 为明天学习vue做铺垫 yarn可能遇到的问题如果报错参考报错文档: http://itcz_jiaoyu.gitee.io/error/#811 知识点自测对这些知识点了如指掌, 学习今天的内容会轻松很多 什么是模块, 模块化开发规范(CommonJS &#x2F; ES6) commonJS规范: 123// nodejs - commonJS规范-规定了导出和导入方式// 导出 module.exports = &#123;&#125;// 导入 const 变量 = require(&quot;模块标识&quot;) ES6规范 12// 导出 export 或者 export default &#123;&#125;// 导入 import 变量名 from &#x27;模块标识&#x27; 字体图标的使用 可以去阿里巴巴矢量图标库, 选中想要的图标, 登录后, 生成css文件和字体文件 下载css文件和字体文件, 也可以使用在线地址 在自己页面中引入iconfont.css, 并在想显示字体图标的标签上使用类名即可 箭头函数非常熟练 12345678910111213const fn = () =&gt; &#123;&#125; fn()const fn2 = (a, b) =&gt; &#123;return a + b&#125; fn(10, 20); // 结果是30// 当形参只有一个()可以省略const fn3 = a =&gt; &#123;return a * 2&#125;fn(50); // 结果是100// 当&#123;&#125;省略return也省略, 默认返回箭头后表达式结果const fn4 = a =&gt; a * 2;fn(50); // 结果是100 什么是服务器, 本地启动node服务, 服务器和浏览器关系, 服务器作用 123456789服务器是一台性能高, 24小时可以开机的电脑服务器可以提供服务(例如: 文件存储, 网页浏览, 资源返回)在window电脑里安装node后, 可以编写代码用node 启动一个web服务, 来读取本地html文件, 返回给浏览器查看浏览器 -&gt; 请求资源 -&gt; 服务器浏览器 &lt;- 响应数据 &lt;- 服务器 开发环境 和 生产环境 以及英文”development”, “production” 2个单词尽量会写会读 初始化包环境和package.json文件作用 1npm下载的包和对应版本号, 都会记录到下载包时终端所在文件夹下的package.json文件里 package.json中的dependencies和 devDependencies区别和作用 123* dependencies 别人使用你的包必须下载的依赖, 比如yarn add jquery* devDependencies 开发你的包需要依赖的包, 比如yarn add webpack webpack-cli -D (-D 相当于 --save-dev) 终端的熟练使用: 切换路径, 清屏, 包下载命令等 123切换路径 cd 清屏 cls 或者 clear 对base64字符串, 图片转base64字符串了解 在线装换图片http://tool.chinaz.com/tools/imgtobase/ 1. webpack基本概念webpack本身是, node的一个第三方模块包, 用于打包代码 现代 javascript 应用程序的 静态模块打包器 (module bundler) 为要学的 vue-cli 开发环境做铺垫 &#x3D;&#x3D;webpack能做什么&#x3D;&#x3D; 把很多文件打包整合到一起, 缩小项目体积, 提高加载速度 2. webpack的使用2.0_webpack基础使用默认入口: .&#x2F;src&#x2F;index.js 默认出口: .&#x2F;dist&#x2F;main.js &#x3D;&#x3D;注意:路径上, 文件夹, 文件名不能叫webpack&#x2F;其他已知的模块名&#x3D;&#x3D; 初始化包环境 1yarn init 安装依赖包 1yarn add webpack webpack-cli -D 配置scripts(自定义命令) 123scripts: &#123; &quot;build&quot;: &quot;webpack&quot;&#125; 新建目录src 新建src&#x2F;add&#x2F;add.js - 定义求和函数导出 1export const addFn = (a, b) =&gt; a + b 新建src&#x2F;index.js导入使用 123import &#123;addFn&#125; from &#x27;./add/add&#x27;console.log(addFn(10, 20)); 运行打包命令 12yarn build#或者 npm run build 总结: src并列处, 生成默认dist目录和打包后默认main.js文件 2.1_webpack 更新打包 目标: 以后代码变更, 如何重新打包呢 新建src&#x2F;tool&#x2F;tool.js - 定义导出数组求和方法 1export const getArrSum = arr =&gt; arr.reduce((sum, val) =&gt; sum += val, 0) src&#x2F;index.js - 导入使用 12345import &#123;addFn&#125; from &#x27;./add/add&#x27;import &#123;getArrSum&#125; from &#x27;./tool/tool&#x27;console.log(addFn(10, 20));console.log(getArrSum([1, 2, 3])); 重新打包 1yarn build 总结1: src下开发环境, dist是打包后, 分别独立 总结2: 打包后格式压缩, 变量压缩等 3. webpack的配置3.0_webpack-入口和出口 目标: 告诉webpack从哪开始打包, 打包后输出到哪里 默认入口: .&#x2F;src&#x2F;index.js 默认出口: .&#x2F;dist&#x2F;main.js webpack配置 - webpack.config.js(默认) 新建src并列处, webpack.config.js 填入配置项 123456789const path = require(&quot;path&quot;)module.exports = &#123; entry: &quot;./src/main.js&quot;, // 入口 output: &#123; path: path.join(__dirname, &quot;dist&quot;), // 出口路径 filename: &quot;bundle.js&quot; // 出口文件名 &#125;&#125; 修改package.json, 自定义打包命令 - 让webpack使用配置文件 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;&#125;, 打包观察效果 3.1_打包流程图3.2_案例-webpack隔行变色 目标: 工程化模块化开发前端项目, webpack会对ES6模块化处理 回顾从0准备环境 初始化包环境 下载依赖包 配置自定义打包命令 下载jquery, 新建public&#x2F;index.html 1yarn add jquery index.html 准备一些li &#x3D;&#x3D;因为import语法浏览器支持性不好, 需要被webpack转换后, 再使用JS代码&#x3D;&#x3D; 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;!-- ul&gt;li&#123;我是第$个li&#125;*10 --&gt; &lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt; &lt;li&gt;我是第4个li&lt;/li&gt; &lt;li&gt;我是第5个li&lt;/li&gt; &lt;li&gt;我是第6个li&lt;/li&gt; &lt;li&gt;我是第7个li&lt;/li&gt; &lt;li&gt;我是第8个li&lt;/li&gt; &lt;li&gt;我是第9个li&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在src&#x2F;main.js引入jquery 1yarn add jquery src&#x2F;main.js中编写隔行变色代码 123456// 引入jqueryimport $ from &#x27;jquery&#x27;$(function() &#123; $(&#x27;#app li:nth-child(odd)&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) $(&#x27;#app li:nth-child(even)&#x27;).css(&#x27;color&#x27;, &#x27;green&#x27;)&#125;) 执行打包命令观察效果 可以在dist下把public&#x2F;index.html引入过来 在index.html中&#x3D;&#x3D;手动&#x3D;&#x3D;引入js 1&lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt; 总结: 前端工程化模块化, 需要的包yarn下, 被webpack打包后引入到html中使用 3.3_插件-自动生成html文件 目标: html-webpack-plugin插件, 让webpack打包后生成html文件并自动引入打包后的js html-webpack-plugin插件地址 下载插件 1yarn add html-webpack-plugin -D webpack.config.js配置 1234567891011// 引入自动生成 html 的插件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; // ...省略其他代码 plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27; // 以此为基准生成打包后html文件 &#125;) ]&#125; 重新打包后观察dist下是否多出html并运行看效果 &#x3D;&#x3D;打包后的index.html自动引入打包后的js文件&#x3D;&#x3D; 总结: webpack就像一个人, webpack.config.js是人物属性, 给它穿什么装备它就干什么活 3.4_加载器 - 处理css文件问题 目标: 自己准备css文件, 引入到webpack入口, 测试webpack是否能打包css文件 1.新建 - src&#x2F;css&#x2F;index.css 2.编写去除li圆点样式代码 3.(重要) 一定要引入到入口才会被webpack打包 4.执行打包命令观察效果 总结: 保存原因, 因为webpack默认只能处理js类型文件 3.5_加载器 - 处理css文件 目标: loaders加载器, 可让webpack处理其他类型的文件, 打包到js中 原因: webpack默认只认识 js 文件和 json文件 style-loader文档 css-loader文档 安装依赖 1yarn add style-loader css-loader -D webpack.config.js 配置 12345678910111213141516const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; // ...其他代码 module: &#123; rules: [ // loader的规则 &#123; test: /\\.css$/, // 匹配所有的css文件 // use数组里从右向左运行 // 先用 css-loader 让webpack能够识别 css 文件的内容并打包 // 再用 style-loader 将样式, 把css插入到dom中 use: [ &quot;style-loader&quot;, &quot;css-loader&quot;] &#125; ] &#125;&#125; 新建src&#x2F;css&#x2F;li.css - 去掉li默认样式 123ul, li&#123; list-style: none;&#125; 引入到main.js (因为这里是入口需要产生关系, 才会被webpack找到打包起来) 1import &quot;./css/index.css&quot; 运行打包后dist&#x2F;index.html观察效果和css引入情况 总结: 万物皆模块, 引到入口, 才会被webpack打包, css打包进js中, 然后被嵌入在style标签插入dom上 3.6_加载器 - 处理less文件 目标: less-loader让webpack处理less文件, less模块翻译less代码 less-loader文档 下载依赖包 1yarn add less less-loader -D webpack.config.js 配置 12345678910module: &#123; rules: [ // loader的规则 // ...省略其他 &#123; test: /\\.less$/, // 使用less-loader, 让webpack处理less文件, 内置还会用less翻译less代码成css内容 use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &#x27;less-loader&#x27;] &#125; ]&#125; src&#x2F;less&#x2F;index.less - 设置li字体大小24px 12345@size:24px;ul, li&#123; font-size: @size&#125; 引入到main.js中 1import &quot;./less/index.less&quot; 打包运行dist&#x2F;index.html 观察效果 总结: 只要找到对应的loader加载器, 就能让webpack处理不同类型文件 3.7_加载器 - 处理图片文件 目标: 用asset module方式(webpack5版本新增) asset module文档 如果使用的是webpack5版本的, 直接配置在webpack.config.js - 的 rules里即可 1234&#123; test: /\\.(png|jpg|gif|jpeg)$/i, type: &#x27;asset&#x27;&#125; 如果你用的是webpack4及以前的, 请使用者里的配置 url-loader文档 file-loader文档 下载依赖包 1yarn add url-loader file-loader -D webpack.config.js 配置 123456789101112&#123; test: /\\.(png|jpg|gif|jpeg)$/i, use: [ &#123; loader: &#x27;url-loader&#x27;, // 匹配文件, 尝试转base64字符串打包到js中 // 配置limit, 超过8k, 不转, file-loader复制, 随机名, 输出文件 options: &#123; limit: 8 * 1024, &#125;, &#125;, ],&#125; 图片转成 base64 字符串 好处就是浏览器不用发请求了，直接可以读取 坏处就是如果图片太大，再转base64就会让图片的体积增大 30% 左右 src&#x2F;assets&#x2F;准备老师发的2个图文件 在css&#x2F;less&#x2F;index.less - 把小图片用做背景图 123body&#123; background: url(../assets/logo_small.png) no-repeat center;&#125; 在src&#x2F;main.js - 把大图插入到创建的img标签上, 添加body上显示 12345// 引入图片-使用import imgUrl from &#x27;./assets/1.gif&#x27;const theImg = document.createElement(&quot;img&quot;)theImg.src = imgUrldocument.body.appendChild(theImg) 打包运行dist&#x2F;index.html观察2个图片区别 总结: url-loader 把文件转base64 打包进js中, 会有30%的增大, file-loader 把文件直接复制输出 3.8_webpack加载文件优缺点图片转成 base64 字符串 好处就是浏览器不用发请求了，直接可以读取 坏处就是如果图片太大，再转base64就会让图片的体积增大 30% 左右 3.9_加载器 - 处理字体文件 目标: 用asset module技术, asset&#x2F;resource直接输出到dist目录下 webpack5使用这个配置 1234567&#123; // webpack5默认内部不认识这些文件, 所以当做静态资源直接输出即可 test: /\\.(eot|svg|ttf|woff|woff2)$/, type: &#x27;asset/resource&#x27;, generator: &#123; filename: &#x27;font/[name].[hash:6][ext]&#x27; &#125;&#125; webpack4及以前使用下面的配置 webpack.config.js - 准备配置 123456789101112131415&#123; // 处理字体图标的解析 test: /\\.(eot|svg|ttf|woff|woff2)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 2 * 1024, // 配置输出的文件名 name: &#x27;[name].[ext]&#x27;, // 配置输出的文件目录 outputPath: &quot;fonts/&quot; &#125; &#125; ]&#125; src&#x2F;assets&#x2F; - 放入字体库fonts文件夹 在main.js引入iconfont.css 12// 引入字体图标文件import &#x27;./assets/fonts/iconfont.css&#x27; 在public&#x2F;index.html使用字体图标样式 1&lt;i class=&quot;iconfont icon-weixin&quot;&gt;&lt;/i&gt; 执行打包命令-观察打包后网页效果 总结: url-loader和file-loader 可以打包静态资源文件 3.10_加载器 - 处理高版本js语法 目标: 让webpack对高版本 的js代码, 降级处理后打包 写代码演示: 高版本的js代码(箭头函数), 打包后, 直接原封不动打入了js文件中, 遇到一些低版本的浏览器就会报错 原因: webpack 默认仅内置了 模块化的 兼容性处理 import export babel 的介绍 &#x3D;&gt; 用于处理高版本 js语法 的兼容性 babel官网 解决: 让webpack配合babel-loader 对js语法做处理 babel-loader文档 安装包 1yarn add -D babel-loader @babel/core @babel/preset-env 配置规则 1234567891011121314module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] // 预设:转码规则(用bable开发环境本来预设的) &#125; &#125; &#125; ]&#125; 在main.js中使用箭头函数(高版本js) 1234567// 高级语法const fn = () =&gt; &#123; console.log(&quot;你好babel&quot;);&#125;console.log(fn) // 这里必须打印不能调用/不使用, 不然webpack会精简成一句打印不要函数了/不会编译未使用的代码// 没有babel集成时, 原样直接打包进lib/bundle.js// 有babel集成时, 会翻译成普通函数打包进lib/bundle.js 打包后观察lib&#x2F;bundle.js - 被转成成普通函数使用了 - 这就是babel降级翻译的功能 总结: babel-loader 可以让webpack 对高版本js语法做降级处理后打包 4. webpack 开发服务器4.0_webpack开发服务器-为何学?文档地址: https://webpack.docschina.org/configuration/dev-server/ 抛出问题: 每次修改代码, 都需要重新 yarn build 打包, 才能看到最新的效果, 实际工作中, 打包 yarn build 非常费时 (30s - 60s) 之间 为什么费时? 构建依赖 磁盘读取对应的文件到内存, 才能加载 用对应的 loader 进行处理 将处理完的内容, 输出到磁盘指定目录 解决问题: 起一个开发服务器, 在电脑内存中打包, 缓存一些已经打包过的内容, 只重新打包修改的文件, 最终运行加载在内存中给浏览器使用 &#x3D;&#x3D;4.1_webpack-dev-server自动刷新&#x3D;&#x3D; 目标: 启动本地服务, 可实时更新修改的代码, 打包变化代码到内存中, 然后直接提供端口和网页访问 下载包 1yarn add webpack-dev-server -D 配置自定义命令 1234scripts: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;serve&quot;: &quot;webpack serve&quot;&#125; 运行命令-启动webpack开发服务器 12yarn serve#或者 npm run serve 总结: 以后改了src下的资源代码, 就会直接更新到内存打包, 然后反馈到浏览器上了 4.2_webpack-dev-server配置 在webpack.config.js中添加服务器配置 更多配置参考这里: https://webpack.docschina.org/configuration/dev-server/#devserverafter 123456module.exports = &#123; // ...其他配置 devServer: &#123; port: 3000 // 端口号 &#125;&#125; 今日总结 什么是webpack, 它有什么作用 知道yarn的使用过程, 自定义命令, 下载删除包 有了webpack让模块化开发前端项目成为了可能, 底层需要node支持 对webpack各种配置项了解 入口&#x2F;出口 插件 加载器 mode模式 devServer webpack开发服务器的使用和运作过程 面试题1、什么是webpack（必会）​ webpack是一个打包模块化javascript的工具，在webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化项目 2、Webpack的优点是什么？（必会） 专注于处理模块化的项目，能做到开箱即用，一步到位 通过plugin扩展，完整好用又不失灵活 通过loaders扩展, 可以让webpack把所有类型的文件都解析打包 区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展 3、webpack的构建流程是什么?从读取配置到输出文件这个过程尽量说全（必会）​ Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： ​ 1. 初始化参数：从配置文件读取与合并参数，得出最终的参数 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译 确定入口：根据配置中的 entry 找出所有的入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果 4、说一下 Webpack 的热更新原理(必会)​ webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 ​ HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。 ​ 后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。 5、webpack与grunt、gulp的不同？（必会）​ 1) 三者之间的区别 ​ 三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。 ​ grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 ​ webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。 ​ 2) 从构建思路来说 ​ gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工 ​ 3) 对于知识背景来说 ​ gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路 6、有哪些常见的Loader？他们是解决什么问题的？（必会）1、 file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 2、 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 3、 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 4、 image-loader：加载并且压缩图片文件 5、 babel-loader：把 ES6 转换成 ES5 6、 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 7、 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 8、 eslint-loader：通过 ESLint 检查 JavaScript 代码 7、Loader和Plugin的不同？（必会）​ 1) 不同的作用 ​ Loader直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。 ​ Plugin直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 2) 不同的用法 ​ Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） ​ Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Vue基础","slug":"Vue基础","permalink":"http://example.com/tags/Vue%E5%9F%BA%E7%A1%80/"}]},{"title":"初识(六)","slug":"初识-六","date":"2022-11-06T03:43:48.000Z","updated":"2022-11-06T03:55:36.174Z","comments":true,"path":"2022/11/06/初识-六/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E5%85%AD/","excerpt":"","text":"1.jQuery 选择器1.1 jQuery 基础选择器 [jQuery 1.3参考手册.chm](E:\\一点东西\\前端资料\\05-jQuery\\jQuery手册\\jQuery 1.3参考手册.chm) [jQuery 1.4参考手册.CHM](E:\\一点东西\\前端资料\\05-jQuery\\jQuery手册\\jQuery 1.4参考手册.CHM) [jQuery1.7 中文手册.chm](E:\\一点东西\\前端资料\\05-jQuery\\jQuery手册\\jQuery1.7 中文手册.chm) [jQuery_3.3.1_API_Docs_CN.CHM](E:\\一点东西\\前端资料\\05-jQuery\\jQuery 第一天\\2-素材\\jQuery_3.3.1_API_Docs_CN.CHM) 原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 $(“选择器”) &#x2F;&#x2F; 里面选择器直接写 CSS 选择器即可，但是要加引号 1.2 jQuery 层级选择器 jQuery 设置样式 $(‘div’).css(‘属性’, ‘值’) 1.3 隐式迭代（重要）遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 12345678script&gt; // 1.获取四个div console.log($(&#x27;div&#x27;)) // 2.给四个div设置背景颜色 $(&#x27;div&#x27;).css(&#x27;background&#x27;, &#x27;pink&#x27;) // 3.隐式迭代就是把匹配的所有元素内部进行遍历循环，给每一个元素添加css $(&#x27;ul li&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;)&lt;/script&gt; 1.4 jQuery 筛选选择器 1234567891011121314&lt;script&gt; $(function()&#123; // 第一个li $(&#x27;ul li:first&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;) // 第三个li $(&#x27;ul li:eq(2)&#x27;).css(&#x27;color&#x27;,&#x27;blue&#x27;) // 第基数个li $(&#x27;ul li:odd&#x27;).css(&#x27;color&#x27;,&#x27;skyblue&#x27;) // 第偶数个li $(&#x27;ul li:even&#x27;).css(&#x27;color&#x27;,&#x27;pink&#x27;) // 第最后一个li $(&#x27;ul li:last&#x27;).css(&#x27;color&#x27;,&#x27;red&#x27;) &#125;) &lt;/script&gt; 1.5 jQuery 筛选方法（重点） 重点记住： parent() children() find() siblings() eq() 12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;儿子&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;nav&quot;&gt; &lt;p&gt;111&lt;/p&gt; &lt;div&gt; &lt;p&gt;222&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function () &#123; //1. 父 parent() 返回最近一级的父元素 console.log($(&#x27;son&#x27;).parent()) // 2.儿子 // 1.1亲儿子 children() 类似子代选择器 $(&#x27;.nav&#x27;).children(&#x27;p&#x27;).css(&#x27;color&#x27;, &#x27;red&#x27;) // 1.2可以选择里面所有的孩子 包括儿子和孙子 find() 类似后代选择器 $(&#x27;.nav&#x27;).find(&#x27;p&#x27;).css(&#x27;color&#x27;, &#x27;pink&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; 新浪下拉1234567891011121314&lt;script&gt; $(function () &#123; // 鼠标经过 $(&quot;.nav&gt;li&quot;).mouseover(function () &#123; // $(this) jQuery 当前元素 this不要加引号 // show() 显示元素 hide() 隐藏元素 $(this).children(&quot;ul&quot;).show(); &#125;); // 鼠标离开 $(&quot;.nav&gt;li&quot;).mouseout(function () &#123; $(this).children(&quot;ul&quot;).hide(); &#125;) &#125;) &lt;/script&gt; 1.6 jQuery 里面的排他思想想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。 $(this).css(“color”,”red”); $(this).siblings(). css(“color”,” ”); 得到当前元素索引号 $(this).index() 1234567891011121314151617181920&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;script&gt; $(function()&#123; // 1.给所有按钮绑定点击事件 $(&#x27;button&#x27;).click(function()&#123; // 2.当前元素添加背景颜色 $(this).css(&#x27;background&#x27;,&#x27;pink&#x27;) // 3.其他的兄弟去掉背景颜色 $(this).siblings(&#x27;button&#x27;).css(&#x27;background&#x27;,&#x27;&#x27;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 1.7链式编程链式编程是为了节省代码量，看起来更优雅。 $(this).css(‘color’, ‘red’).sibling().css(‘color’, ‘’); 12345678910111213&lt;script&gt; $(function() &#123; // 1. 隐式迭代 给所有的按钮都绑定了点击事件 $(&quot;button&quot;).click(function() &#123; // 2. 让当前元素颜色变为红色 // $(this).css(&quot;color&quot;, &quot;red&quot;); // 3. 让其余的姐妹元素不变色 // $(this).siblings().css(&quot;color&quot;, &quot;&quot;); // 链式编程 $(this).css(&quot;color&quot;, &quot;red&quot;).siblings().css(&quot;color&quot;, &quot;&quot;); &#125;); &#125;) &lt;/script&gt; 2.jQuery 样式操作2.1 操作 css 方法1.参数只写属性名，则是返回属性值 $(this).css(‘’color’’); 2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号 $(this).css(‘’color’’, ‘’red’’); 3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号， $(this).css({ “color”:”white”,”font-size”:”20px”}); 123456789101112131415&lt;script&gt; // 操作样式之css方法 $(function() &#123; console.log($(&quot;div&quot;).css(&quot;width&quot;)); // $(&quot;div&quot;).css(&quot;width&quot;, &quot;300px&quot;); // $(&quot;div&quot;).css(&quot;width&quot;, 300); // $(&quot;div&quot;).css(height, &quot;300px&quot;); 属性名一定要加引号 $(&quot;div&quot;).css(&#123; width: 400, height: 400, backgroundColor: &quot;red&quot; // 如果是复合属性则必须采取驼峰命名法，如果值不是数字，则需要加引号 &#125;) &#125;) &lt;/script&gt; 2.2 设置类样式方法作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。 1.添加类 $(“div”).addClass(‘’current’’); 2.移除类 $(“div”).removeClass(‘’current’’); 3.切换类 $(“div”).toggleClass(‘’current’’); 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;current&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 添加类 addClass() // $(&quot;div&quot;).click(function() &#123; // // $(this).addClass(&quot;current&quot;); // &#125;); // 2. 删除类 removeClass() // $(&quot;div&quot;).click(function() &#123; // $(this).removeClass(&quot;current&quot;); // &#125;); // 3. 切换类 toggleClass() $(&quot;div&quot;).click(function() &#123; $(this).toggleClass(&quot;current&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; tab栏切换 1234567891011121314&lt;script&gt; $(function() &#123; // 1.点击上部的li，当前li 添加current类，其余兄弟移除类 $(&quot;.tab_list li&quot;).click(function() &#123; // 链式编程操作 $(this).addClass(&quot;current&quot;).siblings().removeClass(&quot;current&quot;); // 2.点击的同时，得到当前li 的索引号 var index = $(this).index(); console.log(index); // 3.让下部里面相应索引号的item显示，其余的item隐藏 $(&quot;.tab_con .item&quot;).eq(index).show().siblings().hide(); &#125;); &#125;) &lt;/script&gt; 2.3 类操作与className区别原生 JS 中 className 会覆盖元素原先里面的类名。 jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。 123456789&lt;body&gt; &lt;div class=&quot;one two&quot;&gt;&lt;/div&gt; &lt;script&gt; // var one = document.querySelector(&quot;.one&quot;); // one.className = &quot;two&quot;; // $(&quot;.one&quot;).addClass(&quot;two&quot;); 这个addClass相当于追加类名 不影响以前的类名 $(&quot;.one&quot;).removeClass(&quot;two&quot;); &lt;/script&gt;&lt;/body&gt; 3.jQuery效果3.1 显示隐藏效果1.显示语法规范 show([speed,[easing],[fn]]) 2.隐藏语法规范 hide([speed,[easing],[fn]]) 3.切换语法规范 toggle([speed,[easing],[fn]]) 显示参数 （1）参数都可以省略， 无动画直接显示。 （2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) （3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 （4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 1234567891011121314151617181920212223&lt;body&gt; &lt;button&gt;显示&lt;/button&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;button&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; $(&quot;div&quot;).show(1000, function() &#123; alert(1); &#125;); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; $(&quot;div&quot;).hide(1000, function() &#123; alert(1); &#125;); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; $(&quot;div&quot;).toggle(1000); &#125;) // 一般情况下，我们都不加参数直接显示隐藏就可以了 &#125;); &lt;/script&gt; 3.2 滑动效果1.下滑效果语法规范 slideDown([speed,[easing],[fn]]) 2.上滑效果语法规范 slideUp([speed,[easing],[fn]]) 3.滑动切换效果语法规范 slideToggle([speed,[easing],[fn]]) 显示参数 （1）参数都可以省略， 无动画直接显示。 （2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) （3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 （4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 1234567891011121314151617181920212223&lt;body&gt; &lt;button&gt;下拉滑动&lt;/button&gt; &lt;button&gt;上拉滑动&lt;/button&gt; &lt;button&gt;切换滑动&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; // 下滑动 slideDown() $(&quot;div&quot;).slideDown(); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; // 上滑动 slideUp() $(&quot;div&quot;).slideUp(500); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; // 滑动切换 slideToggle() $(&quot;div&quot;).slideToggle(500); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 3.3 事件切换hover([over,]out) （1）over:鼠标移到元素上要触发的函数（相当于mouseenter） （2）out:鼠标移出元素要触发的函数（相当于mouseleave） （3）如果只写一个函数，则鼠标经过和离开都会触发它 123456789101112131415161718192021222324&lt;script&gt; $(function() &#123; // 鼠标经过 // $(&quot;.nav&gt;li&quot;).mouseover(function() &#123; // // $(this) jQuery 当前元素 this不要加引号 // // show() 显示元素 hide() 隐藏元素 // $(this).children(&quot;ul&quot;).slideDown(200); // &#125;); // // 鼠标离开 // $(&quot;.nav&gt;li&quot;).mouseout(function() &#123; // $(this).children(&quot;ul&quot;).slideUp(200); // &#125;); // 1. 事件切换 hover 就是鼠标经过和离开的复合写法 // $(&quot;.nav&gt;li&quot;).hover(function() &#123; // $(this).children(&quot;ul&quot;).slideDown(200); // &#125;, function() &#123; // $(this).children(&quot;ul&quot;).slideUp(200); // &#125;); // 2. 事件切换 hover 如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数 $(&quot;.nav&gt;li&quot;).hover(function() &#123; $(this).children(&quot;ul&quot;).slideToggle(); &#125;); &#125;) &lt;/script&gt; 3.4 动画队列及其停止排队方法1.动画或效果队列 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 2.停止排队 stop() (1）stop() 方法用于停止动画或效果。 (2) 注意： stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。 12345678910111213141516171819202122232425&lt;script&gt; $(function() &#123; // 鼠标经过 // $(&quot;.nav&gt;li&quot;).mouseover(function() &#123; // // $(this) jQuery 当前元素 this不要加引号 // // show() 显示元素 hide() 隐藏元素 // $(this).children(&quot;ul&quot;).slideDown(200); // &#125;); // // 鼠标离开 // $(&quot;.nav&gt;li&quot;).mouseout(function() &#123; // $(this).children(&quot;ul&quot;).slideUp(200); // &#125;); // 1. 事件切换 hover 就是鼠标经过和离开的复合写法 // $(&quot;.nav&gt;li&quot;).hover(function() &#123; // $(this).children(&quot;ul&quot;).slideDown(200); // &#125;, function() &#123; // $(this).children(&quot;ul&quot;).slideUp(200); // &#125;); // 2. 事件切换 hover 如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数 $(&quot;.nav&gt;li&quot;).hover(function() &#123; // stop 方法必须写到动画的前面 $(this).children(&quot;ul&quot;).stop().slideToggle(); &#125;); &#125;) &lt;/script&gt; 3.5 淡入淡出效果1.淡入效果语法规范 fadeIn([speed,[easing],[fn]]) 2.淡出效果语法规范 fadeOut([speed,[easing],[fn]]) 3.淡入淡出切换效果语法规范 fadeToggle([speed,[easing],[fn]]) 淡入淡出效果参数 （1）参数都可以省略。 （2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) （3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 （4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 4.渐进方式调整到指定的不透明度 fadeTo([[speed],opacity,[easing],[fn]]) 显示参数 （1）opacity 透明度必须写，取值 0~1 之间。 （2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。必须写 （3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 （4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;button&gt;淡入效果&lt;/button&gt; &lt;button&gt;淡出效果&lt;/button&gt; &lt;button&gt;淡入淡出切换&lt;/button&gt; &lt;button&gt;修改透明度&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; // 淡入 fadeIn() $(&quot;div&quot;).fadeIn(1000); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; // 淡出 fadeOut() $(&quot;div&quot;).fadeOut(1000); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; // 淡入淡出切换 fadeToggle() $(&quot;div&quot;).fadeToggle(1000); &#125;); $(&quot;button&quot;).eq(3).click(function() &#123; // 修改透明度 fadeTo() 这个速度和透明度要必须写 $(&quot;div&quot;).fadeTo(1000, 0.5); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 3.6 自定义动画 animate1.语法 animate(params,[speed],[easing],[fn]) 2.参数 （1）params: 想要更改的样式属性，以对象形式传递，必须写。 属性名可以不用带引号， 如果是复合属性则需要采取驼峰命名法 borderLeft。其余参数都可以省略。 （2）speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000) （3）easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 （4）fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 12345678910111213141516&lt;body&gt; &lt;button&gt;动起来&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).click(function() &#123; $(&quot;div&quot;).animate(&#123; left: 500, top: 300, opacity: .4, width: 500 &#125;, 500); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 4.jQuery 属性操作4.1、设置或获取元素固有属性值 prop()所谓元素固有属性就是元素本身自带的属性，比如 元素里面的 href ，比如 元素里面的 type。 1.获取属性语法 prop(‘’属性’’) 2.设置属性语法 prop(‘’属性’’, ‘’属性值’’) 4.2、设置或获取元素自定义属性值 attr()用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index &#x3D;“1”。 1.获取属性语法 attr(‘’属性’’) &#x2F;&#x2F; 类似原生 getAttribute() 2.设置属性语法 attr(‘’属性’’, ‘’属性值’’) &#x2F;&#x2F; 类似原生 setAttribute() 1234567891011121314151617181920212223242526&lt;body&gt; &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt; &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt; &lt;span&gt;123&lt;/span&gt; &lt;script&gt; $(function() &#123; //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值 console.log($(&quot;a&quot;).prop(&quot;href&quot;)); $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;); $(&quot;input&quot;).change(function() &#123; console.log($(this).prop(&quot;checked&quot;)); &#125;); // console.log($(&quot;div&quot;).prop(&quot;index&quot;)); // 2. 元素的自定义属性 我们通过 attr() console.log($(&quot;div&quot;).attr(&quot;index&quot;)); $(&quot;div&quot;).attr(&quot;index&quot;, 4); console.log($(&quot;div&quot;).attr(&quot;data-index&quot;)); // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面 $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;); console.log($(&quot;span&quot;).data(&quot;uname&quot;)); // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型 console.log($(&quot;div&quot;).data(&quot;index&quot;)); &#125;) &lt;/script&gt;&lt;/body&gt; 4.3 数据缓存 data()data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 1.附加数据语法 data(‘’name’’,’’value’’) &#x2F;&#x2F; 向被选元素附加数据 2.获取数据语法 date(‘’name’’) &#x2F;&#x2F; 向被选元素获取数据 同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型 5.jQuery 内容文本值主要针对元素的内容还有表单的值操作。 1.普通元素内容 html()（ 相当于原生inner HTML) ​ html() &#x2F;&#x2F; 获取元素的内容 ​ html(‘’内容’’) &#x2F;&#x2F; 设置元素的内容 2.普通元素文本内容 text() (相当与原生 innerText) ​ text() &#x2F;&#x2F; 获取元素的文本内容 3.表单的值 val()（ 相当于原生value) ​ val() &#x2F;&#x2F; 获取表单的值 ​ val(‘’内容’’) &#x2F;&#x2F; 设置表单的值 1234567891011121314151617&lt;body&gt; &lt;div&gt; &lt;span&gt;我是内容&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt; &lt;script&gt; // 1. 获取设置元素内容 html() console.log($(&quot;div&quot;).html()); // $(&quot;div&quot;).html(&quot;123&quot;); // 2. 获取设置元素文本内容 text() console.log($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;123&quot;); // 3. 获取设置表单值 val() console.log($(&quot;input&quot;).val()); $(&quot;input&quot;).val(&quot;123&quot;); &lt;/script&gt;&lt;/body&gt; 6.jQuery 元素操作主要是遍历、创建、添加、删除元素操作。 6.1.遍历元素jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。 ​ 语法1、语法：$(“div”).each(function (index, domEle) { xxx; }） ​ 1.each() 方法遍历匹配的每一个元素。主要用DOM处理。 each 每一个 ​ 2.里面的回调函数有2个参数： index 是每个元素的索引号; demEle 是每个DOM元素对象，不是jquery对象 ​ 3.所以要想使用jquery方法，需要给这个dom元素转换为jquery对象 $(domEle) ​ 语法2、$.each(object，function (index, element) { xxx; }） ​ 1.$.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象 ​ 2.里面的函数有2个参数： index 是每个元素的索引号; element 遍历内容 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; $(function() &#123; // $(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;); // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大） var sum = 0; // 1. each() 方法遍历元素 var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; $(&quot;div&quot;).each(function(i, domEle) &#123; // 回调函数第一个参数一定是索引号 可以自己指定索引号号名称 // console.log(index); // console.log(i); // 回调函数第二个参数一定是 dom元素对象 也是自己命名 // console.log(domEle); // domEle.css(&quot;color&quot;); dom对象没有css方法 $(domEle).css(&quot;color&quot;, arr[i]); sum += parseInt($(domEle).text()); &#125;) console.log(sum); // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据 // $.each($(&quot;div&quot;), function(i, ele) &#123; // console.log(i); // console.log(ele); // &#125;); // $.each(arr, function(i, ele) &#123; // console.log(i); // console.log(ele); // &#125;) $.each(&#123; name: &quot;andy&quot;, age: 18 &#125;, function(i, ele) &#123; console.log(i); // 输出的是 name age 属性名 console.log(ele); // 输出的是 andy 18 属性值 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 6.2 创建元素语法：$(‘’‘’); 动态的创建一个li 6.3 添加元素1.内部添加 element.append(‘’内容’’) 把内容放入匹配元素内部最后面，类似原生 appendChild。 element.prepend(‘’内容’’) 把内容放入匹配元素内部最前面。 2.外部添加 element.after(‘’内容’’) &#x2F;&#x2F; 把内容放入目标元素后面 element.before(‘’内容’’) &#x2F;&#x2F; 把内容放入目标元素前面 内部添加元素，生成之后，它们是父子关系。外部添加元素，生成之后，他们是兄弟关系。 6.4 删除元素​ 1、element.remove() &#x2F;&#x2F; 删除匹配的元素（本身） ​ 2、element.empty() &#x2F;&#x2F; 删除匹配的元素集合中所有的子节点 ​ 3、element.html(‘’ ‘’) &#x2F;&#x2F; 清空匹配的元素内容 1.remove 删除元素本身。 2.empt() 和 html(‘’’’) 作用等价，都可以删除元素里面的内容，只不过 html 还可以设置内容。 123456789101112131415161718192021222324&lt;body&gt; &lt;ul&gt; &lt;li&gt;原先的li&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 创建元素 var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;); // 2. 添加元素 // (1) 内部添加 // $(&quot;ul&quot;).append(li); 内部添加并且放到内容的最后面 $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面 // (2) 外部添加 var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;); // $(&quot;.test&quot;).after(div); $(&quot;.test&quot;).before(div); // 3. 删除元素 // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀 // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子 $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子 &#125;) &lt;/script&gt;&lt;/body&gt; 7.jQuery 尺寸、位置操作7.1 jQuery 尺寸 以上参数为空，则是获取相应值，返回的是数字型。 如果参数为数字，则是修改相应值。 参数可以不必写单位。 12345678910111213141516&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. width() / height() 获取设置元素 width和height大小 console.log($(&quot;div&quot;).width()); // $(&quot;div&quot;).width(300); // 2. innerWidth() / innerHeight() 获取设置元素 width和height + padding 大小 console.log($(&quot;div&quot;).innerWidth()); // 3. outerWidth() / outerHeight() 获取设置元素 width和height + padding + border 大小 console.log($(&quot;div&quot;).outerWidth()); // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin console.log($(&quot;div&quot;).outerWidth(true)); &#125;) &lt;/script&gt;&lt;/body&gt; 7.2 jQuery 位置位置主要有三个： offset()、position()、scrollTop()&#x2F;scrollLeft() 1.offset() 设置或获取元素偏移 ​ 1.1offset() 方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系。该方法有2个属性 left、top。 ​ 1.2offset().top 用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。 ​ 1.3可以设置元素的偏移：offset({ top: 10, left: 30 }); 2.position() 获取元素偏移 ​ 2.1position() 方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。 ​ 2.2该方法有2个属性 left、top。position().top 用于获取距离定位父级顶部的距离，position().left 用于获取距 离定位父级左侧的距离。 ​ 2.3该方法只能获取。 scrollTop()&#x2F;scrollLeft() 设置或获取元素被卷去的头部和左侧 ​3.1scrollTop() 方法设置或返回被选元素被卷去的头部。 ​3.2不跟参数是获取，参数为不带单位的数字则是设置被卷去的头部。 1234567891011121314151617181920212223&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 获取设置距离文档的位置（偏移） offset console.log($(&quot;.son&quot;).offset()); console.log($(&quot;.son&quot;).offset().top); // $(&quot;.son&quot;).offset(&#123; // top: 200, // left: 200 // &#125;); // 2. 获取距离带有定位父级位置（偏移） position 如果没有带有定位的父级，则以文档为准 // 这个方法只能获取不能设置偏移 console.log($(&quot;.son&quot;).position()); // $(&quot;.son&quot;).position(&#123; // top: 200, // left: 200 // &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;script&gt; $(function() &#123; $(document).scrollTop(100); // 被卷去的头部 scrollTop() / 被卷去的左侧 scrollLeft() // 页面滚动事件 var boxTop = $(&quot;.container&quot;).offset().top; console.log($(&quot;.container&quot;).offset()); $(window).scroll(function() &#123; // console.log(11); console.log($(document).scrollTop()); if ($(document).scrollTop() &gt;= boxTop) &#123; $(&quot;.back&quot;).fadeIn(); &#125; else &#123; $(&quot;.back&quot;).fadeOut(); &#125; &#125;); // 返回顶部 $(&quot;.back&quot;).click(function() &#123; // $(document).scrollTop(0); $(&quot;body, html&quot;).stop().animate(&#123; scrollTop: 0 &#125;); // $(document).stop().animate(&#123; // scrollTop: 0 // &#125;); 不能是文档而是 html和body元素做动画 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 8.jQuery 事件注册​ 语法：element.事件(function(){}) ​ $(“div”).click(function(){ 事件处理程序 }) 其他事件和原生基本一致。比如mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll 等 123456789$(function() &#123; // 单个事件注册 $(&quot;div&quot;).click(function() &#123; $(this).css(&quot;background&quot;, &quot;purple&quot;); &#125;); $(&quot;div&quot;).mouseenter(function() &#123; $(this).css(&quot;background&quot;, &quot;skyblue&quot;); &#125;); &#125;) 9.jQuery 事件处理9.1事件处理 on() 绑定事件on() 方法在匹配元素上绑定一个或多个事件的事件处理函数 ​ 语法：element.on(events,[selector],fn) events:一个或多个用空格分隔的事件类型，如”click”或”keydown” 。 selector: 元素的子元素选择器 。 fn:回调函数 即绑定在元素身上的侦听函数。 on() 方法优势1：可以绑定多个事件，多个处理事件处理程序。 12345 $(“div”).on(&#123; mouseover: function()&#123;&#125;, mouseout: function()&#123;&#125;, click: function()&#123;&#125; &#125;); 如果事件处理相同 123$(“div”).on(“mouseover mouseout”, function() &#123; $(this).toggleClass(“current”); &#125;); on() 方法优势2：可以事件委派操作 。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。 123$(&#x27;ul&#x27;).on(&#x27;click&#x27;, &#x27;li&#x27;, function() &#123; alert(&#x27;hello world!&#x27;);&#125;); 在此之前有bind(), live() delegate()等方法来处理事件绑定或者事件委派，最新版本的请用on替代他们。 on() 方法优势3：动态创建的元素，click() 没有办法绑定事件， on() 可以给动态生成的元素绑定事件 123$(“div&quot;).on(&quot;click&quot;,”p”, function()&#123; alert(&quot;俺可以给动态生成的元素绑定事件&quot;)&#125;); 1$(&quot;div&quot;).append($(&quot;&lt;p&gt;我是动态创建的p&lt;/p&gt;&quot;)); 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; $(function() &#123; // 事件处理on // (1) on可以绑定1个或者多个事件处理程序 // $(&quot;div&quot;).on(&#123; // mouseenter: function() &#123; // $(this).css(&quot;background&quot;, &quot;skyblue&quot;); // &#125;, // click: function() &#123; // $(this).css(&quot;background&quot;, &quot;purple&quot;); // &#125;, // mouseleave: function() &#123; // $(this).css(&quot;background&quot;, &quot;blue&quot;); // &#125; // &#125;); $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() &#123; $(this).toggleClass(&quot;current&quot;); &#125;); // (2) on可以实现事件委托（委派） // $(&quot;ul li&quot;).click(); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;); // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li // (3) on可以给未来动态创建的元素绑定事件 // $(&quot;ol li&quot;).click(function() &#123; // alert(11); // &#125;) $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;) var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;); $(&quot;ol&quot;).append(li); &#125;) &lt;/script&gt; 123456789101112131415161718192021222324&lt;script&gt; //微博发布 $(function() &#123; // 1.点击发布按钮， 动态创建一个小li，放入文本框的内容和删除按钮， 并且添加到ul 中 $(&quot;.btn&quot;).on(&quot;click&quot;, function() &#123; var li = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;); li.html($(&quot;.txt&quot;).val() + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt; 删除&lt;/a&gt;&quot;); $(&quot;ul&quot;).prepend(li); li.slideDown(); $(&quot;.txt&quot;).val(&quot;&quot;); &#125;) // 2.点击的删除按钮，可以删除当前的微博留言li // $(&quot;ul a&quot;).click(function() &#123; // 此时的click不能给动态创建的a添加事件 // alert(11); // &#125;) // on可以给动态创建的元素绑定事件 $(&quot;ul&quot;).on(&quot;click&quot;, &quot;a&quot;, function() &#123; $(this).parent().slideUp(function() &#123; $(this).remove(); &#125;); &#125;) &#125;) &lt;/script&gt; 9.2事件处理 off() 解绑事件off() 方法可以移除通过 on() 方法添加的事件处理程序。 123$(&quot;p&quot;).off() // 解绑p元素所有事件处理程序$(&quot;p&quot;).off( &quot;click&quot;) // 解绑p元素上面的点击事件 后面的 foo 是侦听函数名$(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;); // 解绑事件委托 如果有的事件只想触发一次， 可以使用 one() 来绑定事件。 1234567891011121314151617181920212223&lt;script&gt; $(function() &#123; $(&quot;div&quot;).on(&#123; click: function() &#123; console.log(&quot;我点击了&quot;); &#125;, mouseover: function() &#123; console.log(&#x27;我鼠标经过了&#x27;); &#125; &#125;); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;); // 1. 事件解绑 off // $(&quot;div&quot;).off(); // 这个是解除了div身上的所有事件 $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;); // 2. one() 但是它只能触发事件一次 $(&quot;p&quot;).one(&quot;click&quot;, function() &#123; alert(11); &#125;) &#125;) &lt;/script&gt; 9.3自动触发事件 trigger()有些事件希望自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。 1element.click() // 第一种简写形式 1element.trigger(&quot;type&quot;) // 第二种自动触发模式 1234$(&quot;p&quot;).on(&quot;click&quot;, function () &#123; alert(&quot;hi~&quot;);&#125;); $(&quot;p&quot;).trigger(&quot;click&quot;); // 此时自动触发点击事件，不需要鼠标点击 1element.triggerHandler(type) // 第三种自动触发模式 triggerHandler模式不会触发元素的默认行为，这是和前面两种的区别。 123456789101112131415161718192021222324&lt;script&gt; $(function() &#123; $(&quot;div&quot;).on(&quot;click&quot;, function() &#123; alert(11); &#125;); // 自动触发事件 // 1. 元素.事件() // $(&quot;div&quot;).click();会触发元素的默认行为 // 2. 元素.trigger(&quot;事件&quot;) // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为 $(&quot;input&quot;).trigger(&quot;focus&quot;); // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为 $(&quot;div&quot;).triggerHandler(&quot;click&quot;); $(&quot;input&quot;).on(&quot;focus&quot;, function() &#123; $(this).val(&quot;你好吗&quot;); &#125;); // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=&quot;text&quot;&gt;&lt;/body&gt; 10.jQuery 事件对象事件被触发，就会有事件对象的产生。 1element.on(events,[selector],function(event) &#123;&#125;) 阻止默认行为：event.preventDefault() 或者 return false 阻止冒泡： event.stopPropagation() 12345678910111213141516171819202122232425&lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; $(document).on(&quot;click&quot;, function() &#123; console.log(&quot;点击了document&quot;); &#125;) $(&quot;div&quot;).on(&quot;click&quot;, function(event) &#123; console.log(event); console.log(&quot;点击了div&quot;); event.stopPropagation(); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 11.多对象拷贝如果想要把某个对象拷贝（合并） 给另外一个对象使用，此时可以使用 $.extend() 方法 ​ 语法：$.extend([deep], target, object1, [objectN]) deep: 如果设为true 为深拷贝， 默认为false 浅拷贝 target: 要拷贝的目标对象 object1:待拷贝到第一个对象的对象。 objectN:待拷贝到第N个对象的对象。 浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象。 深拷贝，前面加true， 完全克隆(拷贝的对象,而不是地址)，修改目标对象不会影响被拷贝对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; $(function() &#123; // var targetObj = &#123;&#125;; // var obj = &#123; // id: 1, // name: &quot;andy&quot; // &#125;; // // $.extend(target, obj); // $.extend(targetObj, obj); // console.log(targetObj); // var targetObj = &#123; // id: 0 // &#125;; // var obj = &#123; // id: 1, // name: &quot;andy&quot; // &#125;; // // $.extend(target, obj); // $.extend(targetObj, obj); // console.log(targetObj); // 会覆盖targetObj 里面原来的数据 var targetObj = &#123; id: 0, msg: &#123; sex: &#x27;男&#x27; &#125; &#125;; var obj = &#123; id: 1, name: &quot;andy&quot;, msg: &#123; age: 18 &#125; &#125;; // // $.extend(target, obj); // $.extend(targetObj, obj); // console.log(targetObj); // 会覆盖targetObj 里面原来的数据 // // 1. 浅拷贝把原来对象里面的复杂数据类型地址拷贝给目标对象 // targetObj.msg.age = 20; // console.log(targetObj); // console.log(obj); // 2. 深拷贝把里面的数据完全复制一份给目标对象 如果里面有不冲突的属性,会合并到一起 $.extend(true, targetObj, obj); // console.log(targetObj); // 会覆盖targetObj 里面原来的数据 targetObj.msg.age = 20; console.log(targetObj); // msg :&#123;sex: &quot;男&quot;, age: 20&#125; console.log(obj); &#125;) &lt;/script&gt; 12.多库共存jQuery使用$作为标示符，随着jQuery的流行,其他 js 库也会用这$作为标识符， 这样一起使用会引起冲突。 需要一个解决方案，让jQuery 和其他的js库不存在冲突，可以同时存在，这就叫做多库共存。 jQuery 解决方案： 1.把里面的 $ 符号 统一改为 jQuery。 比如 jQuery(‘’div’’) 2.jQuery 变量规定新的名称：$.noConflict() var xx &#x3D; $.noConflict(); 12345678910111213141516171819&lt;script&gt; $(function() &#123; function $(ele) &#123; return document.querySelector(ele); &#125; console.log($(&quot;div&quot;)); // 1. 如果$ 符号冲突 我们就使用 jQuery jQuery.each(); // 2. 让jquery 释放对$ 控制权 让用自己决定 var suibian = jQuery.noConflict(); console.log(suibian(&quot;span&quot;)); suibian.each(); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;&lt;/body&gt; 13.jQuery 插件jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 注意: 这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件，因此也称为 jQuery 插件。 jQuery 插件常用的网站： jQuery 插件库 http://www.jq22.com/ jQuery 之家 http://www.htmleaf.com/ jQuery 插件使用步骤： 引入相关文件。（jQuery 文件 和 插件文件） 复制相关html、css、js (调用插件)。 jQuery 插件演示： 1.瀑布流 2.图片懒加载（图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载） 当我们页面滑动到可视区域，再显示图片。 我们使用jquery 插件库 EasyLazyload。 注意，此时的js引入文件和js调用必须写到 DOM元素（图片）最后面 3.全屏滚动（fullpage.js） ​ gitHub： https://github.com/alvarotrigo/fullPage.js ​ 中文翻译网站： http://www.dowebok.com/demo/2014/77/ 本地存储的数据格式 123456789101112131415161718192021&lt;body&gt; &lt;script&gt; var todolist = [&#123; title: &#x27;我今天吃八个馒头&#x27;, done: false &#125;, &#123; title: &#x27;我今天学习jq&#x27;, done: false &#125;, ]; // localStorage.setItem(&quot;todo&quot;, todolist); // 1. 本地存储里面只能存储字符串的数据格式 把我们的数组对象转换为字符串格式 JSON.stringify() localStorage.setItem(&quot;todo&quot;, JSON.stringify(todolist)); var data = localStorage.getItem(&quot;todo&quot;); // console.log(typeof data); // console.log(data[0].title); // 2. 获取本地存储的数据 我们需要把里面的字符串数据转换为 对象格式 JSON.parse() data = JSON.parse(data); console.log(data); console.log(data[0].title); &lt;/script&gt;&lt;/body&gt; 案例tudolist123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293$(function() &#123; // alert(11); // 1. 按下回车 把完整数据 存储到本地存储里面 // 存储的数据格式 var todolist = [&#123;title: &quot;xxx&quot;, done: false&#125;] load(); $(&quot;#title&quot;).on(&quot;keydown&quot;, function(event) &#123; if (event.keyCode === 13) &#123; if ($(this).val() === &quot;&quot;) &#123; alert(&quot;请输入您要的操作&quot;); &#125; else &#123; // 先读取本地存储原来的数据 var local = getDate(); // console.log(local); // 把local数组进行更新数据 把最新的数据追加给local数组 local.push(&#123; title: $(this).val(), done: false &#125;); // 把这个数组local 存储给本地存储 saveDate(local); // 2. toDoList 本地存储数据渲染加载到页面 load(); $(this).val(&quot;&quot;); &#125; &#125; &#125;); // 3. toDoList 删除操作 $(&quot;ol, ul&quot;).on(&quot;click&quot;, &quot;a&quot;, function() &#123; // alert(11); // 先获取本地存储 var data = getDate(); console.log(data); // 修改数据 var index = $(this).attr(&quot;id&quot;); console.log(index); data.splice(index, 1); // 保存到本地存储 saveDate(data); // 重新渲染页面 load(); &#125;); // 4. toDoList 正在进行和已完成选项操作 $(&quot;ol, ul&quot;).on(&quot;click&quot;, &quot;input&quot;, function() &#123; // alert(11); // 先获取本地存储的数据 var data = getDate(); // 修改数据 var index = $(this).siblings(&quot;a&quot;).attr(&quot;id&quot;); console.log(index); // data[?].done = ? data[index].done = $(this).prop(&quot;checked&quot;); console.log(data); // 保存到本地存储 saveDate(data); // 重新渲染页面 load(); &#125;); // 读取本地存储的数据 function getDate() &#123; var data = localStorage.getItem(&quot;todolist&quot;); if (data !== null) &#123; // 本地存储里面的数据是字符串格式的 但是我们需要的是对象格式的 return JSON.parse(data); &#125; else &#123; return []; &#125; &#125; // 保存本地存储数据 [&#123;&#125;,&#123;&#125;,&#123;&#125;] function saveDate(data) &#123; localStorage.setItem(&quot;todolist&quot;, JSON.stringify(data)); &#125; // 渲染加载数据 function load() &#123; // 读取本地存储的数据 var data = getDate(); console.log(data); // 遍历之前先要清空ol里面的元素内容 $(&quot;ol, ul&quot;).empty(); var todoCount = 0; // 正在进行的个数 var doneCount = 0; // 已经完成的个数 // 遍历这个数据 $.each(data, function(i, n) &#123; // console.log(n); if (n.done) &#123; $(&quot;ul&quot;).prepend(&quot;&lt;li&gt;&lt;input type=&#x27;checkbox&#x27; checked=&#x27;checked&#x27; &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href=&#x27;javascript:;&#x27; id=&quot; + i + &quot; &gt;&lt;/a&gt;&lt;/li&gt;&quot;); doneCount++; &#125; else &#123; $(&quot;ol&quot;).prepend(&quot;&lt;li&gt;&lt;input type=&#x27;checkbox&#x27; &gt; &lt;p&gt;&quot; + n.title + &quot;&lt;/p&gt; &lt;a href=&#x27;javascript:;&#x27; id=&quot; + i + &quot; &gt;&lt;/a&gt;&lt;/li&gt;&quot;); todoCount++; &#125; &#125;); $(&quot;#todocount&quot;).text(todoCount); $(&quot;#donecount&quot;).text(doneCount); &#125;&#125;)","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"初识(五)","slug":"初识-五","date":"2022-11-06T03:43:38.000Z","updated":"2022-11-06T03:55:21.736Z","comments":true,"path":"2022/11/06/初识-五/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E4%BA%94/","excerpt":"","text":"NodeNode.js 是一个基于 Chrome v8 引擎的 JavaScript运行环境。 注意： ① 浏览器是 JavaScript 的前端运行环境。 ② Node.js 是 JavaScript 的后端运行环境。 ③ Node.js 中无法调用 DOM 和 BOM 等浏览器内置 API。 Node可以做什么 Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大 的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位： ① 基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用 ② 基于 Electron 框架（https://electronjs.org/），可以构建跨平台的桌面应用 ③ 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目 ④ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc… 1. fs 文件系统模块fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。 例如： fs.readFile() 方法，用来读取指定文件中的内容 fs.writeFile() 方法，用来向指定的文件中写入内容 1.1导入fs使用 fs 模块来操作文件，则需要使用如下的方式先导入它： 1const fs = require(&#x27;fs&#x27;) 1.2 读取使用 fs.readFile() 方法，可以读取指定文件中的内容，语法格式如下： 1fs.readFile(path[,options],callback) 参数解读： ⚫ 参数1：必选参数，字符串，表示文件的路径。 ⚫ 参数2：可选参数，表示以什么编码格式来读取文件。 ⚫ 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。 12345fs.readFile(&#x27;./1.txt&#x27;, &#x27;utf8&#x27;, function (err, dataStr) &#123; console.log(err) console.log(&#x27;-------------------------&#x27;) console.log(dataStr)&#125;) 123456789//判断文件是否读取成功//可以判断 err 对象是否为 null，从而知晓文件读取的结果const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./1.txt&#x27;, &#x27;utf8&#x27;, function (err,dataStr) &#123; if (err) &#123; return console.log(&#x27;读取失败&#x27; + err.message) &#125; console.log(&#x27;读取文件成功&#x27; + dataStr)&#125;) 1.3 fs.writeFile()使用 fs.writeFile() 方法，可以向指定的文件中写入内容 12345678910111213141516const fs = require(&#x27;fs&#x27;)// 调用 fs.writeFile() 方法 写入文件的内容// 参数1：表示文件的存放路径// 参数2：表示要写入的内容// 参数3：回调函数// 有该文件 修改内容 没有该文件创建文件fs.writeFile(&#x27;./3.txt&#x27;, &#x27;小马&#x27;, function (err) &#123; // 写入成功 null // 写入失败 错误对象 // console.log(err) if (err) &#123; return console.log(&#x27;文件写入失败&#x27; + err.message) &#125; console.log(&#x27;文件写入成功&#x27;)&#125;) 注意： ① fs.writeFile() 方法只能用来创建文件，不能用来创建路径 ② 重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容 小案例-成绩读取使用 fs 文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。 步骤： ① 导入需要的 fs 文件系统模块 ② 使用 fs.readFile() 方法，读取素材目录下的 成绩.txt 文件 ③ 判断文件是否读取失败 ④ 文件读取成功后，处理成绩数据 ⑤ 将处理完成的成绩数据，调用 fs.writeFile() 方法，写入到新文件 成绩-ok.txt 中 12345678910111213141516171819202122232425const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./text/成绩.txt&#x27;, &#x27;utf8&#x27;, function (err, dataStr) &#123; if (err) return console.log(&#x27;读取失败&#x27;) console.log(&#x27;读取成功&#x27;) console.log(dataStr) // 变成数组 let arr = dataStr.split(&#x27; &#x27;) // 遍历数组 arr = arr.map(function (item) &#123; return item.replace(&#x27;=&#x27;, &#x27;:&#x27;) &#125;) console.log(arr) // 换行 let str = arr.join(&#x27;\\n&#x27;) console.log(str) // 写入新文件 fs.writeFile(&#x27;./04_成绩-ok.txt&#x27;, str, &#x27;utf8&#x27;, function (err) &#123; if (err) &#123; console.log(&#x27;写入失败&#x27;) &#125; else &#123; console.log(&#x27;写入成功&#x27;) &#125; return &#125;)&#125;) 2 path 路径模块path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理 需求。 例如： ⚫ path.join() 方法，用来将多个路径片段拼接成一个完整的路径字符串 ⚫ path.basename() 方法，用来从路径字符串中，将文件名解析出来 1const path = require(&#x27;path&#x27;) path.join() 的语法格式 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串 1path.join([...paths]) 参数解读： ⚫ …paths 路径片段的序列 ⚫ 返回值: 12345678910111213141516// path 路径的相关模块const path = require(&#x27;path&#x27;)// join 拼接路径// basename 获取文件名// extname 获取文件后缀名// path.join(各种路径) 该方法可以把各种路径拼接一起console.log(__dirname + &#x27;text&#x27;)// join 可识别路径拼接console.log(path.join(__dirname, &#x27;text&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;../&#x27;, &#x27;c/d/e/f&#x27;))// path.basename(&#x27;路径&#x27;,&#x27;去除的后缀名&#x27;)console.log(path.basename(&#x27;./text.txt&#x27;, &#x27;.txt&#x27;))// path.extname(&#x27;路径&#x27;)console.log(path.extname(&#x27;./text.txt&#x27;)) 2.1 path.basename() 获取路径中的文件名使用 path.basename() 方法，可以获取路径中的最后一部分 1path.basename(path[,ext]) 参数解读： ⚫ path 必选参数，表示一个路径的字符串 ⚫ ext 可选参数，表示文件扩展名 ⚫ 返回: 表示路径中的最后一部分 使用 path.basename() 方法，可以从一个文件路径中，获取到文件的名称部分 12345678910const path = require(&#x27;path&#x27;)// 定义文件的存放路径const fpath = &#x27;/a/b/c/index.html&#x27;// const fullName = path.basename(fpath)// console.log(fullName)const nameWithoutExt = path.basename(fpath, &#x27;.html&#x27;)console.log(nameWithoutExt) //index 2.2 path.extname() 获取路径中的文件扩展名1path.extname(path) 参数解读： ⚫ path 必选参数，表示一个路径的字符串 ⚫ 返回: 返回得到的扩展名字符串 使用 path.extname() 方法，可以获取路径中的扩展名部分 1234567const path = require(&#x27;path&#x27;)// 这是文件的存放路径const fpath = &#x27;/a/b/c/index.html&#x27;const fext = path.extname(fpath)console.log(fext) //.html 综合案例将素材目录下的 index.html 页面，拆分成三个文件，分别是：index.css &#x2F; index.js &#x2F; index.html 并且将拆分出来的 3 个文件，存放到 clock 目录中。 案例的实现步骤 ① 创建两个正则表达式，分别用来匹配 和 标签 ② 使用 fs 模块，读取需要被处理的 HTML 文件 ③ 自定义 resolveCSS 方法，来写入 index.css 样式文件 ④ 自定义 resolveJS 方法，来写入 index.js 脚本文件 ⑤ 自定义 resolveHTML 方法，来写入 index.html 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 把 index.html 拆解出单独的 html css js const fs = require(&#x27;fs&#x27;)const past = require(&#x27;path&#x27;)// __dirname 拼接路径const mypath = past.join(__dirname, &#x27;index.html&#x27;)// console.log(mypath)// 读取文件fs.readFile(mypath, &#x27;utf8&#x27;, (err, dataStr) =&gt; &#123; if (err) return console.log(&#x27;读取失败&#x27;) // console.log(dataStr) // 处理css // 正则表达式.exec(dataStr) let cssreg = /&lt;style&gt;([\\s\\S]*)&lt;\\/style&gt;/ // let css = reg.exec(dataStr) let css = cssreg.exec(dataStr)[1] // console.log(css) let csspath = past.join(__dirname, &#x27;index.css&#x27;) // console.log(csspath) // fs.writeFile(csspath, css, &#x27;utf8&#x27;, (err) =&gt; &#123; // if (err) return console.log(&#x27;写入失败&#x27;) // console.log(&#x27;css写入成功&#x27;) // &#125;) let cssname = &#x27;css&#x27; fn(csspath, css, cssname) // 处理js let jsreg = /&lt;script&gt;([\\s\\S]*)&lt;\\/script&gt;/ // console.log(jsreg) let js = jsreg.exec(dataStr)[1] // console.log(js) let jspath = past.join(__dirname, &#x27;index.js&#x27;) // console.log(jspath) // fs.writeFile(jspath, js, &#x27;utf8&#x27;, err =&gt; &#123; // if (err) return console.log(&#x27;写入失败&#x27;) // console.log(&#x27;js写入成功&#x27;) // &#125;) let jsname = &#x27;js&#x27; fn(jspath, js, jsname) // 处理html let html = dataStr.replace(cssreg.exec(dataStr)[0], &#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;&#x27;).replace(jsreg.exec(dataStr)[0], &#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;) let htmlpath = past.join(__dirname, &#x27;index.html&#x27;) // fs.writeFile(htmlpath, html, &#x27;utf8&#x27;, err =&gt; &#123; // if (err) return console.log(&#x27;写入失败&#x27;) // console.log(&#x27;html写入成功&#x27;) // &#125;) let htmlname = &#x27;html&#x27; fn(htmlpath, html, htmlname) function fn(path, html, name) &#123; fs.writeFile(path, html, &#x27;utf8&#x27;, err =&gt; &#123; if (err) return console.log(&#x27;写入失败&#x27;) console.log(name + &#x27;写入成功&#x27;) &#125;) &#125;&#125;) 3.http模块http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。 1const http = require(&#x27;http&#x27;) 1234567891011121314151617181920// 1.导入模块const http = require(&#x27;http&#x27;)// 2.创建web服务器let app = http.createServer()// 3.监听请求app.on(&#x27;request&#x27;, (req, res) =&gt; &#123; console.log(&#x27;有人来请求了，请求的地址是：&#x27; + req.url) // 请求的类型 console.log(&#x27;请求的类型是：&#x27; + req.method) console.log(&#x27;----------------------------&#x27;) // 防止中文乱码 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;) // 相应的返回值 res.end(&#x27;加油&#x27;)&#125;)// 4.启动服务器app.listen(80, () =&gt; &#123; console.log(&#x27;服务器开启&#x27;)&#125;) 3.1 req 请求对象只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。 在事件处理函数中，访问与客户端相关的数据或属性 1234567server.on(&#x27;request&#x27;,(req) =&gt; &#123; //req 是请求对象，它包含了与客户端相关的数据和属性 //req.url 是客户端请求的 URL 地址 //req.method 是客户端的 method 请求类型 const str = `请求的地址是： $&#123;req.url&#125;,请求的类型是：$&#123;req.method&#125;` console.log(str) //终端显示&#125;) 3.2 res 响应对象在服务器的 request 事件处理函数中，访问与服务器相关的数据或属性 1234567server.on(&#x27;request&#x27;,(req, res) =&gt; &#123; //res 是响应对象，它包含了与服务器相关的数据和属性 //要发送到服务器的字符串 const str = `请求的地址是： $&#123;req.url&#125;,请求的类型是：$&#123;req.method&#125;` //res.end() 向客户端发送指定内容，并结束这次请求的处理过程 res.end(str) //页面显示&#125;) 3.3 解决中文乱码问题1res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;) 小案例根据不同的 url 响应不同的 html 内容 实现步骤 ① 获取请求的 url 地址 ② 设置默认的响应内容为 404 Not found ③ 判断用户请求的是否为 / 或 /index.html 首页 ④ 判断用户请求的是否为 /about.html 关于页面 ⑤ 设置 Content-Type 响应头，防止中文乱码 ⑥ 使用 res.end() 把内容响应给客户端 12345678910111213141516171819202122const http = require(&#x27;http&#x27;)const server = http.createServer()// 监听服务器server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // 获取请求的地址 const url = req.url // 设置，默认的相应内容为 404 let content = &#x27;&lt;h1&gt;404 Not Found!&lt;h1&gt;&#x27; // 判断用户输入的页面 if (url === &#x27;/&#x27; || url === &#x27;index.html&#x27;) &#123; content = &#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27; &#125; else if (url === &#x27;/about.html&#x27;) &#123; content = &#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27; &#125; // 防止中文乱码 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;) // 把内容相应给客户端 res.end(content)&#125;)server.listen(80, () =&gt; &#123; console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) 综合案例实现 clock 时钟的 web 服务器 实现步骤 ① 导入需要的模块 ② 创建基本的 web 服务器 ③ 将资源的请求 url 地址映射为文件的存放路径 ④ 读取文件内容并响应给客户端 ⑤ 优化资源的请求路径 123456789101112131415161718192021222324252627282930const http = require(&#x27;http&#x27;)const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)// 2.创建web服务器const server = http.createServer()// 3.监听web服务器server.on(&#x27;request&#x27;, (req, res) =&gt; &#123; // 5.获取客户端请求的URL地址 const url = req.url // 具体文件存放路径 let fpath = &#x27;&#x27; if (url === &#x27;/&#x27;) &#123; fpath = path.join(__dirname, &#x27;./clock/index.html&#x27;) &#125; else &#123; fpath = path.join(__dirname, &#x27;./clock&#x27;, url) &#125; // const fpath = path.join(__dirname, &#x27;./clock&#x27;, url) // 6.根据文件路径读取内容 fs.readFile(fpath, &#x27;utf8&#x27;, (err, dataStr) =&gt; &#123; // 读取失败 返回错误提示 if (err) return res.end(&#x27;404 访问错误&#x27;) // 读取成功 返回读取内容 res.end(dataStr) &#125;)&#125;)// 4.开启服务器server.listen(80, () =&gt; &#123; // 服务器开启后的提示消息 console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) 4.模块化模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。 编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。 把代码进行模块化拆分的好处： ① 提高了代码的复用性 ② 提高了代码的可维护性 ③ 可以实现按需加载 4.1 Node.js 中模块的模块化4.1.1 Node.js 中模块的分类Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是： ⚫ 内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） ⚫ 自定义模块（用户创建的每个 .js 文件，都是自定义模块） ⚫ 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载） 4.1.2 加载模块使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。 123456//1.加载内置的 fs 模块const fs = require(&#x27;fs&#x27;)//2.加载用户的自定义模块const custom = require(&#x27;./custom.js&#x27;)//3.加载第三方模块const moment = require(&#x27;moment&#x27;) 4.1.3 Node.js 中的模块作用域和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。 防止了全局变量污染的问题 4.1.4 向外共享模块作用域中的成员​ module 对象 ​ 在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息 ​ module.exports 对象 ​ 在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。外界用 require() 方法导 ​ 入自定义模块时，得到的就是 module.exports 所指向的对象。 ​ 由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情下， ​ exports 和 module.exports 指向同一个对象。最终共享的结果，还是以 module.exports 指向的对象为准。 ​ 使用 require() 方法导入模块时，导入的结果，永远以 module.exports 指向的对象为准。 4.1.5 Node.js 中的模块化规范Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。 CommonJS 规定： ① 每个模块内部，module 变量代表当前模块。 ② module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。 ③ 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。 5-npm与包5.1 包Node.js 中的第三方模块又叫做包。 就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。 不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。 注意：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。 由于 Node.js 的内置模块仅提供了一些底层的 API，导致在基于内置模块进行项目开发的时，效率很低。 包是基于内置模块封装出来的，提供了更高级、更方便的 API，极大的提高了开发效率。 包和内置模块之间的关系，类似于 jQuery 和 浏览器内置 API 之间的关系。 12345//查看自己电脑上所安装的 npm 包管理工具的版本号npm -v//项目中安装指定名称的包 tab补齐名称npm install 包的完整名npm i 包的完整名 5.2 初次装包后多了的文件初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。 其中： node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。 package-lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。 注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们。 5.2.1 安装指定版本的包使用 npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过 @ 符号指定具体的版本。 1npm i moment@2.22.2 5.2.2 包的语义化版本规范包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0 其中每一位数字所代表的的含义如下： 第1位数字：大版本 第2位数字：功能版本 第3位数字：Bug修复版本 版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。 5.3 包管理配置文件npm 规定，在项目根目录中，必须提供一个叫做 package.json 的包管理配置文件。用来记录与项目有关的一些配置 信息。例如： ⚫ 项目的名称、版本号、描述等 ⚫ 项目中都用到了哪些包 ⚫ 哪些包只在开发期间会用到 ⚫ 那些包在开发和部署时都需要用到 5.3.1 记录项目中安装了哪些包在项目根目录中，创建一个叫做 package.json 的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除 node_modules 目录之后，在团队成员之间共享项目的源代码。 注意：今后在项目开发中，一定要把 node_modules 文件夹，添加到 .gitignore 忽略文件中。 5.3.2 快速创建 package.jsonnpm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建 package.json 这个包管理配置文件 1npm init -y 注意： ① 上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。 ② 运行 npm install 命令安装包的时候，npm 包管理工具会自动把包的名称和版本号，记录到 package.json 中。 5.3.3 dependencies 节点package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install 命令安装了哪些包。 123456//下载 dependencies 记录的所有包npm installnpm i//卸载包 npm uninstall 具体包名注意：npm uninstall 命令执行成功后，会把卸载的包，自动从 package.json 的 dependencies 中移除掉。 5.3.4 devDependencies 节点如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 devDependencies 节点中。 与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。 123//安装指定包到 devDependencies 节点中npm i 包名 -Dnpm install 包名 --save-dev-- 5.4 切换 npm 的下包镜像源下包的镜像源，指的就是下包的服务器地址。 为了更方便的切换下包的镜像源，我们可以安装 nrm 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下 包的镜像源。 123456//下载npm i nrm -g//查看所有镜像源nrm ls//切换下载镜像源nrm use 镜像源名 1234//查看当前下载包镜像源npm config get registry//查看当前下载包镜像源下载是否成功npm config set registry 5.5 包的分类使用 npm 包管理工具下载的包，共分为两大类，分别是：项目包和全局包 5.5.1 项目包那些被安装到项目的 node_modules 目录中的包，都是项目包。 项目包又分为两类，分别是： ⚫ 开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到） ⚫ 核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到） 1234//开发依赖包npm i 包名 -D//核心依赖包npm i 包名 5.5.2 全局包在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。 全局包会被安装到 C:\\Users\\用户目录\\AppData\\Roaming\\npm\\node_modules 目录下。 1234//全局安装指定的包npm i 包名 -g//卸载全局安装指定的包npm uninstall 包名 -g 注意： ① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。 ② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。 5.5.2.1 i5ting_toci5ting_toc 是一个可以把 md 文档转为 html 页面的小工具 1234//安装npm i i5ting_toc -g//调用i5ting_toc -f 要转换的md文件路径 -o 5.6 规范的包结构一个规范的包，它的组成结构，必须符合以下 3 点要求： ① 包必须以单独的目录而存在 ② 包的顶级目录下要必须包含 package.json 这个包管理配置文件 ③ package.json 中必须包含 name，version，main 这三个属性，分别代表包的名字、版本号、包的入口。 参考网站：https://yarnpkg.com/zh-Hans/docs/package-json 5.7 开发属于自己的包5.7.1 初始化包的基本结构① 新建 wt-tools 文件夹，作为包的根目录 ② 在 wt-tools 文件夹中，新建如下三个文件： ⚫ package.json （包管理配置文件） ⚫ index.js （包的入口文件） ⚫ README.md （包的说明文档） 创建的这个包的 README.md 文档中，会包含以下 6 项内容： 安装方式、导入方式、格式化时间、转义 HTML 中的特殊字符、还原 HTML 中的特殊字符、开源协议 5.7.2 将不同的功能进行模块化拆分① 将格式化时间的功能，拆分到 src -> dateFormat.js 中 ② 将处理 HTML 字符串的功能，拆分到 src -> htmlEscape.js 中 ③ 在 index.js 中，导入两个模块，得到需要向外共享的方法 ④ 在 index.js 中，使用 module.exports 把对应的方法共享出去 index.js拆分 ⚫dataFormat.js（格式化时间） ⚫htmlEscape.js（转义 HTML 中的特殊字符） 1234567891011&#123; &quot;name&quot;: &quot;wt-tools&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;description&quot;: &quot;提供了格式化时间，HTMLEscape的功能&quot;, &quot;keywords&quot;: [ &quot;wt&quot;, &quot;mjx&quot; ], &quot;license&quot;: &quot;ISC&quot;&#125; 12345678910111213141516171819202122// 定义格式化时间函数function dateFormat(dateStr) &#123; const dt = new Date(dateStr) const y = padZero(dt.getFullYear()) const m = padZero(dt.getMonth() + 1) const d = padZero(dt.getDate()) const hh = padZero(dt.getHours()) const mm = padZero(dt.getMinutes()) const ss = padZero(dt.getSeconds()) return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`&#125;// 补零函数function padZero(n) &#123; return n &gt; 9 ? n : &#x27;0&#x27; + n&#125;// 向外暴露module.exports = &#123; dateFormat&#125; 1234567891011121314151617181920212223242526272829303132333435// 转译html特殊字符function htmlEscape(htmlstr) &#123; return htmlstr.replace(/&lt;|&gt;|&quot;|&amp;/g, match =&gt; &#123; switch (match) &#123; case &#x27;&lt;&#x27;: return &#x27;&amp;lt;&#x27; case &#x27;&gt;&#x27;: return &#x27;&amp;gt;&#x27; case &#x27;&quot;&#x27;: return &#x27;&amp;quot;&#x27; case &#x27;&amp;&#x27;: return &#x27;&amp;amp;&#x27; &#125; &#125;)&#125;// 还原html字符串function htmlUnEscape(str) &#123; return str.replace(/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g, match =&gt; &#123; switch (match) &#123; case &#x27;&amp;lt;&#x27;: return &#x27;&lt;&#x27; case &#x27;&amp;gt;&#x27;: return &#x27;&gt;&#x27; case &#x27;&amp;quot;&#x27;: return &#x27;&quot;&#x27; case &#x27;&amp;amp;&#x27;: return &#x27;&amp;&#x27; &#125; &#125;)&#125;// 向外暴露需要的成员module.exports = &#123; htmlEscape, htmlUnEscape&#125; 123456789// 包入口文件const data = require(&#x27;./dataFormat&#x27;)const escape = require(&#x27;./htmlEscape&#x27;)// 向外暴露需要的成员module.exports = &#123; ...data, ...escape&#125; 1234567891011121314151617181920212223242526272829303132333435363738### 安装​``` npm install wu-tools​```### 导入​```jsconst wt = require(&#x27;./wt-tools/index&#x27;)​```### 格式化时间​```js//调用 dadateFormat 对时间进行格式化const dtStr = wt.dateFormat(new Date())// 结果 2022-07-17 15:51:33console.log(dtStr)​```### 转义 HTML 中的特殊字符​```js// 待转换的 HTML 字符串const htmlStr = &#x27;&lt;h1&gt;六六六&lt;/h1&gt;&#x27;// 调用 htmlEscape 方法进行转换const str = wt.htmlEscape(htmlStr)// 结果 &amp;lt;h1&amp;gt;六六六&amp;lt;/h1&amp;gt;console.log(str)​```### 还原 HTML 中的特殊字符​```js// 待还原的 HTML 字符串const uhtmlstr = wt.htmlUnEscape(str)// 结果 &lt;h1&gt;六六六&lt;/h1&gt;console.log(uhtmlstr)​```### 开源协议ISC 5.8 yarn跟 npm 相似的一个东西（第三方包的管理工具）公司用yarn比较多 与npm相比的优势： 1.速度快（并行下载） 2.离线安装（存在缓存） 3.版本信息统一（子依赖包信息清楚明确） 4.提示信息简介 12345678//安装npm i yarn -g//安装包yarn add 包名//卸载包yarn remove 包名//一次性安装包yarn 5.9 发布包5.9.1 注册 npm 账号① 访问 https://www.npmjs.com/ 网站，点击 sign up 按钮，进入注册用户界面 ② 填写账号相关的信息：Full Name、Public Email、Username、Password ③ 点击 Create an Account 按钮，注册账号 ④ 登录邮箱，点击验证链接，进行账号的验证 5.9.2 登录 npm 账号npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。 注意：在运行 npm login 命令之前，必须先把下包的服务器地址切换为 npm 的官方服务器。否则会导致发布包失败！ 5.9.3 把包发布到 npm 上将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：包名不能雷同）。 5.9.4 删除已发布的包运行 npm unpublish 包名 --force 命令，即可从 npm 删除已发布的包。 注意： ① npm unpublish 命令只能删除 72 小时以内发布的包 ② npm unpublish 删除的包，在 24 小时内不允许重复发布 ③ 发布包的时候要慎重，尽量不要往 npm 上发布没有意义的包！ 6-模块加载机制6.1 优先从缓存中加载模块在第一次加载后会被缓存。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。 注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。 6.2 内置模块的加载机制内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。 例如，require('fs') 始终返回内置的 fs 模块，即使在 node_modules 目录下有名字相同的包也叫做 fs。 6.3 自定义模块的加载机制使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。在加载自定义模块时，如果没有指定 ./ 或 ../ 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。 同时，在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件： ① 按照确切的文件名进行加载 ② 补全 .js 扩展名进行加载 ③ 补全 .json 扩展名进行加载 ④ 补全 .node 扩展名进行加载 ⑤ 加载失败，终端报错 6.4 第三方模块的加载机制如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父 目录开始，尝试从 /node_modules 文件夹中加载第三方模块。 如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。 例如，假设在 'C:\\Users\\itheima\\project\\foo.js' 文件里调用了 require('tools')，则 Node.js 会按以下顺序查找： ① C:\\Users\\itheima\\project\\node_modules\\tools ② C:\\Users\\itheima\\node_modules\\tools ③ C:\\Users\\node_modules\\tools ④ C:\\node_modules\\tools 6.5 目录作为模块当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式： ① 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口 ② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。 ③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module 'xxx' 7- Express7.1 Express 简介官方给出的概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。 通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。 Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。 Express 的中文官网： http://www.expressjs.com.cn/ 对于前端程序员来说，最常见的两种服务器，分别是： ⚫ Web 网站服务器：专门对外提供 Web 网页资源的服务器。 ⚫ API 接口服务器：专门对外提供 API 接口的服务器。 使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。 7.2 Express 使用7.2.1 安装express12//安装npm i express 7.2.2 创建web服务器12345678//1.导入const express = require(&#x27;express&#x27;)//2.创建web服务器const app = express()//3.调用启动服务器app.listen(80,() =&gt; &#123; console.log(&#x27;服务器已启动&#x27;)&#125;) 7.2.3 监听 GET 请求通过 app.get() 方法，可以监听客户端的 GET 请求 1234567app.get(&#x27;请求url&#x27;,function(req, res) &#123; console.log(&#x27;发起了get请求&#x27;)&#125;)//参数1：客户端请求的url地址//参数2：请求对应的处理函数// req:请求对象// res:响应对象 7.2.4 监听 POST 请求通过 app.post() 方法，可以监听客户端的 POST 请求 1234567app.post(&#x27;请求url&#x27;,function(req, res) &#123; console.log(&#x27;发起了post请求&#x27;)&#125;)//参数1：客户端请求的url地址//参数2：请求对应的处理函数// req:请求对象// res:响应对象 7.2.5 把内容响应给客户端通过 res.send() 方法，可以把处理好的内容，发送给客户端： 123456789app.get(&#x27;/user&#x27;, function(req, res) &#123; //向客户发送JSON对象 res.send(&#123;name:&#x27;张三&#x27;, age:18, sex:&#x27;男&#x27;&#125;)&#125;)app.post(&#x27;/user&#x27;, function(req, res) &#123; //向客户端发送文本内容 res.send(&#x27;请求成功&#x27;)&#125;) 7.2.6 获取 URL 中携带的查询参数通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数 1234567app.ger(&#x27;/&#x27;, function(req, res) &#123; //req.query 默认是一个空对象 //客户端使用 ？name=zs&amp;age=20 这种查询字符串形式，发送到服务器的参数 //可以通过 req.query 对象访问 如： // req.query.name req.query.age console.log(req.query)&#125;) 7.2.7 获取 URL 中的动态参数通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数 123456//url地址中，可以通过：参数名 的形式，匹配动态参数值app.get(&#x27;/user/id:&#x27;, (req, res) =&gt; &#123; //req.params 默认是一个空对象 //里面存放着：动态匹配到的参数值 console.log(req.params)&#125;) 7.3 托管静态资源7.3.1 express.static()express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器， 例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了 1app.use(express.static(&#x27;public&#x27;)) 现在，你就可以访问 public 目录中的所有文件了： h1ttp://localhost:3000/images/bg.jpg h1ttp://localhost:3000/css/style.css h1ttp://localhost:3000/js/login.js 注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。 因此，存放静态文件的目录名不会出现在 URL 中。 7.3.2 托管多个静态资源目录如果要托管多个静态资源目录，请多次调用 express.static() 函数 12app.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;)) 访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件 7.3.3 挂载路径前缀如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式 1app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;)) 现在，你就可以通过带有 /public 前缀地址来访问 public 目录中的文件了： h1ttp://localhost:3000/public/images/kitten.jpg h1ttp://localhost:3000/public/css/style.css h1ttp://localhost:3000/public/js/app.js 7.3.4 nodemon在编写调试 Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动 close 掉，然后再重新启动，非常繁琐。 现在，我们可以使用 nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件 的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试。 7.3.4.1 安装nodemon1npm i nodemon -g 7.3.4.2 使用nodemon当基于 Node.js 编写了一个网站应用的时候，传统的方式，是运行 node app.js 命令，来启动项目。这样做的坏处是： 代码被修改之后，需要手动重启项目。 现在，我们可以将 node 命令替换为 nodemon 命令，使用 nodemon app.js 来启动项目。这样做的好处是：代码 被修改之后，会被 nodemon 监听到，从而实现自动重启项目的效果。 1nodemon 文件名 7.4 Express 路由在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。 Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数 1app.请求的类型(请求的url地址, 处理函数) 123456app.get(&#x27;/&#x27;, function(req, res) &#123; res.send(&#x27;Hello&#x27;)&#125;)app.post(&#x27;/&#x27;, function(req, res) &#123; res.send(&#x27;Hello&#x27;)&#125;) 7.4.1 路由的匹配过程每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。 在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转 交给对应的 function 函数进行处理。 7.4.2 模块化路由为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 将路由抽离为单独模块的步骤如下： ① 创建路由模块对应的 .js 文件 ② 调用 express.Router() 函数创建路由对象 ③ 向路由对象上挂载具体的路由 ④ 使用 module.exports 向外共享路由对象 ⑤ 使用 app.use() 函数注册路由模块 123456789101112131415//创建路由模块//1.导入模块const express = require(&#x27;express&#x27;)//2.创建路由对象const router = express.Router()//3.挂载获取用户列表的路由router.get(&#x27;/user/list&#x27;, function (req, res) &#123; res.send(&#x27;获取用户列表&#x27;)&#125;)//4.挂载添加用户列表的路由router.post(&#x27;/user/add&#x27;, function (req, res) &#123; res.send(&#x27;添加用户列表&#x27;)&#125;)//5.向外导出路由对象module.exports = router 12345//注册路由模块//1.导入路由模块const userRouter = require(&#x27;./router/user.js&#x27;)//2.使用app.use() 注册路由模块app.use(userRouter) 7.5 中间件7.5.1 中间的处理环节Express 的中间件，本质上就是一个 function 处理函数 注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。 1234567891011121314151617181920212223const express = require(&#x27;express&#x27;)const app = express()// 中间件const fn1 = (req, res, next) =&gt; &#123; console.log(&#x27;11111&#x27;) next()&#125;app.use(fn1)// 中间件const fn2 = (req, res, next) =&gt; &#123; console.log(&#x27;22222&#x27;) // next()&#125;app.use(fn2)// 中间件app.use((req, res, next) =&gt; &#123; console.log(&#x27;33333&#x27;) next()&#125;)app.listen(80, () =&gt; &#123; console.log(&#x27;开启&#x27;)&#125;) 没有 next() 将不会往后执行代码 7.5.2 中间件的5个使用注意事项① 一定要在路由之前注册中间件 ② 客户端发送过来的请求，可以连续调用多个中间件进行处理 ③ 执行完中间件的业务代码之后，不要忘记调用 next() 函数 ④ 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码 ⑤ 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象 为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是： ① 应用级别的中间件 ② 路由级别的中间件 ③ 错误级别的中间件 ④ Express 内置的中间件 ⑤ 第三方的中间件 7.5.3 错误级别的中间件错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。 格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)。 注意：错误级别的中间件， 必须注册在所有路由之后！ 7.5.4 Express内置的中间件自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验： ① express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性） ② express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） ③ express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） 7.5.5 第三方的中间件非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置 第三方中间件，从而提高项目的开发效率。 例如：在 &#101;&#x78;&#112;&#x72;&#101;&#x73;&#x73;&#x40;&#52;&#x2e;&#49;&#54;&#x2e;&#48; 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步 骤如下： ① 运行 npm install body-parser 安装中间件 ② 使用 require 导入中间件 ③ 调用 app.use() 注册并使用中间件 注意：Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。 7.6 Express1234567891011121314151617const express = require(&#x27;express&#x27;)const app = express()// 配置解析表单数据的中间件app.use(express.urlencoded(&#123; extended: false &#125;))// 在路由之前配置 corsconst cors = require(&#x27;cors&#x27;)app.use(cors())// 导入路由const router = require(&#x27;./09_apiRouter&#x27;)// 把路由模块注册到app上app.use(&#x27;/api&#x27;, router)app.listen(85, () =&gt; &#123; console.log(&#x27;服务器已启动：http://127.0.0.1&#x27;)&#125;) 1234567891011121314151617181920212223242526272829const express = require(&#x27;express&#x27;)const router = express.Router()// 挂载对应的路由router.get(&#x27;/get&#x27;, (req, res) =&gt; &#123; // 通过 res.query 获取客户查询的字符串 发送到服务器数据 const query = req.query // 调用 res.send() 方法 向客户端响应处理结果 res.send(&#123; // 0:表示处理成功 1:表示处理失败 status: 0, // 状态描述 msg: &#x27;get请求成功&#x27;, // 需要响应给客户端的数据 data: query &#125;)&#125;)// post 接口router.post(&#x27;/post&#x27;, (req, res) =&gt; &#123; // req.body 获取请求体包含的 url-encoded 格式数据 const body = req.body res.send(&#123; status: 0, msg: &#x27;post请求&#x27;, body: body &#125;)&#125;)module.exports = router 7.6.1 接口的跨域问题刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。 解决接口跨域问题的方案主要有两种： ① CORS（主流的解决方案，推荐使用） ② JSONP（有缺陷的解决方案：只支持 GET 请求） 7.6.2 使用 cors 中间件解决跨域问题cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。 使用步骤分为如下 3 步： ① 运行 npm install cors 安装中间件 ② 使用 const cors = require('cors') 导入中间件 ③ 在路由之前调用 app.use(cors()) 配置中间件 7.6.3 CORS 的注意事项① CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。 ② CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服 务端接口（例如：IE10+、Chrome4+、FireFox3.5+） 7.6.4 CORS 响应头部 - Access-Control-Allow-Origin响应头部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下: 1Access-Control-Allow-Origin:&lt;origin&gt; | * 其中，origin 参数的值指定了允许访问该资源的外域 URL。 例如，下面的字段值将只允许来自 http://itcast.cn 的请求： 1res.setHeader(&#x27;Access-Control-Allow-Origin:&lt;origin&gt;&#x27;, &#x27;http://itcast.cn&#x27;) 如果指定了 Access-Control-Allow-Origin 字段的值为通配符 *，表示允许来自任何域的请求，示例代码如下： 1res.setHeader(&#x27;Access-Control-Allow-Origin:&lt;origin&gt;&#x27;, &#x27;*&#x27;) 7.6.5 CORS 响应头部 - Access-Control-Allow-Headers默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头： Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、 Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一） 如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外 的请求头进行声明，否则这次请求会失败！ 多个请求头用英文逗号隔开（ , ） 1res.setHeader(&#x27;Access-Control-Allow-Origin:&lt;origin&gt;&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;) 7.6.6 CORS 响应头部 Access-Control-Allow-Methods默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。 如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法。 1234//只允许 post,get,delete,head 请求方式res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)//允许所有的 http 请求方式res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;) 7.6.7 CORS请求的分类客户端在请求 CORS 接口时，根据请求方式和请求头的不同，可以将 CORS 的请求分为两大类，分别是： ① 简单请求 ② 预检请求 7.6.8 简单请求同时满足以下两大条件的请求，就属于简单请求： ① 请求方式：GET、POST、HEAD 三者之一 ② HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、 Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form\u0002 urlencoded、multipart/form-data、text/plain） 7.6.9 预检请求只要符合以下任何一个条件的请求，都需要进行预检请求： ① 请求方式为 GET、POST、HEAD 之外的请求 Method 类型 ② 请求头中包含自定义头部字段 ③ 向服务器发送了 application/json 格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一 次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。 简单请求和预检请求的区别 简单请求的特点：客户端与服务器之间只会发生一次请求。 预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。 7.7 JSONP 接口概念：浏览器端通过 标签的 src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据 的方式叫做 JSONP。 特点： ① JSONP 不属于真正的 Ajax 请求，因为它没有使用 XMLHttpRequest 这个对象。 ② JSONP 仅支持 GET 请求，不支持 POST、PUT、DELETE 等请求。 7.7.1 创建 JSONP 接口的注意事项如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口。 123456//优先创建 JSONP 接口 这个接口不会被处理成 cors 接口app.get(&#x27;/api/jsonp&#x27;, (req, res) =&gt; &#123; &#125;)//在配置 cors 中间件 后续的所有接口，都会被处理成 cors 接口app.use(cors())//开启cors的接口app.get(&#x27;/api/get&#x27;, (req, res) =&gt; &#123; &#125;) 7.7.2 实现 JSONP 接口的步骤① 获取客户端发送过来的回调函数的名字 ② 得到要通过 JSONP 形式发送给客户端的数据 ③ 根据前两步得到的数据，拼接出一个函数调用的字符串 ④ 把上一步拼接得到的字符串，响应给客户端的 标签进行解析执行 12345678910111213app.get(&#x27;/api/jsonp&#x27;, (req, res) =&gt; &#123; //获取客户端发送回调函数的名字 const funcName = req.query.callback //通过 JSONP 的形式发送客户端数据 const data = &#123; name:&#x27;zs&#x27;, age:18, &#125; //根据前两步得到的数据 拼接出一个函数调用的字符串 const scripStr = `$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)` //把上一步拼接得到的字符串 响应给客户端的 &lt;script&gt; 标签进行解析 res.send(scriptStr)&#125;) 7.7.3 在网页中使用 jQuery 发起 JSONP 请求调用 $.ajax() 函数，提供 JSONP 的配置选项，从而发起 JSONP 请求，示例代码如下： 1234567891011$(&#x27;#btnJSONP&#x27;).on(&#x27;click&#x27;, function () &#123; $.ajax(&#123; method:&#x27;get&#x27;, url:&#x27;127.0.0.1/api/jsonp&#x27;, //表示发起 JSONP 的请求 dataType:&#x27;jsonp&#x27;, success: function (res) &#123; console.log(res) &#125; &#125;)&#125;) 8-数据库8.1 数据库的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 导入 mysql 模块const mysql = require(&#x27;mysql&#x27;)// 简历数据库连接const db = mysql.createPool(&#123; // 数据库IP地址 host: &#x27;127.0.0.1&#x27;, // 默认端口 port: 3306, // 登录数据库账户 user: &#x27;root&#x27;, // 登录数据库密码 password: &#x27;root&#x27;, // 指定操作那个数据库 database: &#x27;qianduan48&#x27;,&#125;)// 测试 MySQL 模块是否连接成功// db.query(&#x27;select 1&#x27;, (err, results) =&gt; &#123;// if (err) return console.log(err.message)// console.log(results)// &#125;)// 查询数据库表的数据db.query(&#x27;select * from student&#x27;, (err, results) =&gt; &#123; // 查询失败 if (err) return console.log(err.message) // 查询成功 console.log(results)&#125;)// 插入数据const studentStr = &#123; stu_id: 4, stu_name: &#x27;赵六&#x27;, stu_age: 20, stu_sex: &#x27;男&#x27;, stu_status: &#x27;在校&#x27;&#125;// // 执行sql语句// const sqlStr = &#x27;insert into student values(?,?,?,?,?)&#x27;// // 使用数组的形式，依次为？占位符指定具体的值// db.query(sqlStr, [studentStr.stu_id, studentStr.stu_name, studentStr.stu_age, studentStr.stu_sex, studentStr.stu_status], (err, results) =&gt; &#123;// if (err) return console.log(err.message)// if (results.affectedRows === 1) &#123;// console.log(&#x27;数据插入成功&#x27;)// &#125;// &#125;)// 执行sql语句const sqlStr = &#x27;insert into student set ?&#x27;// 使用数组的形式，依次为？占位符指定具体的值db.query(sqlStr, [studentStr], (err, results) =&gt; &#123; if (err) return console.log(err.message) if (results.affectedRows === 1) &#123; console.log(&#x27;数据插入成功&#x27;) &#125;&#125;) 8.2 sql语句8.2.1 基础 切换数据库 1use 数据库的名字; 增 123insert into users (username, password) values (&#x27;tl&#x27;, &#x27;123456&#x27;);insert into users set username=&#x27;tl&#x27;, password =&#x27;123456&#x27;; 删 1delete from users where id = 1; 改 1update users set status = 1 where username = &#x27;tl&#x27;; 查 123select * from users;select username, password from users; 8.2.2 拓展 where 1select * from users where id!=1 and status =0; order by 1select * from users order by id desc, status asc; count 1select count(*) from users; as 1select count(*) as total from users;8.2.3 8.3.2 sql使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-- 通过 * 把 users 表中所有的数据查询出来-- select * from users-- 从 users 表中把 username 和 password 对应的数据查询出来-- select username, password from users-- 向 users 表中，插入新数据，username 的值为 tony stark password 的值为 098123-- insert into users (username, password) values (&#x27;tony stark&#x27;, &#x27;098123&#x27;)-- select * from users-- 将 id 为 4 的用户密码，更新成 888888-- update users set password=&#x27;888888&#x27; where id=4-- select * from users-- 更新 id 为 2 的用户，把用户密码更新为 admin123 同时，把用户的状态更新为 1-- update users set password=&#x27;admin123&#x27;, status=1 where id=2-- select * from users-- 删除 users 表中， id 为 4 的用户-- delete from users where id=4-- select * from users-- 演示 where 子句的使用-- select * from users where status=1-- select * from users where id&gt;=2-- select * from users where username&lt;&gt;&#x27;ls&#x27;-- select * from users where username!=&#x27;ls&#x27;-- 使用 AND 来显示所有状态为0且id小于3的用户-- select * from users where status=0 and id&lt;3-- 使用 or 来显示所有状态为1 或 username 为 zs 的用户-- select * from users where status=1 or username=&#x27;zs&#x27;-- 对users表中的数据，按照 status 字段进行升序排序-- select * from users order by status-- 按照 id 对结果进行降序的排序 desc 表示降序排序 asc 表示升序排序（默认情况下，就是升序排序的）-- select * from users order by id desc-- 对 users 表中的数据，先按照 status 进行降序排序，再按照 username 字母的顺序，进行升序的排序-- select * from users order by status desc, username asc-- 使用 count(*) 来统计 users 表中，状态为 0 用户的总数量-- select count(*) from users where status=0-- 使用 AS 关键字给列起别名-- select count(*) as total from users where status=0-- select username as uname, password as upwd from users 9-前后端的身份认证9.1 Session 认证机制9.1.1 什么是 CookieCookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用 于控制 Cookie 有效期、安全性、使用范围的可选属性组成。 不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。 Cookie的几大特性： ① 自动发送 ② 域名独立 ③ 过期时限 ④ 4KB 限制 9.1.2 Cookie 在身份认证中的作用客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中。 随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给 服务器，服务器即可验明客户端的身份。 9.1.3 Cookie 不具有安全性由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全 性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。 9.2 什么是 JWTJWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。 9.2.1 JWT 的工作原理用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过对 Token 字符串进行解析来认证用户的身份。 9.2.2 JWT 的组成部分JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。三者之间使用英文的“.”分隔。 9.2.3 JWT 的三个部分各自代表的含义JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。 其中： ⚫ Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。 ⚫ Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。 9.2.4 jwt-了解jwt的使用方式问题： 前端在进行开发的时候，往往是怎样使用jwt的（3点）？ 客服端往往通过调服务器的登录接口获取token 客户端收到服务器返回的 JWT 之后，通常会将它储存在 浏览器本地存储空间中。 此后，客户端调用需要进行用户认证的接口时会在请求头中 带上这个 JWT 的字符串，从而进行身份认证。 思考： 后端需要做哪些事情？ 在提供的登录接口，得验证用户名和密码是否合法，如果合法，则返回token(这个token中携带了用户标识) 在提供得需要进行用户认证得接口中，得对用户发过来得token做解析， 要求token是没有过期，而且是合法得，会得到token中隐藏得用户标识 响应和用户相关的内容 9.2.5 jwt-安装并导入jwt相关的包问题： 在express中使用jwt需要安装哪两个包？分别有什么用？执行什么命令？ jsonwebtoken 用于生成 JWT 字符串 express-jwt 用于将 JWT 字符串解析还原成 JSON 对象 1npm install jsonwebtoken express-jwt 9.2.6 jwt-定义secret秘钥问题： 为什么需要定义secret秘钥？在哪两个场景中将会使用到secret 为了保证 JWT 字符串的安全性，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密 的 secret 密钥 ① 当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串 ② 当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密 9.2.7 jwt-调用jsonwebtoken提供的sign方法生成token字符串问题： 生成token需要使用谁提供的什么方法？需要指定哪3个参数？ jsonwebtoken提供的sign方法 3个参数 js对象 密钥 配置信息，expiresIn是token有效时间 1var token = jwt.sign(&#123; username: userinfo.username &#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27; &#125;) 9.2.8 jwt-将jwt字符串还原为json对象问题： 解析token需要配置哪个中间件？配置完这个中间件后会帮我们解析token,并将解析出来的用户信息挂载在req的什么属性上？ 需要配置express-jwt 这个中间件 只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上 12// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上app.use(expressJWT(&#123; secret: secretKey &#125;).unless(&#123; path: [/^\\/api\\//] &#125;)) 9.2.9 jwt-使用req.user获取用户信息问题： 配置了 express-jwt 这个中间件之后，会把解析出来的用户信息，挂载到 req的什么属性上？ req.user 9.2.10 jwt-捕获解析jwt失败后产生的错误问题： 哪两种情况下会导致express-jwt中间件解析token失败？ 不合法：token是非法伪造的 过期：token是正常获取的，但过期了。 express-jwt中间件解析token失败后会抛出什么错误异常？我们需要怎样俘获，返回什么结果？ UnauthorizedError 使用中间件俘获，返回401的状态码 12345678910111213app.use((err, req, res, next) =&gt; &#123; // 这次错误是由 token 解析失败导致的 if (err.name === &#x27;UnauthorizedError&#x27;) &#123; return res.send(401, &#123; status: 401, message: &#x27;无效的token&#x27;, &#125;) &#125; res.send(&#123; status: 500, message: &#x27;未知的错误&#x27;, &#125;)&#125;) 拓展： 你可以说说有哪些常见的http状态码，各有什么含义吗（面试题）？ 2xx： 成功 200 成功 201 创建成功 3xx：重定向 301：永久重定向 302：临时重定向 4xx： 客服端的错误 400：客服端的错误，请求错误 401：认证失败：我不知道你是谁 403：没有权限：我知道你是谁，但是对不起，你没有权限 404：没找到 405：请求方式不支持 5xx： 500： 服务器的错误 9.3 你可以说说你对cookie和session的理解吗？他们之间有什么不同 cookie的原理： 第一次访问登录接口的时候，登录接口的响应头中会包含一个set-cookie的响应头，这个响应头中包含用户的标识 浏览器在接收到响应之后，会自动的把set-cookie的响应头中的用户标识信息给存储在浏览器的本地存储空间cookie中 再次访问服务器的时候，浏览器会自动的在请求头中携带cookie信息，服务器对cookie信息进行解析，就能够知道你是谁了 cookie特点： 自动发送 域名独立 4K限制 具有时效性 session的原理 服务器会给每个客服端开辟一个session的内存空间，来存储用户的关键信息等数据 每个session的内存空间都拥有不同的标识，这个session内存空间的标识，会通过cookie的形式告诉客服端 客服端在访问服务器的时候，会在cookie的请求头中携带上session内存空间的标识，后端就会利用session内存空间的标识去找到特定的session存储空间，去把用户的关键信息取出来 他们之间有什么不同 session的实现依赖于cookie cookie存储在浏览器客服端，session存储在服务器 cookie是不安全的，cookie里不能放敏感信息，而session是安全的，而session里是可以放敏感信息的。 10- ES6模块化与异步编程高级用法10.1 什么是 ES6 模块化规范ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学 习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范。 ES6 模块化规范中定义： ⚫ 每个 js 文件都是一个独立的模块 ⚫ 导入其它模块成员使用 import 关键字 ⚫ 向外共享模块成员使用 export 关键字 10.1.1 ES6 模块化的基本语法ES6 的模块化主要包含如下 3 种用法： ① 默认导出与默认导入 1234//默认导出export default 默认导出的成员//默认导入import 接收名称 from &#x27;模块标识符&#x27; 注意：每个模块中，只允许使用唯一的一次 export default，否则会报错！ ② 按需导出与按需导入 1234//按需导出export 按需导出的成员//按需导入 import &#123; s1 &#125; from &#x27;模块标识符&#x27; 按需导出与按需导入的注意事项 1.每个模块中可以使用多次按需导出 2.按需导入的成员名称必须和按需导出的名称保持一致 3.按需导入时，可以使用 as 关键字进行重命名 4.按需导入可以和默认导入一起使用 ③ 直接导入并执行模块中的代码 如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模 块代码，示例代码如下 1import &#x27;模块标识符&#x27; 10.2 Promise10.2.1 Promise 的基本概念① Promise 是一个构造函数 ⚫ 我们可以创建 Promise 的实例 const p = new Promise() ⚫ new 出来的 Promise 实例对象，代表一个异步操作 ② Promise.prototype 上包含一个 .then() 方法 ⚫ 每一次 new Promise() 构造函数得到的实例对象， ⚫ 都可以通过原型链的方式访问到 .then() 方法，例如 p.then() ③ .then() 方法用来预先指定成功和失败的回调函数 ⚫ p.then(成功的回调函数，失败的回调函数) ⚫ p.then(result => { }, error => { }) ⚫ 调用 .then() 方法时，成功的回调函数是必选的、失败的回调函数是可选的 10.2.2 基于 Promise 按顺序读取文件的内容1234567891011121314151617181920212223import thenFS from &#x27;then-fs&#x27;thenFS .readFile(&#x27;./files/11.txt&#x27;, &#x27;utf8&#x27;) // 捕获11出现错误，后续代码继续执行 .catch((err) =&gt; &#123; console.log(err.message) &#125;) .then(res =&gt; &#123; console.log(res) return thenFS.readFile(&#x27;./files/2.txt&#x27;, &#x27;utf8&#x27;) &#125;) .then(res =&gt; &#123; console.log(res) return thenFS.readFile(&#x27;./files/3.txt&#x27;, &#x27;utf8&#x27;) &#125;) .then(res =&gt; &#123; console.log(res) &#125;) // 捕获catch之前出现的错误，中断后续代码执行 // .catch((err) =&gt; &#123; // console.log(err.message) // &#125;) 10.2.3 Promise 方法Promise.all() 方法会发起并行的 Promise 异步操作，等所有的异步操作全部结束后才会执行下一步的 .then 操作（等待机制）。 Promise.race() 方法会发起并行的 Promise 异步操作，只要任何一个异步操作完成，就立即执行下一步的 .then 操作（赛跑机制）。 12345678910111213141516import thenFs from &quot;then-fs&quot;;const arr = [ thenFs.readFile(&#x27;./files/1.txt&#x27;,&#x27;utf8&#x27;), thenFs.readFile(&#x27;./files/2.txt&#x27;,&#x27;utf8&#x27;), thenFs.readFile(&#x27;./files/3.txt&#x27;,&#x27;utf8&#x27;)]// 等待 数组中的所有异步操作执行完 再执行 then 并且结果是数组顺序Promise.all(arr).then(res =&gt; &#123; console.log(res)&#125;)// 赛跑 哪个异步执行的块 就结束 并且拿到快的异步的结果// Promise.race(arr).then(res =&gt; &#123;// console.log(res)// &#125;) 10.2.4 基于 Promise 封装读文件的方法方法的封装要求： ① 方法的名称要定义为 getFile ② 方法接收一个形参 fpath，表示要读取的文件的路径 ③ 方法的返回值为 Promise 实例对象 1234567891011121314151617181920212223242526import fs from &#x27;fs&#x27;// 封装函数function getFile(path) &#123; const p = new Promise(function (resolve, reject) &#123; fs.readFile(path, &#x27;utf8&#x27;, (err, res) =&gt; &#123; if (err) return reject.err resolve(res) &#125;) &#125;) return p&#125;getFile(&#x27;./files/1.txt&#x27;) .then(res =&gt; &#123; console.log(res) return getFile(&#x27;./files/2.txt&#x27;) &#125;) .then(res =&gt; &#123; console.log(res) return getFile(&#x27;./files/3.txt&#x27;) &#125;) .then(res =&gt; &#123; console.log(res) &#125;) 10.3 async/await10.3.1 什么是 async/awaitasync/await 是 ES8（ECMAScript 2017）引入的新语法，用来简化 Promise 异步操作。在 async/await 出现之前，开发者只能通过链式 .then() 的方式处理 Promise 异步操作。 1234567891011121314import getFn from &#x27;then-fs&#x27;async function test() &#123; const res = await getFn(&#x27;./files/1.txt&#x27;) console.log(res) const res2 = await getFn(&#x27;./files/2.txt&#x27;) console.log(res2) const res3 = await getFn(&#x27;./files/3.txt&#x27;) console.log(res3)&#125;test() 10.3.2 async/await 的使用注意事项① 如果在 function 中使用了 await，则 function 必须被 async 修饰 ② 在 async 方法中，第一个 await 之前的代码会同步执行，await 之后的代码会异步执行 10.4 EventLoop10.4.1 JavaScript 是单线程的语言JavaScript 是一门单线程执行的编程语言。也就是说，同一时间只能做一件事情。 单线程执行任务队列的问题： 如果前一个任务非常耗时，则后续的任务就不得不一直等待，从而导致程序假死的问题。 10.4.2 同步任务和异步任务为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类： ① 同步任务（synchronous） ⚫ 又叫做非耗时任务，指的是在主线程上排队执行的那些任务 ⚫ 只有前一个任务执行完毕，才能执行后一个任务 ② 异步任务（asynchronous） ⚫ 又叫做耗时任务，异步任务由 JavaScript 委托给宿主环境进行执行 ⚫ 当异步任务执行完成后，会通知 JavaScript 主线程执行异步任务的回调函数 10.4.3 同步任务和异步任务的执行过程① 同步任务由 JavaScript 主线程次序执行 ② 异步任务委托给宿主环境执行 ③ 已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行 ④ JavaScript 主线程的执行栈被清空后，会读取任务队列中的回调函数，次序执行 ⑤ JavaScript 主线程不断重复上面的第 4 步 10.4.5 EventLoop 的基本概念JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又称为 EventLoop（事件循环）。 10.4.6 宏任务和微任务JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是： ① 宏任务（macrotask） ⚫ 异步 Ajax 请求、 ⚫ setTimeout、setInterval、 ⚫ 文件操作 ⚫ 其它宏任务 ② 微任务（microtask） ⚫ Promise.then、.catch 和 .finally ⚫ process.nextTick ⚫ 其它微任务 每一个宏任务执行完之后，都会检查是否存在待执行的微任务，如果有，则执行完所有微任务之后，再继续执行下一个宏任务。","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"}]},{"title":"初识(四)","slug":"初识-四","date":"2022-11-06T03:43:20.000Z","updated":"2022-11-06T04:10:23.416Z","comments":true,"path":"2022/11/06/初识-四/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E5%9B%9B/","excerpt":"","text":"Ajax1- URL地址URL(UniformResourceLocator) 中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。 浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。 1.1 URL地址一般由三部分组成：1.客户端与服务器之间的通信协议 2.存有该资源的服务器名称 3.资源在服务器上具体的存放位置 1.2 资源的请求方式客户端请求服务器时，请求的方式有很多种，最常见的两种方式分别为get和post请求。 1.get 请求通常用于获取服务端资源（向服务器要资源） 例如：根据URL地址,从服务器获取HTML文件、css文件、js文件、图片文件、数据资源等 2.post请求通常用于向服务器提交数据（往服务器发送资源） 例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作。 2- AjaxAjax全称是：Asynchronous Javascript And XML（异步JavaScript和XML） 通俗的理解：在网页中利用XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。 Ajax能让我们轻松实线网页与服务器之间的数据交互。 Ajax的应用场景 用户名检测：注册用户时，通过Ajax的形式，动态检测用户名是否被占用 搜索提示：当输入搜索关键字时，通过Ajax的形态，动态加载搜索提示列表 3- jQuery中的Ajax3.1 $.get()函数的语法1$.get(url,[data],[callback]) url:请求的资源地址（string） 必写 data：请求资源期间要携带的参数（object） 可写 callback：请求成功时的回调函数（function） 可写 12345678910111213$.get(&#x27;http://ajax-base-api-t.itheima.net/api/getbooks&#x27;, &#123; author: &#x27;曹雪芹&#x27; &#125;, function (res) &#123; console.log(res) &#125;)$.get(&#123; url: &#x27;http://ajax-base-api-t.itheima.net/api/getbooks&#x27;, data: &#123; id: 1527 &#125; &#125;, function (res) &#123; console.log(res) &#125;) 3.2 $.post()语法用来发起 post 请求，从而向服务器提交数据 1$.post(url,[data],[callback]) 123456789101112131415161718$.post(&quot;http://ajax-base-api-t.itheima.net/api/addbook&quot;,&#123; bookname:&#x27;水浒传&#x27;, author:&#x27;吴承恩&#x27;, publisher:&#x27;北京出版社&#x27; &#125;,function(res)&#123; console.log(res) &#125;)$.post(&#123; url: &#x27;http://ajax-base-api-t.itheima.net/api/getbooks&#x27;, data: &#123; bookname:&#x27;水浒传&#x27;, author:&#x27;吴承恩&#x27;, publisher:&#x27;北京出版社&#x27; &#125; &#125;, function (res) &#123; console.log(res) &#125;) 3.3 $.ajax函数是一个功能比较综合的函数，它允许我们对 Ajax 请求进行更详细的配置。 1234567891011121314151617// $.ajax(url,[settings]) settings 配置项（对象） // &#123; // url 请求的地址 // type 请求的方式 // data 请求需要的参数 // success 成功的回调函数 // &#125; $.ajax(&#123; url: &#x27;http://ajax-base-api-t.itheima.net/api/getbooks&#x27;, type: &#x27;get&#x27;, data: &#123; id: 5 &#125;, success(res) &#123; console.log(res) &#125; &#125;) 4-接口使用 Ajax 请求数据时，被请求的 URL 地址，就叫做 数据接口（简称接口）。同时，每个接口必须有请求方式。 4.1接口测试为了验证接口是否被正常被访问，我们常常需要使用接口测试工具，来对数据接口进行检测 好处：接口测试工具能让我们在 不写任何代码 的情况下，对接口进行 调用 和 测试常用的就是：PostMan 4.2接口文档接口文档，顾名思义就是 接口的说明文档，它是我们调用接口的依据。好的接口文档包含了对 接口URL，参数 以及 输出内容 的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用 接口文档的组成部分 接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下6项内容，从而为接口的调用提供依据： 接口名称：用来标识各个接口的简单说明，如 登录接口，获取图书列表接口等 接口URL：接口的调用地址 调用方式：接口的调用方式，如 GET 或者 POST 参数格式：接口需要传递的参数，每个参数必须包含 参数名称、参数类型、是否必选、参数说明这4项内容 响应格式：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容 返回示例（可选）：通过对象的形式，列举服务器返回数据的结构 5-form表单表单在网页中主要负责 数据采集功能。HTML中&lt;form&gt;标签，就是用于采集用户输入的信息，并通过 &lt;form&gt; 标签的提交操作，把采集的信息提交到服务器端进行处理 5.1标签的属性5.1.1**action** 属性用来规定当提交表单时，向何处发送表单数据。 action 属性的值应该是后端提供的一个URL地址，这个URL地址专门负责接收表单提交过来的数据。 当 &lt;form&gt;表单在未制定 action 属性值的清空下，action的默认值为当前页面的 URL 地址 注意: 当提交表单后，会立即跳转到 action 属性指定的 URL 地址。 5.1.2**target** 属性用来规定 在何处打开 action URL 它的可选值有5个，默认情况下，target的值是 _self，表示在相同的框架中打开 action URL _blank：在新窗口打开 _self：默认。在相同的框架上打开 _parent：在父框架集中打开 _top：在整个窗口打开 framename：在指定的框架上打开 5.1.3method属性method 属性用来规定 以何种方式 把表单数据提交到 action URL 它的可选值有两个，分别是 get 和 post 默认情况下，method的值为 get， 表示通过URL地址的形式，把表单数据提交到 action URL 注意： get 方式适合用来提交少量的，简单的数据 post 方式适合用来提交大量的，复杂的，或包含文件上传的数据 5.1.4enctype属性enctype属性用来规定在 发送表单数据之前如何对数据进行编码 它的可选值有三个，默认情况下，enctype的值为 application/x-www-form-urlencoded，表示在发送前编码的所有字符。 5.1.5表单同步提交的缺点 &lt;form&gt; 表单同步提交后，整个页面会发生跳转，跳转到 action URL 所指向的地址，用户体验很差 &lt;form&gt; 表单同步提交后，页面之前的状态和数据会丢失 如何解决呢？ 表单只复杂采集数据，Ajax负责将数据提交到服务器 jQuery中监听表单提交事件的两种方式 .submit &#x2F; .on 123456789101112131415$(function()&#123; // 绑定提交事件 $(&#x27;form&#x27;).submit(function(e)&#123; // 阻止默认行为 // e.preventDefault() console.log(111) // 在jQuery中能阻止默认行为和冒泡 return false &#125;) // $(&#x27;form&#x27;).on(&#x27;submit&#x27;,function(e)&#123; // e.preventDefault() // console.log(222) // &#125;) &#125;) 5.1.6阻止表单默认提交行为当监听到表单的提交事件以后，可以调用事件对象的 event.preventDefault() 函数，来阻止表单的提交和页面的跳转 5.1.7serialize() 函数serialize() 函数能够快速获取表单 注意：在使用 serialize() 函数快速获取表单数据时，必须为每个表单元素添加 name 属性 1$(&#x27;form&#x27;).serialize() 6-模板引擎模板引擎，它可以根据程序员指定的 模板结构 和 数据，自动生成一个完整的HTML页面 好处 减少了字符串的拼接操作 使代码结构更清晰 使代码更易于阅读与维护 6.1art-template模板引擎 导入 art-template 在window全局，就多了一个函数，叫做 template(‘模板id’，需要渲染的数据对象) 1&lt;script src=&quot;./lib/template-web.js&quot;&gt;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script type=&quot;text/html&quot; id=&quot;t1&quot;&gt; &lt;div&gt; 姓名：&#123;&#123;name&#125;&#125;-年龄：&#123;&#123;age&#125;&#125;- a是&#123;&#123;data.a&#125;&#125;-b是&#123;&#123;data.b&#125;&#125;- a+b=&#123;&#123;data.a+data.b&#125;&#125;- 您的性别为：&#123;&#123;sex === 0 ? &#x27;男&#x27; : &#x27;女&#x27;&#125;&#125;- strong标签&#123;&#123;@strong&#125;&#125; &lt;/div&gt; &#123;&#123;if ifLogin === true&#125;&#125; 欢迎&#123;&#123;name&#125;&#125; &#123;&#123;else&#125;&#125; 请登录 &#123;&#123;/if&#125;&#125; &#123;&#123;if isLogin === true&#125;&#125; 欢迎&#123;&#123;name&#125;&#125; &#123;&#123;/if&#125;&#125; ----------------------------------------- &lt;ul&gt; &#123;&#123;each arr&#125;&#125; &lt;li&gt;&#123;&#123;$value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;ul&gt; &#123;&#123;each arr&#125;&#125; &lt;li&gt;&#123;&#123;$index&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/script&gt; &lt;script&gt; const obj = &#123; name: &#x27;xm&#x27;, age: 18, sex: 0, data: &#123; a: 1, b: 2 &#125;, arr: [&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;王五&#x27;], isLogin: true, strong: &#x27;&lt;strong&gt;我是strong标签&lt;/strong&gt;&#x27;, &#125; let html = template(&#x27;t1&#x27;, obj) $(&#x27;.main&#x27;).html(html) &lt;/script&gt; 6.3过滤器过滤器本质就是一个 function 函数 1&#123;&#123;$value.money | fn&#125;&#125; 1template.defaults.imports.fn = function ( ) &#123; &#125; 123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/html&quot; id=&quot;t1&quot;&gt; &lt;ul&gt; &#123;&#123;each arr&#125;&#125; &lt;li&gt;我的手机是：&#123;&#123;$value.name&#125;&#125;，价格是：&#123;&#123;$value.money | fn&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/script&gt; &lt;script&gt; template.defaults.imports.fn = function (money) &#123; return money.toFixed(2) + &#x27;￥&#x27; &#125; const obj = &#123; arr: [&#123; name: &#x27;p20&#x27;, money: 1999, &#125;, &#123; name: &#x27;p30&#x27;, money: 2999, &#125;, &#123; name: &#x27;p40&#x27;, money: 3999, &#125;, &#123; name: &#x27;p50&#x27;, money: 4999, &#125; ] &#125; let html = template(&#x27;t1&#x27;, obj) $(&#x27;.main&#x27;).html(html) &lt;/script&gt; 6.4模板引擎的实现原理正则与字符串操作 6.4.1exec函数exec() 函数用于 检索字符串 中的正在表达式的匹配 如果字符串中又匹配的值，则返回该匹配值，否则返回 null 6.4.2分组正则表达式中 （） 包起来的内容表示一个分组，可以通过分组来 提取自己想要的内容，示例代码如下 123456let str = &#x27;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&#x27;let pattern = /&#123;&#123;([a-zA-Z]+)&#125;&#125;/let patternResult = pattern.exec(str)console.log(patternResult)//得到 name 相关的分组信息//[&quot;&#123;&#123;name&#125;&#125;&quot;,&quot;name&quot;,index: 7, input: &quot;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&quot;, groups: undefined] 6.4.3字符串的 replace 函数replace() 函数用于在字符串中 用一些字符 替换 另一些字符的 1let result = &#x27;123456&#x27;.replace(&#x27;123&#x27;,&#x27;abc&#x27;) // &#x27;abc456&#x27; 1234567891011121314151617181920// exec 提取出字符串中内容，每次匹配第一项，但是如果不存在正在匹配的内容 null // 场景：获取一个数据匹配的正则条件的内容 // 数组结果 = 正则表达式.exec(被匹配的字符串) // test 检测字符串是否包含 // 场景：判断一个数据是否满足正则条件 // 布尔值结果 = 正则表达式.test(被匹配的字符串) // ? 0||1 // + &gt;=1 // * &gt;=0 let reg = /\\d+/; let str = &#x27;abcaaabc&#x27;; console.log(reg.exec(str)); console.log([1,2,3]); // 目标：模拟模板引擎的template.js 完成核心、简单的替换 // 把模板中的 &#123;&#123;name&#125;&#125; 替换城真正的数据 yj // data = &#123; // name:yj // &#125; 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; const template = function(id,data)&#123; let html = document.querySelector(&#x27;#&#x27;+id).innerHTML; // console.log(&#x27;temp: &#x27;, temp); // 把下面字符串 // temp = &lt;div&gt;我的名字叫&#123;&#123;name&#125;&#125;，我今年&#123;&#123;age&#125;&#125;岁，我是&#123;&#123;sex&#125;&#125;生&lt;/div&gt; // 变成另一个字符串 // res = 我的名字叫yj，我今年18岁，我是男生 // console.log(data); // data[&#x27;name&#x27;] === yj let reg = /&#123;&#123;([0-9a-zA-Z]+)&#125;&#125;/; // exec 如果正则表达式在中间存在() 可以单独的被匹配出来 // res=reg.exec(temp) // console.log(&#x27;res: &#x27;, res); // let html = temp.replace(res[0],data[res[1]]) // console.log(&#x27;html: &#x27;, html); // res=reg.exec(html) // html = html.replace(res[0],data[res[1]]) // console.log(&#x27;html: &#x27;, html); // res=reg.exec(html) // html = html.replace(res[0],data[res[1]]) // console.log(&#x27;html: &#x27;, html); // let res = temp.replace(&#x27;&#123;&#123;name&#125;&#125;&#x27;,&#x27;yj&#x27;) // console.log(&#x27;res: &#x27;, res); // res = res.replace(&#x27;&#123;&#123;age&#125;&#125;&#x27;,&#x27;18&#x27;) // console.log(&#x27;res: &#x27;, res); // res = res.replace(&#x27;&#123;&#123;sex&#125;&#125;&#x27;,&#x27;男&#x27;) // console.log(&#x27;res: &#x27;, res); while(res=reg.exec(html))&#123; console.log(&#x27;res: &#x27;, res); html = html.replace(res[0],data[res[1]]) &#125; console.log(&#x27;html: &#x27;, html); return html &#125; &lt;/script&gt; 7-XMLHttpRequest的基本使用XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以请求服务器上的数据资源。之 前所学的 jQuery 中的 Ajax 函数，就是基于 xhr 对象封装出来的 7.1使用xhr发起GET请求步骤 创建 xhr 对象 调用 xhr.open() 函数 调用 xhr.send() 函数 监听 xhr.onreadystatechange 事件 12345678910111213// 1. 创建 XHR 对象var xhr = new XMLHttpRequest()// 2. 调用 open 函数xhr.open(&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;)// 3. 调用 send 函数xhr.send()// 4. 监听 onreadystatechange 事件xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; // 获取服务器响应的数据 console.log(xhr.responseText) &#125;&#125; XMLHttpRequest 对象的 readyState 属性，用来表示当前 Ajax 请求所处的状态。每个 Ajax 请求必然处于以 下状态中的一个： 7.2使用xhr发起带参数的GET请求使用 xhr 对象发起带参数的 GET 请求时，只需在调用 xhr.open 期间，为 URL 地址指定参数即可： 查询字符串定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量）。 格式：将英文的 ? 放在URL 的末尾，然后再加上 参数＝值 ，想加上多个参数的话，使用 &amp; 符号进行分隔。以 这个形式，可以将想要发送给服务器的数据添加到 URL 中。 12345678910111213141516171819202122// get 不带参数 &#123; let xhr = new XMLHttpRequest() xhr.open(&#x27;get&#x27;,&#x27;http://ajax-base-api-t.itheima.net/api/getbooks&#x27;) xhr.send() xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; console.log(xhr.response) &#125; &#125; &#125; // get 带参数 &#123; let xhr = new XMLHttpRequest() xhr.open(&#x27;get&#x27;,&#x27;http://ajax-base-api-t.itheima.net/api/getbooks?id=3&#x27;) xhr.send() xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; console.log(xhr.response) &#125; &#125; &#125; GET请求携带参数的本质无论使用 $.ajax()，还是使用 $.get()，又或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的。 7.3-URL编码与解码URL 地址中，只允许出现英文相关的字母、标点符号、数字，因此，在 URL 地址中不允许出现中文字符。 如果 URL 中需要包含中文这样的字符，则必须对中文字符进行编码（转义）。 URL编码的原则：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。 URL编码原则的通俗理解：使用英文字符去表示非英文字符 浏览器提供了 URL 编码与解码的 API，分别是： encodeURI() 编码的函数 decodeURI() 解码的函数 123456&lt;script&gt; let xyj = &#x27;西游记&#x27; // 编码 console.log(encodeURI(xyj)) // 解码 console.log(decodeURI(&#x27;%E8%A5%BF%E6%B8%B8%E8%AE%B0&#x27;)) 7.4使用xhr发起POST请求步骤 创建 xhr 对象 调用 xhr.open() 函数 设置 Content-Type 属性（固定写法） 调用 xhr.send() 函数，同时指定要发送的数据 监听 xhr.onreadystatechange 事件 1234567891011121314// 1. 创建 xhr 对象var xhr = new XMLHttpRequest()// 2. 调用 open 函数xhr.open(&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;)// 3. 设置 Content-Type 属性（固定写法）xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)// 4. 调用 send 函数xhr.send(&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=上海图书出版社&#x27;)// 5. 监听事件xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125; 8-JSON念：**JSON 的英文全称是 JavaScript Object Notation，即“JavaScript 对象表示法”。简单来讲，JSON就是Javascript对象和数组的字符串表示法，它使用文本表示一个JS&#96; 对象或数组的信息，因此， JSON 的本质是字符串。 作用：JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析。 现状：JSON 是在 2001 年开始被推广和使用的数据格式，到现今为止，JSON 已经成为了主流的数据交换格式 8.1JSON的两种结构JSON 就是用字符串来表示 Javascript 的对象和数组。所以，JSON 中包含对象和数组两种结构，通过这 两种结构的相互嵌套，可以表示各种复杂的数据结构。 8.1.1对象结构对象结构在 JSON 中表示为 &#123; &#125; 括起来的内容。数据结构为 &#123; key: value, key: value, … &#125; 的键 值对结构。其中，key 必须是使用英文的双引号包裹的字符串，value 的数据类型可以是数字、字符串、 布尔值、null、数组、对象6种类型。 8.1.2数组结构数组结构在 JSON 中表示为 [ ] 括起来的内容。数据结构为 [ &quot;java&quot;, &quot;javascript&quot;, 30, true … ] 。 数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。 8.2JSON语法注意事项① 属性名必须使用双引号包裹 ② 字符串类型的值必须使用双引号包裹 ③ JSON 中不允许使用单引号表示字符串 ④ JSON 中不能写注释 ⑤ JSON 的最外层必须是对象或数组格式 ⑥ 不能使用 undefined 或函数作为 JSON 的值 JSON 的作用：在计算机与网络之间存储和传输数据。 JSON 的本质：用字符串来表示 Javascript 对象数据或数组数据 8.3JSON和JS对象的关系JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。例如： 1234//这是一个对象const obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;world&#x27;&#125;//这是一个JSON字符串，本质就是一个字符串const json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; 8.4JSON和JS对象的互转要实现从 JSON 字符串转换为 JS 对象，使用 JSON.parse() 方法： 123// 实现从JSON字符串转换为JS对象，使用JSON.parse()方法 const jsonStr = &#x27;&#123;&quot;a&quot;:&quot;Hello&quot;,&quot;b&quot;:&quot;world&quot;&#125;&#x27; console.log(JSON.parse(jsonStr)) 要实现从 JS 对象转换为 JSON 字符串，使用 JSON.stringify() 方法： 123// 实现从JS对象转换为JSON字符串，使用JSON.stringify()方法 const json = JSON.stringify(&#123;a:&#x27;hello&#x27;,b:&#x27;world&#x27;&#125;) console.log(json) 1234567891011let myjson = &#123; &quot;name&quot; : &quot;张三&quot;, &quot;age&quot; : 18, &quot;arr&quot; : [&quot;a&quot;,&quot;b&quot;] &#125; // 对象变成JSON字符串 let json = JSON.stringify(myjson) console.log(json) // json字符串变成对象 let obj = JSON.parse(json) console.log(obj) 应用场景 1234567891011var xhr = new XMLHttpRequest()xhr.open(&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;)xhr.send()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) console.log(typeof xhr.responseText) var result = JSON.parse(xhr.responseText) console.log(result) &#125;&#125; 8.5序列化和反序列化把数据对象 转换为 字符串的过程，叫做序列化，例如：调用 JSON.stringify() 函数的操作，叫做 JSON 序列化。 把字符串 转换为 数据对象的过程，叫做反序列化，例如：调用 JSON.parse() 函数的操作，叫做 JSON 反序列化。 8.6封装自己的Ajax函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546function myAjax(options) &#123; console.log(options) // 准备数据 let &#123; url, tyep, data, success &#125; = options // 转换type 为大写 type = tyep.toLocaleUpperCase() // data 数据处理 let arr = [] for (let key in data) &#123; arr.push(key + &#x27;=&#x27; + data[key]) &#125; data = arr.join(&#x27;&amp;&#x27;) // 发起原生的请求 判断get和post let xhr = new XMLHttpRequest() if (tyep === &#x27;GET&#x27;) &#123; console.log(&#x27;get请求&#x27;) xhr.open(tyep, url + &#x27;?&#x27; + data) xhr.send() &#125; else &#123; console.log(&#x27;post 请求&#x27;) xhr.open(tyep, url) xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) xhr.send(data) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.response)) // 必须 存在 success 并且还是函数 typeof success === &#x27;function&#x27; &amp;&amp; success(JSON.parse(xhr.response)) &#125; &#125; &#125; // 调用 myAjax(&#123; url: &#x27;http://ajax-base-api-t.itheima.net/api/addbook&#x27;, tyep: &#x27;post&#x27;, data: &#123; bookname: &#x27;西游记2&#x27;, author: &#x27;666&#x27;, publisher: &#x27;48期&#x27; &#125;, success(res) &#123; console.log(res) &#125; &#125;) 8.7设置HTTP请求时限有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限： 12345678910111213141516171819202122&lt;script&gt; let xhr = new XMLHttpRequest() // 当前时间 let starTime = +new Date() console.log(starTime) // 超时限制 xhr.timeout = 52 xhr.open(&#x27;get&#x27;, &#x27;http://ajax-base-api-t.itheima.net/api/getbooks&#x27;) xhr.send() // 超时判断 xhr.ontimeout = function () &#123; console.log(&#x27;请求超时&#x27;) &#125; xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.response)) // 成功后当前时间 let endTime = +new Date() console.log(endTime) &#125; &#125; &lt;/script&gt; 8.8FormData对象管理表单数据1234567891011121314151617181920212223242526272829303132333435&lt;form action=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; let btn = document.querySelector(&#x27;button&#x27;) btn.onclick = function (e) &#123; // 方法1 // let data = new FormData(document.querySelector(&#x27;form&#x27;)) // let xhr = new XMLHttpRequest() // xhr.open(&#x27;post&#x27;, &#x27;http://ajax-base-api-t.itheima.net/api/formdata&#x27;) // xhr.send() // xhr.onreadystatechange = function () &#123; // if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; // console.log(JSON.parse(xhr.response)) // &#125; // &#125; // 方法2 let data2 = new FormData(document.querySelector(&#x27;form&#x27;)) data2.append(&#x27;id&#x27;, 1) data2.append(&#x27;iphone&#x27;, 6666666) data2.append(&#x27;wx&#x27;, 8888888) let xhr2 = new XMLHttpRequest() xhr2.open(&#x27;post&#x27;, &#x27;http://ajax-base-api-t.itheima.net/api/formdata&#x27;) xhr2.send(data2) xhr2.onreadystatechange = function () &#123; if (xhr2.readyState === 4 &amp;&amp; xhr2.status === 200) &#123; console.log(JSON.parse(xhr2.response)) &#125; &#125; e.preventDefault() &#125; 8.9上传文件新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件。 实现步骤： ① 定义 UI 结构 ② 验证是否选择了文件 ③ 向 FormData 中追加文件 ④ 使用 xhr 发起上传文件的请求 ⑤ 监听 onreadystatechange 事件 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;form&gt; &lt;input type=&quot;file&quot; name=&quot;avatar&quot; id=&quot;file&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;上传&quot; id=&quot;btn&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;&quot;&gt; &lt;/form&gt; &lt;script&gt; // 1.点击按钮 // 2.收集上传文件 // 3.发起请求 // 4.显示上传成功的图片 let btn = document.querySelector(&#x27;#btn&#x27;) btn.onclick = function () &#123; // console.log(1) // 获取方法1 let data = new FormData(document.querySelector(&#x27;form&#x27;)) // console.log(data) // let file = document.querySelector(&#x27;#file&#x27;) // console.dir(file) // 获取方法2 // let img = document.querySelector(&#x27;#file&#x27;).files[0] // console.log(img) // let data = new FormData() // data.append(&#x27;avatar&#x27;, img) let xhr = new XMLHttpRequest() xhr.open(&#x27;post&#x27;, &#x27;http://ajax-base-api-t.itheima.net/api/upload/avatar&#x27;) xhr.send(data) xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; let res = JSON.parse(xhr.response) // console.log(JSON.parse(xhr.response)) console.log(res) if (res.status !== 200) return alert(&#x27;网络异常&#x27;) let myimg = document.querySelector(&#x27;img&#x27;) myimg.src = &#x27;http://ajax-base-api-t.itheima.net&#x27; + res.url &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 8.10显示文件上传进度计算文件上传进度 新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。语法格式如下： 1234567891011// 创建 XHR 对象var xhr = new XMLHttpRequest()// 监听 xhr.upload 的 onprogress 事件xhr.upload.onprogress = function(e) &#123; // e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度 if (e.lengthComputable) &#123; // e.loaded 已传输的字节 // e.total 需传输的总字节 var percentComplete = Math.ceil((e.loaded / e.total) * 100) &#125; &#125; 导入需要的库 12&lt;link rel=&quot;stylesheet&quot; href=&quot;./lib/bootstrap.css&quot; /&gt;&lt;script src=&quot;./lib/jquery.js&quot;&gt;&lt;/script&gt; 基于Bootstrap渲染进度条 123456&lt;!-- 进度条 --&gt;&lt;div class=&quot;progress&quot; style=&quot;width: 500px; margin: 10px 0;&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-info progress-bar\u0002striped active&quot; id=&quot;percent&quot; style=&quot;width: 0%&quot;&gt; 0% &lt;/div&gt;&lt;/div&gt; 动态设置到进度条上 1234567891011xhr.upload.onprogress = function(e) &#123; if (e.lengthComputable) &#123; // 1. 计算出当前上传进度的百分比 var percentComplete = Math.ceil((e.loaded / e.total) * 100) $(&#x27;#percent&#x27;) // 2. 设置进度条的宽度 .attr(&#x27;style&#x27;, &#x27;width:&#x27; + percentComplete + &#x27;%&#x27;) // 3. 显示当前的上传进度百分比 .html(percentComplete + &#x27;%&#x27;) &#125;&#125; 监听上传完成的事件 1234567xhr.upload.onload = function() &#123; $(&#x27;#percent&#x27;) // 移除上传中的类样式 .removeClass() // 添加上传完成的类样式 .addClass(&#x27;progress-bar progress-bar-success&#x27;)&#125; 加载圈 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;立即上传&quot;&gt; &lt;img src=&quot;./loading.gif&quot; alt=&quot;&quot; style=&quot;display: none;&quot;&gt; &lt;script src=&quot;./lib/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 全局 .ajaxStart / .ajaxStop $(document).ajaxStart(function () &#123; $(&#x27;img&#x27;).show() &#125;) $(document).ajaxStop(function () &#123; $(&#x27;img&#x27;).hide() &#125;) $(&#x27;#btn&#x27;).click(function () &#123; let data = new FormData(document.querySelector(&#x27;form&#x27;)) $.ajax(&#123; url: &#x27;http://ajax-base-api-t.itheima.net/api/upload/avatar&#x27;, type: &#x27;post&#x27;, data: data, contentType: false, processData: false, // 局部 beforeSend() / complete() beforeSend() &#123; console.log(&#x27;请求发起&#x27;); &#125;, complete() &#123; console.log(&#x27;请求结束&#x27;); &#125;, success(res) &#123; console.log(res) &#125; &#125;) &#125;) &#125;) &lt;/script&gt; &lt;/form&gt;&lt;/body&gt; 8.11axiosAxios 是专注于网络数据请求的库。 相比于原生的 XMLHttpRequest 对象，axios 简单易用。 相比于 jQuery，axios 更加轻量化，只专注于网络数据请求。 8.11.1axios发起GET请求axios 发起 get 请求的语法： 1axios.get(&#x27;url&#x27;, &#123; params: &#123; /*参数*/ &#125; &#125;).then(callback) 具体的请求示例如下： 12345678910// 请求的 URL 地址var url = &#x27;http://www.liulongbin.top:3006/api/get&#x27;// 请求的参数对象var paramsObj = &#123; name: &#x27;zs&#x27;, age: 20 &#125;// 调用 axios.get() 发起 GET 请求axios.get(url, &#123; params: paramsObj &#125;).then(function(res) &#123; // res.data 是服务器返回的数据 var result = res.data console.log(res)&#125;) 8.11.2axios发起POST请求axios 发起 post 请求的语法： 1axios.post(&#x27;url&#x27;, &#123; /*参数*/ &#125;).then(callback) 具体的请求示例如下： 12345678910// 请求的 URL 地址var url = &#x27;http://www.liulongbin.top:3006/api/post&#x27;// 要提交到服务器的数据var dataObj = &#123; location: &#x27;北京&#x27;, address: &#x27;顺义&#x27; &#125;// 调用 axios.post() 发起 POST 请求axios.post(url, dataObj).then(function(res) &#123; // res.data 是服务器返回的数据 var result = res.data console.log(result)&#125;) 8.11.3直接使用axios发起请求axios 也提供了类似于 jQuery 中 $.ajax() 的函数，语法如下： 123456axios(&#123; method: &#x27;请求类型&#x27;, url: &#x27;请求的URL地址&#x27;, data: &#123; /* POST数据 */ &#125;, params: &#123; /* GET参数 */ &#125;&#125;).then(callback) 发起get请求 1234567891011document.querySelector(&#x27;#btn3&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; var url = &#x27;http://www.liulongbin.top:3006/api/get&#x27; var paramsData = &#123; name: &#x27;钢铁侠&#x27;, age: 35 &#125; axios(&#123; method: &#x27;GET&#x27;, url: url, params: paramsData &#125;).then(function (res) &#123; console.log(res.data) &#125;)&#125;) 发起post请求 12345678910111213document.querySelector(&#x27;#btn4&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; axios(&#123; method: &#x27;POST&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/post&#x27;, data: &#123; name: &#x27;娃哈哈&#x27;, age: 18, gender: &#x27;女&#x27; &#125; &#125;).then(function (res) &#123; console.log(res.data) &#125;)&#125;) 9-同源策略9.1同源策略（英文全称 Same origin policy）是浏览器提供的一个安全功能 MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这 是一个用于隔离潜在恶意文件的重要安全机制 通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互，例如： ① 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB ② 无法接触非同源网页的 DOM ③ 无法向非同源地址发送 Ajax 请求 9.2跨域同源指的是两个 URL 的协议、域名、端口一致，反之，则是跨域 出现跨域的根本原因：浏览器的同源策略不允许非同源的 URL 之间进行资源的交互 注意：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！ 9.3如何实现跨域数据请求现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。 JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。 CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器 9.4JSONPJSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。 9.4.1JSONP的实现原理由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 &lt;script&gt; 标签不受浏览器同 源策略的影响，可以通过 src 属性，请求非同源的 js 脚本。 因此，JSONP 的实现原理，就是通过 &lt;script&gt; 标签的 src 属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据 9.4.2自己实现一个简单的JSONP定义一个success回调函数： 123456&lt;script&gt; function success(data) &#123; console.log(&#x27;获取到了data数据：&#x27;) console.log(data) &#125;&lt;/script&gt; 通过 &lt;script&gt; 标签，请求接口数据： 12&lt;script src=&quot;http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&amp;name=zs&amp;age=20&quot;&gt;&lt;/script&gt; 9.4.3JSONP的缺点由于 JSONP 是通过 &lt;script&gt; 标签的 src 属性，来实现跨域数据获取的，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。 注意： JSONP 和 Ajax 之间没有任何关系，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象 9.4.4jQuery中的JSONPjQuery 提供的 $.ajax() 函数，除了可以发起真正的 Ajax 数据请求之外，还能够发起 JSONP 数据请求，例如： 12345678$.ajax(&#123; url: &#x27;http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20&#x27;, // 如果要使用 $.ajax() 发起 JSONP 请求，必须指定 datatype 为 jsonp dataType: &#x27;jsonp&#x27;, success: function(res) &#123; console.log(res) &#125;&#125;) 默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback=jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称 9.4.5自定义参数及回调函数名称在使用 jQuery 发起 JSONP 请求时，如果想要自定义 JSONP 的参数以及回调函数名称，可以通过如下两个参数来指定： 1234567891011$.ajax(&#123; url: &#x27;http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20&#x27;, dataType: &#x27;jsonp&#x27;, // 发送到服务端的参数名称，默认值为 callback jsonp: &#x27;callback&#x27;, // 自定义的回调函数名称，默认值为 jQueryxxx 格式 jsonpCallback: &#x27;abc&#x27;, success: function(res) &#123; console.log(res) &#125;&#125;) 9.4.6jQuery中JSONP的实现过程jQuery 中的 JSONP，也是通过 &lt;script&gt; 标签的 src 属性实现跨域数据访问的，只不过，jQuery 采用的是动态创建和移除标签的方式，来发起 JSONP 数据请求。 在发起 JSONP 请求的时候，动态向 &lt;header&gt; 中 append 一个 &lt;script&gt; 标签； 在 JSONP 请求成功以后，动态从 &lt;header&gt; 中移除刚才 append 进去的 &lt;script&gt; 标签； 案例-淘宝搜索框 获取用户输入的搜索关键词 为了获取到用户每次按下键盘输入的内容，需要监听输入框的 keyup 事件，示例代码如下： 12345678910// 监听文本框的 keyup 事件$(&#x27;#ipt&#x27;).on(&#x27;keyup&#x27;, function() &#123; // 获取用户输入的内容 var keywords = $(this).val().trim() // 判断用户输入的内容是否为空 if (keywords.length &lt;= 0) &#123; return &#125; // TODO：获取搜索建议列表&#125;) 封装getSuggestList函数 将获取搜索建议列表的代码，封装到 getSuggestList 函数中，示例代码如下： 12345678910function getSuggestList(kw) &#123; $.ajax(&#123; // 指定请求的 URL 地址，其中，q 是用户输入的关键字 url: &#x27;https://suggest.taobao.com/sug?q=&#x27; + kw, // 指定要发起的是 JSONP 请求 dataType: &#x27;jsonp&#x27;, // 成功的回调函数 success: function(res) &#123; console.log(res) &#125; &#125;) &#125; 渲染建议列表的UI结构 定义搜索建议列表 12345678&lt;div class=&quot;box&quot;&gt; &lt;!-- tab 栏区域 --&gt; &lt;div class=&quot;tabs&quot;&gt;&lt;/div&gt; &lt;!-- 搜索区域 --&gt; &lt;div class=&quot;search-box&quot;&gt;&lt;/div&gt; &lt;!-- 搜索建议列表 --&gt; &lt;div id=&quot;suggest-list&quot;&gt;&lt;/div&gt;&lt;/div&gt; 定义模板结构 创建script标签 设置type属性为 text/html 设置模板id 利用 each 遍历结构 123456&lt;!-- 模板结构 --&gt;&lt;script type=&quot;text/html&quot; id=&quot;tpl-suggestList&quot;&gt; &#123;&#123;each result&#125;&#125; &lt;div class=&quot;suggest-item&quot;&gt;&#123;&#123;$value[0]&#125;&#125;&lt;/div&gt; &#123;&#123;/each&#125;&#125;&lt;/script&gt; 定义渲染模板结构的函数 定义函数，接收一个参数，就是服务器返回的数据 判断返回的数据长度是否大于0 如果没有，将页面的列表清空，并且进行隐藏 如果有数据，调用模板的 template 函数，传入id和数据 返回渲染好的html字符串，然后放入容器中 12345678910 // 渲染建议列表function renderSuggestList(res) &#123; // 如果没有需要渲染的数据，则直接 return if (res.result.length &lt;= 0) &#123; return $(&#x27;#suggest-list&#x27;).empty().hide() &#125; // 渲染模板结构 var htmlStr = template(&#x27;tpl-suggestList&#x27;, res) $(&#x27;#suggest-list&#x27;).html(htmlStr).show()&#125; 搜索关键词为空时隐藏搜索建议列表 注册keyup事件 判断输入框的内容是否为空 如果为空隐藏列表 12345678910$(&#x27;#ipt&#x27;).on(&#x27;keyup&#x27;, function() &#123; // 获取用户输入的内容 var keywords = $(this).val().trim() // 判断用户输入的内容是否为空 if (keywords.length &lt;= 0) &#123; // 如果关键词为空，则清空后隐藏搜索建议列表 return $(&#x27;#suggest-list&#x27;).empty().hide() &#125; getSuggestList(keywords)&#125;) 10-防抖&amp;节流10.1什么是防抖防抖策略（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。 好处：能够保证用户在频繁触发某些事件的时候，不会频繁的执行回调，只会被执行一次 防抖的应用场景用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减 少请求次数，节约请求资源； 实现输入框的防抖 防抖动的 timer 定义防抖的函数，函数里面定义一个延时器，在演示器里面调用发起JSONP的请求 在触发 keyup 事件时，立即清空 timer，然后调用防抖的函数 123456789101112var timer = null // 1. 防抖动的 timerfunction debounceSearch(keywords) &#123; // 2. 定义防抖的函数 timer = setTimeout(function() &#123; // 发起 JSONP 请求 getSuggestList(keywords) &#125;, 500) &#125;$(&#x27;#ipt&#x27;).on(&#x27;keyup&#x27;, function() &#123; // 3. 在触发 keyup 事件时，立即清空 timer clearTimeout(timer) // ...省略其他代码 debounceSearch(keywords) &#125;) 缓存搜索的建议列表 定义全局缓存对象 12// 缓存对象var cacheObj = &#123;&#125; 将搜索结果保存到缓存对象中 键就是用户输入的关键字，值就是服务器返回的value 1234567// 渲染建议列表function renderSuggestList(res) &#123; // ...省略其他代码 // 将搜索的结果，添加到缓存对象中 var k = $(&#x27;#ipt&#x27;).val().trim() cacheObj[k] = res&#125; 优先从缓存中获取搜索建议 在发起请求之前，先判断缓存中是否有数据 12345678910// 监听文本框的 keyup 事件$(&#x27;#ipt&#x27;).on(&#x27;keyup&#x27;, function() &#123; // ...省略其他代码 // 优先从缓存中获取搜索建议 if (cacheObj[keywords]) &#123; return renderSuggestList(cacheObj[keywords]) &#125; // 获取搜索建议列表 debounceSearch(keywords) &#125;) 10.2节流10.2.1什么是节流节流策略（throttle），顾名思义，可以减少一段时间内事件的触发频率。 10.2.2节流的应用场景① 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次； ② 懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源； 10.2.3节流案例 – 鼠标跟随效果UI效果渲染UI结构并美化样式123456789&lt;!-- UI 结构 --&gt;&lt;img src=&quot;./assets/angel.gif&quot; alt=&quot;&quot; id=&quot;angel&quot; /&gt;/* CSS 样式 */html, body &#123; margin: 0; padding: 0; overflow: hidden; &#125;#angel &#123; position: absolute; &#125; 不使用节流时实现鼠标跟随效果 获取图片元素 注册 mousemove事件 设置图片的位置 123456789$(function() &#123; // 获取图片元素 var angel = $(&#x27;#angel&#x27;) // 监听文档的 mousemove 事件 $(document).on(&#x27;mousemove&#x27;, function(e) &#123; // 设置图片的位置 $(angel).css(&#x27;left&#x27;, e.pageX + &#x27;px&#x27;).css(&#x27;top&#x27;, e.pageY + &#x27;px&#x27;) &#125;)&#125;) 10.3节流阀的概念高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。 假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。 上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生间。 下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫生间。 节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。 当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了。 每次执行操作前，必须先判断节流阀是否为空。 10.3.1使用节流优化鼠标跟随效果 预定义一个 timer 节流阀 当设置了鼠标跟随效果后，清空 timer 节流阀，方便下次开启延时器 执行事件的时候判断节流阀是否为空，如果不为空，则证明距离上次执行间隔不足16毫秒 1234567891011$(function() &#123; var angel = $(&#x27;#angel&#x27;) var timer = null // 1.预定义一个 timer 节流阀 $(document).on(&#x27;mousemove&#x27;, function(e) &#123; if (timer) &#123; return &#125; // 3.判断节流阀是否为空，如果不为空，则证明距离上次执行间隔不足16毫秒 timer = setTimeout(function() &#123; $(angel).css(&#x27;left&#x27;, e.pageX + &#x27;px&#x27;).css(&#x27;top&#x27;, e.pageY + &#x27;px&#x27;) timer = null // 2.当设置了鼠标跟随效果后，清空 timer 节流阀，方便下次开启延时器 &#125;, 16) &#125;)&#125;) 10.4总结防抖和节流的区别 防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面 N 多次的触发都会被忽略！ 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"}]},{"title":"初识(三)","slug":"初识-三","date":"2022-11-06T03:43:13.000Z","updated":"2022-11-06T03:54:56.310Z","comments":true,"path":"2022/11/06/初识-三/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E4%B8%89/","excerpt":"","text":"web APIsweb APIs 作用：就是使用 js 去操作 html 和 浏览器 分类： DOM （文档对象模型 操作网页内容，可以开发网页内容特效和实现用户交互）， ​ BOM（浏览器对象模型） DOM对象： document （它提供的属性和方法都是用来访问和操作网页内容的) 获取DOM对象根据CSS选择器来获取DOM元素： ​ 一： 选择匹配的第一个元素 ———能直接操作修改 语法： document.querySelector（’css选择器’）—-必须是字符串 而且必须加反引号 1const div = document.querySelector(&#x27;div&#x27;) 参数：包含一个或多个有效的 css选择器 字符串 返回值：css选择器匹配的 第一个元素，一个HTMLElement对象。如果没有匹配到，则返回null。 二： 选择匹配的多个元素———–**只能通过遍历的方式一次给里面的元素做修改 ** 语法： document.querySelectorAll（’css选择器’） 1const lis = document.querySelectorAll(&#x27;.nav li&#x27;) 返回值：css选择器匹配的 NodeList 对象集合 例如：document.querySelectorAll（’ul li’） 获取到的将是是一个伪数组 伪元素：1.有长度有索引号的数组，但是没有pop（） push（）等数组方法 ​ 2.想要得到里面的每一个对象，则需要遍历（for）的方式获得。 注意事项： 哪怕只有一个元素，通过querySelectorAll（）获取过来的也是一个 伪数组，里面只有一个元素而已 其他三个获取DOM元素的方法（了解） 1.根据id获取一个元素：document.getElementById(‘nav’) 2.根据标签获取一类（所有的）元素：document.getElementsByTagName(‘div’) 3.根据类名获取元素：document.getElementByClassName(‘w’) ​ 操作元素内容 一.元素innerText属性 1.将文本内容添加&#x2F;更新到任意标签位置 2.显示纯文本，不解析标签 二.元素 .innerHTML属性 （推荐使用） 1.将文本内容添加&#x2F;更新到任意标签位置 2.会解析标签，能识别文本，多标签建议使用模板字符串 12345678910// 1. 获取元素 const box = document.querySelector(&#x27;.box&#x27;) // 2. 修改文字内容 对象.innerText 属性 console.log(box.innerText) // 获取文字内容 box.innerText = &#x27;我是一个盒子&#x27; // 修改文字内容 box.innerText = &#x27;&lt;strong&gt;我是一个盒子&lt;/strong&gt;&#x27; // 不解析标签 // 3. innerHTML 解析标签 console.log(box.innerHTML) box.innerHTML = &#x27;我要更换&#x27; box.innerHTML = &#x27;&lt;strong&gt;我要加粗的&lt;/strong&gt;&#x27; ​ 操作元素属性 一. 操作元素 常用 属性 语法：对象.属性 &#x3D; 值 常见的属性比如：href title src 等 12345678910&lt;body&gt; &lt;img src=&quot;./images/1.webp&quot; alt=&quot;&quot;&gt; &lt;script&gt; // 1. 获取图片元素 const img = document.querySelector(&#x27;img&#x27;) // 2. 修改图片对象的属性 对象.属性 = 值 img.src = &#x27;./images/2.webp&#x27; img.title = &#x27;pink老师的艺术照&#x27; &lt;/script&gt;&lt;/body&gt; 二.操作元素的 样式 属性 1.通过 style 属性操作css 语法：对象.style.样式属性 &#x3D; 值 12345678910111213&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 1. 获取元素 const box = document.querySelector(&#x27;.box&#x27;) //2. 修改样式属性 对象.style.样式属性 = &#x27;值&#x27; 别忘了跟单位 box.style.width = &#x27;300px&#x27; // 多组单词的采取 小驼峰命名法 box.style.backgroundColor = &#x27;hotpink&#x27; box.style.border = &#x27;2px solid blue&#x27; box.style.borderTop = &#x27;2px solid red&#x27; &lt;/script&gt;&lt;/body&gt; 2.操作 类名（className）操作css *语法： 元素.className &#x3D; ‘active’（active是一个css类名） 123456789&lt;body&gt; &lt;div class=&quot;nav&quot;&gt;123&lt;/div&gt; &lt;script&gt; // 1. 获取元素 const div = document.querySelector(&#x27;div&#x27;) // 2.添加类名 class 是个关键字 我们用 className div.className = &#x27;nav box&#x27; &lt;/script&gt;&lt;/body&gt; 3.通过 classList 操作控制css 3.1 追加一个类： 元素.classList.add(‘类名’) 3.2 删除一个类： 元素.classList.remove(‘类名’) 3.3 切换一个类： 元素.classList.toggle(‘类名’) 123456789101112131415&lt;body&gt; &lt;div class=&quot;box active&quot;&gt;文字&lt;/div&gt; &lt;script&gt; // 通过classList添加 // 1. 获取元素 const box = document.querySelector(&#x27;.box&#x27;) // 2. 修改样式 // 2.1 追加类 add() 类名不加点，并且是字符串 box.classList.add(&#x27;active&#x27;) // 2.2 删除类 remove() 类名不加点，并且是字符串 box.classList.remove(&#x27;box&#x27;) // 2.3 切换类 toggle() 有还是没有啊， 有就删掉，没有就加上 box.classList.toggle(&#x27;active&#x27;) &lt;/script&gt;&lt;/body&gt; 三.操作 表单元素 属性 获取：DOM对象.属性名 比如：表单.value &#x3D; ‘用户名’ 设置：DOM对象.属性名 &#x3D; 新值 表单.type &#x3D; ‘password’ 1234567891011121314151617181920212223242526&lt;body&gt; &lt;!-- &lt;input type=&quot;text&quot; value=&quot;电脑&quot;&gt; --&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; // 1 获取元素 const uname = document.querySelector(&#x27;input&#x27;) // 2. 获取值 获取表单里面的值 用的 表单.value console.log(uname.value) // 电脑 console.log(uname.innerHTML) innertHTML 得不到表单的内容 // 3. 设置表单的值 uname.value = &#x27;我要买电脑&#x27; console.log(uname.type) uname.type = &#x27;password&#x27; // 1. 获取 const ipt = document.querySelector(&#x27;input&#x27;) console.log(ipt.checked) // false 只接受布尔值 ipt.checked = true // ipt.checked = &#x27;true&#x27; // 会选中，不提倡 有隐式转换 // 1.获取 const button = document.querySelector(&#x27;button&#x27;) // console.log(button.disabled) // 默认false 不禁用 button.disabled = true // 禁用按钮 &lt;/script&gt;&lt;/body&gt; 四.自定义属性 标准属性：标签天生自带的属性 比如class id title等，可以直接使用点语法操作 比如：disabled，checked，seleced 自定义属性：从html5中推出来了专门的**data-**自定义属性 1.在标签上一律以 **data- ** 开头 2.在DOM对象上一律以 dataset 对象方式获取 123456789101112&lt;body&gt; &lt;div data-id=&quot;1&quot; data-spm=&quot;不知道&quot;&gt;1&lt;/div&gt; &lt;div data-id=&quot;2&quot;&gt;2&lt;/div&gt; &lt;div data-id=&quot;3&quot;&gt;3&lt;/div&gt; &lt;div data-id=&quot;4&quot;&gt;4&lt;/div&gt; &lt;div data-id=&quot;5&quot;&gt;5&lt;/div&gt; &lt;script&gt; const one = document.querySelector(&#x27;div&#x27;) console.log(one.dataset.id) // 1 console.log(one.dataset.spm) // 不知道 &lt;/script&gt;&lt;/body&gt; 定时器-间歇函数**定时器-间歇函数 ** 目标：重复执行代码 1.开启定时器 语法：setInterval（函数，间隔时间） ​ 作用：每间隔一段时间调用这个函数 &#x2F; 间隔的单位是毫秒 注意！！ 调用函数不需要加括号 &#x2F; 定时器返回的是一个id数字 **2.关闭定时器 语法：let 变量名 &#x3D; setInterval(函数，间隔时间) ** ​ clearInterval（变量名） &#x2F;&#x2F; 一般不会刚创建就停止 二是满足一定条件再停止 123456789function fn() &#123; console.log(&#x27;一秒执行一次&#x27;) &#125; // setInterval(函数名, 间隔时间) 函数名不要加小括号 let n = setInterval(fn, 1000) // setInterval(&#x27;fn()&#x27;, 1000) console.log(n) // 关闭定时器 clearInterval(n) ***练习：用户倒计时协议案例 自动播放轮播图案例 *** 1234567891011121314151617181920212223&lt;body&gt;&lt;div class=&quot;slider&quot;&gt; &lt;div class=&quot;slider-wrapper&quot;&gt; &lt;img src=&quot;./images/slider01.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;slider-footer&quot;&gt; &lt;p&gt;对人类来说会不会太超前了？&lt;/p&gt; &lt;ul class=&quot;slider-indicator&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;toggle&quot;&gt; &lt;button class=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt; &lt;button class=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839 &lt;script&gt; // 1. 初始数据 const sliderData = [ &#123; url: &#x27;./images/slider01.jpg&#x27;, title: &#x27;对人类来说会不会太超前了？&#x27;, color: &#x27;rgb(100, 67, 68)&#x27; &#125;, &#123; url: &#x27;./images/slider02.jpg&#x27;, title: &#x27;开启剑与雪的黑暗传说！&#x27;, color: &#x27;rgb(43, 35, 26)&#x27; &#125;, &#123; url: &#x27;./images/slider03.jpg&#x27;, title: &#x27;真正的jo厨出现了！&#x27;, color: &#x27;rgb(36, 31, 33)&#x27; &#125;, &#123; url: &#x27;./images/slider04.jpg&#x27;, title: &#x27;李玉刚：让世界通过B站看到东方大国文化&#x27;, color: &#x27;rgb(139, 98, 66)&#x27; &#125;, &#123; url: &#x27;./images/slider05.jpg&#x27;, title: &#x27;快来分享你的寒假日常吧~&#x27;, color: &#x27;rgb(67, 90, 92)&#x27; &#125;, &#123; url: &#x27;./images/slider06.jpg&#x27;, title: &#x27;哔哩哔哩小年YEAH&#x27;, color: &#x27;rgb(166, 131, 143)&#x27; &#125;, &#123; url: &#x27;./images/slider07.jpg&#x27;, title: &#x27;一站式解决你的电脑配置问题！！！&#x27;, color: &#x27;rgb(53, 29, 25)&#x27; &#125;, &#123; url: &#x27;./images/slider08.jpg&#x27;, title: &#x27;谁不想和小猫咪贴贴呢！&#x27;, color: &#x27;rgb(99, 72, 114)&#x27; &#125;, ] // 1.获取元素 const img = document.querySelector(&#x27;.slider-wrapper img&#x27;) const p = document.querySelector(&#x27;.slider-footer p&#x27;) let i = 0 //控制图片的张量 // 开启定时器从第二张开始 // console.log(sliderData[i]) //拿到对应的对象 setInterval(function () &#123; i++ // 无缝衔接 if (i &gt;= sliderData.length) &#123; i = 0 &#125; console.log(i) // console.log(sliderData[i]) // 跟换图片路径 img.src = sliderData[i].url //把文字写到P里面去 p.innerHTML = sliderData[i].title // 小圆点 // 先删除一起的active // 选中小圆点,删除它 document.querySelector(&#x27;.slider-indicator .active&#x27;).classList.remove(&#x27;active&#x27;) // 只让当前的li添加active document.querySelector(`.slider-indicator li:nth-child($&#123;i + 1&#125;)`).classList.add(&#x27;active&#x27;) &#125;, 1000) &lt;/script&gt;&lt;/body&gt; 掌握：事件绑定处理和事件对象，完成常见网页交互 01-事件监听（绑定）语法：元素对象.addEventListener(‘事件类型’，要执行的函数)简答：1.什么是事件 事件是在编程时系统内发生的 动作或者发生的事情 比如用户在网页上单击一个按钮 ​ 2.什么是事件监听 让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 绑定事件或者注册事件 比如：鼠标经过显示下拉菜单， 点击可以播放轮播图等 ！！！ 事件监听三要素： 事件源： 哪个DOM元素被事件触发了，要获取DOM元素 事件类型： 用什么方式触发，比如鼠标单击click，鼠标经过mouseenter等 ​ **注意！！ 事件类型要加引号 函数是点击之后再去执行，每次点击都会执行一次 ** 事件调用的函数： 要做什么事 12345678910111213&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; // 需求： 点击了按钮，弹出一个对话框 // 1. 事件源 按钮 // 2.事件类型 点击鼠标 click 字符串 // 3. 事件处理程序 弹出对话框 const btn = document.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; alert(&#x27;你早呀~&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt; （了解）发展史： DOM L0 ：是 DOM 的发展的第一个版本； L：level DOM L1：DOM级别1 于1998年10月1日成为W3C推荐标准 DOM L2：使用addEventListener注册事件 DOM L3： DOM3级事件模块在DOM2级事件的基础上重新定义了这些事件，也添加了一些新事件类型 02-事件类型鼠标事件（鼠标触发）： click 鼠标点击 mouseenter 鼠标经过 mouseleave 鼠标离开 焦点事件（表单获得光标）: focus 获得焦点 blur 失去焦点 键盘事件（键盘触发）： keydown 键盘按下触发 keyup 键盘抬起触发 文本事件（表单输入触发）： input 用户输入事件 1234567891011121314&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; const div = document.querySelector(&#x27;div&#x27;) // 鼠标经过 div.addEventListener(&#x27;mouseenter&#x27;, function () &#123; console.log(`轻轻的我来了`) &#125;) // 鼠标离开 div.addEventListener(&#x27;mouseleave&#x27;, function () &#123; console.log(`轻轻的我走了`) &#125;) &lt;/script&gt;&lt;/body&gt; 03-事件对象获取事件对象： 语法 元素.addEventListener(‘click’,function(e){}) e:就是事件对象，在事件绑定的回调函数的第一个参数就是事件对象 一般命名为event，e。。。 常见事件对象属性： 1.type 获取当前的事件类型 ​ 2.clientX&#x2F;clientY 获取光标相对于浏览器可见窗口左上角的位置 ​ 3.offsetX &#x2F; offsetY 获取光标相对于当前DOM元素左上角的位置 ​ 4.key 用户按下的键盘的值 （现在不提倡使用keyCode） 1234567891011&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; const input = document.querySelector(&#x27;input&#x27;) input.addEventListener(&#x27;keyup&#x27;, function (e) &#123; if (e.key === &#x27;Enter&#x27;) &#123; console.log(&#x27;我按下了回车键&#x27;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 04-环境对象：指的是函数内部特殊的变量this， 它代表着当前函数运行时所处的环境 【谁调用，this就是谁】 12345678910111213141516&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; // 每个函数里面都有this 环境对象 普通函数里面this指向的是window // function fn() &#123; // console.log(this) // &#125; // window.fn() const btn = document.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // console.log(this) // btn 对象 // btn.style.color = &#x27;red&#x27; this.style.color = &#x27;red&#x27; &#125;) &lt;/script&gt;&lt;/body&gt; 05-回调函数简单理解：当一个函数当作参数传递给另外一个函数的时候，这个函数就是回调函数 回调函数的本质还是函数，只不过是把她当作参数使用 123456789101112131415161718192021&lt;script&gt; // 1.给5个链接绑定鼠标经过事件 // 1.1 获取a元素 const as = document.querySelectorAll(&#x27;.tab-nav a&#x27;) // console.log(as) for (let i = 0; i &lt; as.length; i++) &#123; // console.log(as[i]) as[i].addEventListener(&#x27;mouseenter&#x27;,function()&#123; // console.log(&#x27;鼠标经过&#x27;) // 排他思想 移除类 添加类 document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) // 添加类 this 当前的a this.classList.add(&#x27;active&#x27;) // 下面五个大盒子 .item // 移除类 document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) // 对应序号item 显示 添加acitve类 document.querySelector(`.tab-content .item:nth-child($&#123;i + 1&#125;)`).classList.add(&#x27;active&#x27;) &#125;) &#125; &lt;/script&gt; 01-事件流事件流指的是事件完整执行过程中的流动路径 会经历两个阶段 分别是捕获阶段和冒泡阶段捕获阶段是从父到子 冒泡阶段是从子到父 实际工作都是使用事件冒泡为主 02-事件捕获 DOM.addEventListener(事件类型，事件处理函数，是否使用捕获机制) 第三个参数传入true代表的是捕获阶段触发 若传入false代表冒泡阶段触发，默认是false 若是用L0事件监听 则只有冒泡阶段 没有捕获 03-事件冒泡 概念：当一个元素触发事件后，会依次向上调用所有的父级元素的同名事件 事件冒泡是默认存在的 L2事件监听第三个参数是false，或者默认都是冒泡 04-阻止冒泡 前提： 阻止事件冒泡需要拿到事件对象 语法： 事件对象.stopPropagation() 此方法可以阻断事流动传播，不光是在冒泡阶段有效，捕获阶段也有效 需要阻止默认行为的发生有：阻止链接的跳转，表单域跳转 语法： e.preventDefault() 05-解绑事件 on事件方式，直接使用null覆盖就可以实现事件的解绑 addEventListener方式，必须使用： removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段]) 注意：匿名函数无法被解绑 鼠标经过事件的区别： mouseover 和 mouseout 会有冒泡效果 mouseenter 和 mouseleave 没有冒泡效果（推荐） 两种注册事件的区别： （L0）传统on注册： 1.同一个对象，后面注册的事件会覆盖前面注册（同一个事件） 2.直接使用null覆盖就可以实现事件解绑 3.都是冒泡阶段执行的 （L2）事件监听注册 1.语法：addEventListener（事件类型，事件处理函数，是否使用捕获） 2.后面注册的事件不会覆盖前面注册的事件（同一个事件） 3.可以通过第三个参数去确定是在冒泡或者捕获阶段执行 4.必须使用removeEventListener(事件类型，事件处理函数，获取捕获或者冒泡阶段) 5.匿名函数无法解绑 事件委托优点：减少注册次数，可以提高程序的性能 原理：事件委托其实就是利用事件冒泡的特点，给父元素注册事件 ，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件 实现：事件对象.target.tagName可以获得真正触发事件的元素 1234567891011121314151617181920212223242526&lt;body&gt; &lt;ul&gt; &lt;li&gt;第1个孩子&lt;/li&gt; &lt;li&gt;第2个孩子&lt;/li&gt; &lt;li&gt;第3个孩子&lt;/li&gt; &lt;li&gt;第4个孩子&lt;/li&gt; &lt;li&gt;第5个孩子&lt;/li&gt; &lt;p&gt;我不需要变色&lt;/p&gt; &lt;/ul&gt; &lt;script&gt; // 点击每个小li 当前li 文字变为红色 // 按照事件委托的方式 委托给父级，事件写到父级身上 // 1. 获得父元素 const ul = document.querySelector(&#x27;ul&#x27;) ul.addEventListener(&#x27;click&#x27;, function (e) &#123; // alert(11) // this.style.color = &#x27;red&#x27; // console.dir(e.target) // 就是我们点击的那个对象 // e.target.style.color = &#x27;red&#x27; // 我的需求，我们只要点击li才会有效果 if (e.target.tagName === &#x27;LI&#x27;) &#123; e.target.style.color = &#x27;red&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 其他事件—页面加载事件 load事件：监听整个页面资源给windo加 DoMContentLoaded:给document加，无需等待样式表，图像等完全加载 页面滚动事件(scroll): 1-获取位置： scrollLeft和scrollTop(属性)： 获取被卷去的大小 获取元素内容往左，往上滚出去看不到的距离 这两个值是可读写的 尽量在scroll事件里面获取被卷去的距离 注意！document.documentElement HTML文档返回对象为HTML元素 2-滚动到指定的坐标： 语法：元素.scrollTo（x，y） 页面尺寸事件（resize）： 会在窗口尺寸改变的时候触发事件 1-获取元素宽高： 获取元素的可见部分宽高（不包含边框，margin，滚动条等） clientWidth和clientHeight 2-元素尺寸与位置-尺寸 offseftLeft和offsetTop 是已读属性 element.getBoundingClientRect方法返回元素的大小及其相对于视口的位置 总结： 1.scrollLeft和scrollTop 被卷去的头部和左侧，配合页面滚动来用，可读 2.clientWidth和clientHeight 获得元素宽度和高度，不包含border，margin，滚动条，用于js获取元素大小，只读属性 3.offsetWidth和offsetHeight 获取元素的宽度和高度，包含border，padding，滚动条等，只读元素 4.offseLeft和offsetTop 获取元素距离自己定位父级元素的左，上距离 获取元素位置的时候使用，只读属性 练习：电梯导航模块，全选反选 01-日期对象用来表示时间的对象，可以得到当前系统时间 1.1实例化： 在代码中发现了new关键字时，一般将这个操作称为实例化 获取当前时间：const date &#x3D; new Date（） 1.2日期对象方法 getFullYear() 获得年份 获取四位年份 getMonth() 获得月份 取值为 0 ~ 11 getDate() 获取月份中的每一天 不同月份取值也不相同 getDay() 获取星期 取值为 0 ~ 6 getHours() 获取小时 取值为 0 ~ 23 getMinutes() 获取分钟 取值为 0 ~ 59 getSeconds() 获取秒 取值为 0 ~ 59 1.3时间戳 （毫秒） （使用场景为计算倒计时的效果） 算法： 将来的时间戳 - 现在的时间戳 &#x3D; 剩余时间毫秒数 ​ 剩余时间毫秒数 转换为剩余时间的 年月日时分秒 就是倒计时时间 公式：转换公式：  d &#x3D; parseInt(总秒数&#x2F; 60&#x2F;60 &#x2F;24); &#x2F;&#x2F; 计算天数  h &#x3D; parseInt(总秒数&#x2F; 60&#x2F;60 %24) &#x2F;&#x2F; 计算小时  m &#x3D; parseInt(总秒数 &#x2F;60 %60 ); &#x2F;&#x2F; 计算分数  s &#x3D; parseInt(总秒数%60); &#x2F;&#x2F; 计算当前秒数 三种方式获取时间戳： 1.使用getTime()方法 2.简写 +new Date（） （一般推荐使用这种） 3.使用Date.now() – 无实例化，只能得到当前的时间戳，而前面两种可以返回指定时间的时间戳 02-节点操作2.1-DOM节点（DOM数里面每一个内容都称之为节点）： 元素节点： 所有的标签 比如body，div html是根节点 属性节点：所有的属性 比如href 文本节点：所有的文本 2.2-查找节点 父节点查找： 子元素.parentNode（返回最近一级的父节点 找不到返回为null） 子节点查找： 父元素.children （仅获得所有元素节点&#x2F;返回的还是一个伪数组） childNodes：获得所有子阶段，包括文本节点（空格，换行），注释节点等 兄弟关系查找： 1.下一个兄弟节点 nextElementSibling ​ 2.上一个兄弟节点 previousElementSibling 2.3-增加节点 步骤：创建一个新的节点 &#x3D;&#x3D;&#x3D;》把创建的新的节点放入到指定的元素内部 创建元素节点的方法： document.createElement(‘标签名’) 追加节点： 插入到父元素的最后一个元素： 父元素.appendChild（要插入的元素） 插入到某个子元素的前面 父元素.insertBefore(要插入的元素，在哪个元素前面) 克隆节点： 克隆一个已有的元素节点：元素.cloneNode(布尔值) *若为true，则代表克隆时会包含后代节点一起克隆 *若为false，则代表克隆时不包含后代节点 *默认为false 2.4-删除节点 （要删除元素必须通过父元素删除） 语法： 父元素.removeChild(要删除的元素) *如不存在父子关系则删除不成功 *删除节点和隐藏节点（display：none）有区别的：隐藏节点还是存在的，但是删除，则从html中删除节点 03-M端事件（移动端）触屏事件touch（也称触摸事件） Android和IOS都有 touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（触摸笔）对屏幕或触控板操作。 常见的触屏touch事件： touchstart 手指触摸到一个DOM元素是触发 touchmove 手指在一个DOM元素上滑动是触发 touchend 手指从一个DOM元素上移开时触发 04-插件 插件: 就是别人写好的一些代码,我们只需要复制对应的代码,就可以直接实现对应的效果  学习插件的基本过程  熟悉官网,了解这个插件可以完成什么需求 https://www.swiper.com.cn/  看在线演示,找到符合自己需求的demo https://www.swiper.com.cn/demo/index.html  查看基本使用流程 https://www.swiper.com.cn/usage/index.html  查看APi文档,去配置自己的插件 https://www.swiper.com.cn/api/index.html  注意: 多个swiper同时使用的时候, 类名需要注意区分 重绘和回流回流：当 Render Tree 中部分或者全部元素的尺寸、结构、布局等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为 回流。 重绘：由于节点(元素)的样式的改变并不影响它在文档流中的位置和文档布局时(比如：color、background-color、outline等), 称为重绘。 重绘不一定引起回流，而回流一定会引起重绘 会导致回流（重排）的操作： *页面的首次刷新 *浏览器的窗口大小发生改变 *元素的大小或位置发生改变 *改变字体的字样 *内容的变化（如：input框的输入，图片的大小） *激活css伪类（如：:hover） *脚本操作DOM（添加或者删除可见的DOM 元素） 简单来说 影响到布局了 就会有回流 练习： 学成在线渲染案例 倒计时案例 微博发布案例 01-Window对象1.1定时器-延时函数 语法： setTimeout（回调函数，等待的毫秒数） setTimeout只执行一次 清除延时函数： let timer &#x3D; setTimeout（回调函数，等待的毫秒数） ​ clearTimeout（timer） 注意！延时器需要等待，所以后面的代码会先执行，每一次调用延时器都会产生一个新的延时器 **1.2 JS执行机制 ** 最大的特点就是单线程，同一时间只能做一件事 分为同步和异步： 同步任务： 都在主线程上执行，形成一个执行栈。 异步任务： 通过回调函数实现的。有以下三种类型 *1.普通事件，如click，resize等 *2.资源加载，如load，error等 *3.定时器，包括setInterval，setTimeout等 异步任务相关添加到任务队列中（任务队列也称为消息队列） 执行步骤： 1.先执行执行栈中的同步任务 ​ 2.异步任务放入任务队列中 ​ 3.一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 由于主线程不断的重复获得任务，执行任务，再获取任务，再执行，所以这种机制被称为事件循环（event loop） 1.3 location对象 location数据类型是对象，它拆分并保存了URL地址各个组成部分 常用的属性和方法： href属性获取完整的URL地址，对其赋值时用于地址的跳转 search属性获取地址中携带的参数，符号？后面的部分 hash属性获取地址中的哈希值，符号#后面部分 reload方法用来刷新当前页面，传入参数true时表示强制刷新 1.4 histroy对象 数据类型是对象，主要管理历史记录，该对象与浏览器地址栏的操作相对应，如前进，后退，历史记录等 常用属性和方法： back（） 可以后退的功能 forward（） 前进功能 go（参数） 前进后退功能 参数如果是1 前进1个页面 如果是-1 后退一个页面 02-本地存储2.1 本地存储分类- localStorage 作用：可以将数据永久存储在本地（用户的电脑），除非手动删除，否则关闭页面也会存在 特性： 可以多窗口（页面）共享（同一浏览器可以共享）&#x2F;以键值对的形式存储使用 语法： 1.存储数据： localStorage.setltem(key,value) ​ 2.获取数据：localStorage.getltem(key) ​ 3.删除数据：localStorage.removeltem(key) 12345678910111213// 存储 localStorage.setItem(&#x27;uname&#x27;, &#x27;熊大&#x27;) // 获取 const n = localStorage.getItem(&#x27;uname&#x27;) console.log(n) // 删除 // localStorage.removeItem(&#x27;uname&#x27;) // 改 如果原来有这个键则是改，没有就是新增 localStorage.setItem(&#x27;uname&#x27;, &#x27;熊二&#x27;) // 本地存储只能存储字符串数据类型 localStorage.setItem(&#x27;age&#x27;, 18) console.log(localStorage.getItem(&#x27;age&#x27;)) 2.2 本地存储分类- sessionStorage 特性：*生命周期为关闭浏览器窗口 ​ *在同一个窗口（页面）下数据可以共享 ​ *以键值对的形式存储使用 ​ *用法跟localStorage基本相同 2.3 存储复杂数据类型 本地只能存储字符串，无法存储复杂数据类型 解决： 需要将复杂数据类型转换成JSON字符串，再存储到本地 语法：JSON.stringify(复杂数据类型) 因为本地存储里面取出来的是字符串，不是对象，无法直接使用，所以要把取出来的字符串转换为对象 语法：JSON.parse(JSON字符串) 12345678const obj = &#123; uname: &#x27;熊大&#x27;, age: 18 &#125; //1. 复杂数据类型存储必须转换为JSON字符串 localStorage.setItem(&#x27;obj&#x27;, JSON.stringify(obj)) //2.把JSON字符串转换为对象 console.log(JSON.parse(localStorage.getItem(&#x27;obj&#x27;))) 数组中map方法 迭代数组 map可以处理数据，并且返回新的数组 也称为映射。 语法：const arr &#x3D; [‘pink’,’red’,’blue’] ​ arr.map(function(item,index){ ​ console.log(item) &#x2F;&#x2F; item 得到数组元素‘pink’ ‘red’ ‘blue’ ​ console.log(index) &#x2F;&#x2F; index 得到索引号 0 1 2 ​ }） map可以处理数据，并且返回新的数组 1234567891011&lt;script&gt; const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;] // map 方法也是遍历 处理数据 可以返回一个数组 const newArr = arr.map(function (item, i) &#123; // console.log(item) //数组元素 // console.log(i) //下标 // 把 item老师 放到新数组里(red老师) return item + &#x27;老师&#x27; &#125;) console.log(newArr) &lt;/script&gt; 数组中join方法 join（）方法用于把数组中的元素转换一个字符串 语法： const arr &#x3D; [‘pink老师’，’red老师’，’blue老师’] ​ console.log(arr.join(‘’)) &#x2F;&#x2F; pink老师 red老师 blue老师 数组元素是通过参数里面指定的额分隔符进行分隔的 join（‘’）里面加的是分隔符号 如果没有，元素就默认连接在一起 12345&lt;script&gt; const arr = [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;] // 把数组元素转换为字符串 console.log(arr.join(&#x27;-&#x27;)) &lt;/script&gt; 练习：必须独立写出学生信息表案例 01-正则表达式正则表达式是用于匹配字符串中字符组合的模式，在js中，正则表达式也是对象通常用来查找，替换那些符合正则表达式的文本。 使用场景： *例如表单验证，用户表单只能输入英文字母，数字或下划线（匹配） *过滤页面内容中的一些敏感词（替换），或从字符串中获取我们想要的特定部分等（提取） 定义正则表达式语法： const 变量名 &#x3D; &#x2F;表达式&#x2F; （&#x2F; &#x2F; 是正则表达式字面量） ​ 查找：const reg &#x3D; &#x2F; &#x2F; 1-判断是否有符合规则的字符串 test()方法 ()写被检测的字符串 返回的是布尔值 2-检索（查找）符合规则的字符串 exec()方法 在一个指定字符串中执行一个搜索匹配 （如果匹配成功，exec（）方法**返回一个数组，否则返回null**） 元字符： 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能 参考文档：  MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions  正则测试工具: http://tool.oschina.net/regex 边界符： （位置符）用来*提示字符所处的位置* ^ :表示匹配行首的文本（以谁开始） $ :表示匹配行尾的文本（以谁结束） 如果 ^ 和 $ 在一起，表示必须是精确匹配 量词： （表示重复次数）用来*设定某个模式出现的次数* *** ** 重复零次或更多次 + 重复一次或更多次 ？ 重复零次或一次 {n} 重复n次 {n，} 重复n次或更多次 {n，m} 重复n-m次 注意！ 逗号左右两侧千万不要出现空格 字符类： [ ]匹配字符集合 里面^取反符号 [^a-z] 匹配除了小写字母以外的字符 \u0001 [ ] 里面加上 - 连字符 表示一个范围 比如[a-z] 表示a-z 26 个英文字母都可以 [a-zA-Z]表示大小写都可以 [0-9]表示0-9的数字都可以 简写方式： \\d 匹配0-9之间的任一数字 相当于【0-9】 \\D 匹配0-9以外的字符 相当于【^0-9】 \\w 匹配任意的字母，数字，下划线，相当于【A-Za-z0-9-_】 \\W 除所有字母，数字和下划线以外的字符，相当于【^A-Za-z0-9-_】 \\s 匹配空格（包括换行符，制表符，空格符等），相等于【\\t\\r\\n\\v\\f】 \\S 匹配非空格的字符，相当于【^\\t\\r\\n\\v\\f】 修饰符： 语法：&#x2F;表达式&#x2F;修饰符 i 表示正则匹配时字母不区分大小写 **g ** 表示匹配所有满足正则表达式的结果 replace 替换 语法：字符串.replace(&#x2F;正则表达式&#x2F;,’替换的文本’) 12345678console.log(/^java$/.test(&#x27;java&#x27;)) console.log(/^java$/i.test(&#x27;JAVA&#x27;)) console.log(/^java$/i.test(&#x27;Java&#x27;)) const str = &#x27;java是一门编程语言，学完JAVA工作很高&#x27; // i 大小写 g 所有的 const re = str.replace(/java/ig,&#x27;前端&#x27;) console.log(re) webAPIs综合案例学生信息表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//学生信息表&lt;script&gt; // 参考数据 // const initData = [ // &#123; // stuId: 1001, // uname: &#x27;欧阳霸天&#x27;, // age: 19, // gender: &#x27;男&#x27;, // salary: &#x27;20000&#x27;, // city: &#x27;上海&#x27;, // &#125; // ] // 1.读取本地存储数据 student-data 本地存储的命名 const data = localStorage.getItem(&#x27;student-data&#x27;) // 2.如果有就返回对象，没有就声明一个空数组 const arr = data ? JSON.parse(data) : [] // const arr = [ // &#123; // stuId: 1001, // uname: &#x27;欧阳霸天&#x27;, // age: 19, // gender: &#x27;男&#x27;, // salary: &#x27;20000&#x27;, // city: &#x27;上海&#x27;, // &#125; // ] // console.log(arr) // 获取tbody const tbody = document.querySelector(&#x27;tbody&#x27;) // 3.渲染模块函数 function render() &#123; // 遍历数组arr 有几个对象就生成几个tr 然后追加给 tbody const trArr = arr.map(function (item, i) &#123; // console.log(item) console.log(item.uname) return ` &lt;tr&gt; &lt;td&gt;$&#123;item.stuId&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.uname&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.salary&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.city&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:&quot; data-id=$&#123;i&#125;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; ` &#125;) // console.log(trArr) // 追加给tbody // 因为trArr 是个数组 我们不需要数组 要tr字符串 用join tbody.innerHTML = trArr.join(&#x27;&#x27;) &#125; render() // 4.录入模块 const info = document.querySelector(&#x27;.info&#x27;) // 获取表单form 里面带有 name 属性的元素 const items = info.querySelectorAll(&#x27;[name]&#x27;) // console.log(items) info.addEventListener(&#x27;submit&#x27;, function (e) &#123; // 阻止提交 e.preventDefault() // 声明空的对象 const obj = &#123;&#125; // obj.stuId = arr.length + 1 obj.stuId = arr.length ? arr[arr.length - 1].stuId + 1 : 1 // 非空判断 for (let i = 0; i &lt; items.length; i++) &#123; // console.log(items) //数组里包含5个表单 // console.log(item[i]) //每个表单 对象 // console.log(item[i].name) const item = items[i] if (items[i].value === &#x27;&#x27;) &#123; return alert(&#x27;输入内容不能为空，请重新输入&#x27;) &#125; // console.log(item.name) // obj[item.name] === obj.name obj.age obj[item.name] = item.value &#125; // console.log(obj) // 追加给数组 arr.push(obj) // 把数组 arr 存储到本地存储里面 localStorage.setItem(&#x27;student-data&#x27;, JSON.stringify(arr)) // 渲染页面 render() // 重置表单 this.reset() &#125;) // 5.删除模块 tbody.addEventListener(&#x27;click&#x27;, function (e) &#123; if (e.target.tagName === &#x27;A&#x27;) &#123; // console.log(e.target.dataset.id) // 删除数组对应的数据 arr.splice(e.target.dataset.id, 1) // 写入本地存储 localStorage.setItem(&#x27;student-data&#x27;, JSON.stringify(arr)) // 重新渲染 render() &#125; &#125;) &lt;/script&gt; 放大镜1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 放大镜效果// 1.获取三个盒子// 1.1小盒子 图片切换效果const small = document.querySelector(&#x27;.small&#x27;)// 中盒子const middle = document.querySelector(&#x27;.middle&#x27;)// 大盒子const large = document.querySelector(&#x27;.large&#x27;)// 2.事件委托small.addEventListener(&#x27;mouseover&#x27;, function (e) &#123; if (e.target.tagName === &#x27;IMG&#x27;) &#123; // console.log(&#x27;111&#x27;) // 排他思想 this.querySelector(&#x27;.active&#x27;).classList.remove(&#x27;active&#x27;) // parentNode 离它最近的上一级 就是给li添加 e.target.parentNode.classList.add(&#x27;active&#x27;) // e.target.src 是小图片 // 让中等盒子的图片 src 换为小图片 src middle.querySelector(&#x27;img&#x27;).src = e.target.src // 大盒子更换背景图片 large.style.backgroundImage = `url($&#123;e.target.src&#125;)` &#125;&#125;)// 3.鼠标经过中等盒子 显示隐藏大盒子middle.addEventListener(&#x27;mouseenter&#x27;, show)middle.addEventListener(&#x27;mouseleave&#x27;, hide)let timeId = 0// 封装函数 显示function show() &#123; // 防止卡bug 先清除定时器 clearTimeout(timeId) large.style.display = &#x27;block&#x27;&#125;// 隐藏 加定时器让用户体验变好function hide() &#123; timeId = setTimeout(function () &#123; large.style.display = &#x27;none&#x27; &#125;, 200)&#125;// 4.鼠标经过大盒子 显示隐藏large.addEventListener(&#x27;mouseenter&#x27;, show)large.addEventListener(&#x27;mouseleave&#x27;, hide)// 5.鼠标经过中等盒子 显示隐藏黑色遮罩层const layer = document.querySelector(&#x27;.layer&#x27;)middle.addEventListener(&#x27;mouseenter&#x27;, function () &#123; layer.style.display = &#x27;block&#x27;&#125;)middle.addEventListener(&#x27;mouseleave&#x27;, function () &#123; layer.style.display = &#x27;none&#x27;&#125;)// 6.移动黑色遮罩层middle.addEventListener(&#x27;mousemove&#x27;, function (e) &#123; // 鼠标在middle 盒子里面的坐标 = 鼠标在页面中的坐标 - middle 中等盒子的坐标 // console.log(e.pageX)鼠标在页面中的坐标 // middle 中等盒子的坐标 // console.log(middle.getBoundingClientRect().left) let x = e.pageX - middle.getBoundingClientRect().left let y = e.pageY - middle.getBoundingClientRect().top - document.documentElement.scrollTop // console.log(x, y) // 黑色遮罩层移动 在 middle 盒子内 限定移动距离 if (x &gt;= 0 &amp;&amp; x &lt;= 400 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 400) &#123; // 黑色盒子不是一直移动的 // 声明两个变量 黑色盒子移动的变量 mx my let mx = 0, my = 0 // 如果鼠标在盒子左的位置小于100 黑色黑子不移动 if (x &lt; 100) mx = 0 // 如果鼠标在盒子左的位置在100-300之间 黑色盒子开始移动并且减去鼠标在盒子左边100的距离 就是黑色盒子从左边0的位置开始，不是直接从左边100开始 if (x &gt;= 100 &amp;&amp; x &lt;= 300) mx = x - 100 // 如果鼠标在盒子左边的位置大于了300 ，黑色盒子移动到左边200的距离就可以了 if (x &gt; 300) mx = 200 if (y &lt; 100) my = 0 if (y &gt;= 100 &amp;&amp; y &lt;= 300) my = y - 100 if (y &gt; 300) my = 200 layer.style.left = mx + &#x27;px&#x27; layer.style.top = my + &#x27;px&#x27; // 大盒子的 背景图片移动(backgroundPositionX) 随中等盒子移动 存在的关系是2倍 large.style.backgroundPositionX = -2 * mx + &#x27;px&#x27; large.style.backgroundPositionY = -2 * my + &#x27;px&#x27; &#125;&#125;) 电梯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 电梯// 第一模块页面滑动(function () &#123; // 获取元素 // 获取要在那显示电梯的盒子 const entry = document.querySelector(&#x27;.xtx_entry&#x27;) // 获取电梯 const elevator = document.querySelector(&#x27;.xtx-elevator&#x27;) // 1.当页面滚动大于300像素，显示电梯导航 // 2.给页面添加滚动事件 window.addEventListener(&#x27;scroll&#x27;, function () &#123; // 被卷去的头部 大于185 const n = document.documentElement.scrollTop // console.log(n) // if (n &gt;= 300) &#123; // elevator.style.opacity = 1 // &#125; else &#123; // elevator.style.opacity = 0 // &#125; // opacity 透明 elevator.style.opacity = n &gt;= entry.offsetTop ? 1 : 0 &#125;) // 点击返回顶部 const backTop = document.querySelector(&#x27;#backTop&#x27;) backTop.addEventListener(&#x27;click&#x27;, function () &#123; // document.documentElement.scrollTop = 0 window.scrollTo(0, 0) &#125;)&#125;)();// 第二模块 第三模块(function () &#123; // 2.点击页面滑动 const list = document.querySelector(&#x27;.xtx-elevator-list&#x27;) list.addEventListener(&#x27;click&#x27;, function (e) &#123; console.log(11) // 判断是a标签还必须是自定义属性 if (e.target.tagName === &#x27;A&#x27; &amp;&amp; e.target.dataset.name) &#123; // 获取active这个类名的对象 赋值 const old = document.querySelector(&#x27;.xtx-elevator-list .active&#x27;) // console.log(old) // null // 判断 如果有active这个类就移除没有就不删除返回null if (old) old.classList.remove(&#x27;active&#x27;) // 当前元素添加active(高亮) e.target.classList.add(&#x27;active&#x27;) // 获得自定义属性 new topic // console.log(e.target.dataset.name) // 根据小盒子的自定义属性值去选择对应的大盒子 // console.log(document.querySelector(`.xtx_goods_$&#123;e.target.dataset.name&#125;`).offsetTop) // 获得对应大盒子的offsetTop const top = document.querySelector(`.xtx_goods_$&#123;e.target.dataset.name&#125;`).offsetTop - 100 // 让页面滚动到对应的位置 document.documentElement.scrollTop = top &#125; &#125;) //3.页面滚动事件，可以根据大盒子添加小盒子 window.addEventListener(&#x27;scroll&#x27;, function () &#123; // 3.1先移除类 // 获取active这个类名的对象 赋值 const old = document.querySelector(&#x27;.xtx-elevator-list .active&#x27;) // console.log(old) // null // 判断 如果有active这个类就移除没有就不删除返回null if (old) old.classList.remove(&#x27;active&#x27;) // 3.2 判断页面当前滑动的位置，选择小盒子 // 获取四个大盒子 const news = document.querySelector(&#x27;.xtx_goods_new&#x27;) const popular = document.querySelector(&#x27;.xtx_goods_popular&#x27;) const brand = document.querySelector(&#x27;.xtx_goods_brand&#x27;) const topic = document.querySelector(&#x27;.xtx_goods_topic&#x27;) // html的位置 const n = document.documentElement.scrollTop if (n &gt;= news.offsetTop &amp;&amp; n &lt; popular.offsetTop) &#123; // [data-name=new] 属性选择器 document.querySelector(&#x27;[data-name=new]&#x27;).classList.add(&#x27;active&#x27;) &#125; else if (n &gt;= popular.offsetTop &amp;&amp; n &lt; brand.offsetTop) &#123; document.querySelector(&#x27;[data-name=popular]&#x27;).classList.add(&#x27;active&#x27;) &#125; else if (n &gt;= brand.offsetTop &amp;&amp; n &lt; topic.offsetTop) &#123; document.querySelector(&#x27;[data-name=brand]&#x27;).classList.add(&#x27;active&#x27;) &#125; else if (n &gt;= topic.offsetTop) &#123; document.querySelector(&#x27;[data-name=topic]&#x27;).classList.add(&#x27;active&#x27;) &#125; &#125;)&#125;)(); tab栏切换12345678910111213141516171819202122&lt;script&gt; // 1.给5个链接绑定鼠标经过事件 // 1.1 获取a元素 const as = document.querySelectorAll(&#x27;.tab-nav a&#x27;) // console.log(as) for (let i = 0; i &lt; as.length; i++) &#123; // console.log(as[i]) as[i].addEventListener(&#x27;mouseenter&#x27;,function()&#123; // console.log(&#x27;鼠标经过&#x27;) // 排他思想 移除类 添加类 document.querySelector(&#x27;.tab-nav .active&#x27;).classList.remove(&#x27;active&#x27;) // 添加类 this 当前的a this.classList.add(&#x27;active&#x27;) // 下面五个大盒子 .item // 移除类 document.querySelector(&#x27;.tab-content .active&#x27;).classList.remove(&#x27;active&#x27;) // 对应序号item 显示 添加acitve类 document.querySelector(`.tab-content .item:nth-child($&#123;i + 1&#125;)`).classList.add(&#x27;active&#x27;) &#125;) &#125; &lt;/script&gt;","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"Web Api","slug":"Web-Api","permalink":"http://example.com/tags/Web-Api/"}]},{"title":"初识(二)","slug":"初识-二-JS","date":"2022-11-06T03:41:47.000Z","updated":"2022-11-06T03:42:47.080Z","comments":true,"path":"2022/11/06/初识-二-JS/","link":"","permalink":"http://example.com/2022/11/06/%E5%88%9D%E8%AF%86-%E4%BA%8C-JS/","excerpt":"","text":"JS进阶1-作用域​ 作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。 作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问， ​ 作用域分为：局部作用域 全局作用域 1.1局部作用域​ 局部作用域分为函数作用域和块作用域。 1.1.1函数作用域​ 在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。 1.函数内部声明的变量，在函数外部无法被访问 2.函数的参数也是函数内部的局部变量 3.不同函数内部声明的变量无法互相访问 4.函数执行完毕后，函数内部的变量实际被清空了 1234567891011121314151617181920212223242526272829// 函数内部声明的变量可以在函数内部访问 // function fn()&#123; // let a = 10; // console.log(a) // &#125; // fn(); // 函数内部声明的变量，不可在函数外部所访问 // function fn()&#123; // let a = 10; // &#125; // fn(); // console.log(a) // 函数的形参对应的作用域也是函数作用，在外部不能够被访问 // function fn(x, y) &#123; // console.log(x) // console.log(y) // return x + y // &#125; // fn(1, 2); // function fn(x, y) &#123; // return x + y // &#125; // fn(1, 2); // console.log(x) // console.log(y) 1.1.2块级作用域在 JavaScript 中使用 { } 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。 1.let 声明的变量会产生块作用域，var不会产生块级作用域 2.const 声明的常量也会产生块级作用域 3.不同代码块之间的变量无法相互访问 4.推荐使用let 和 const 12345678910111213141516// if for switch while 对象不能产生作用域//在&#123;&#125;内,通过const关键字声明变量，会产生块级作用域 // if (true) &#123; // const a = 10; // &#125; // console.log(a) //在&#123;&#125;内,通过var关键字声明变量，不会产生块级作用域 // if (true) &#123; // var a = 10; // &#125; // console.log(a) //不能说： &#123;&#125;对应的作用域就是块级作用、要看是哪个关键字声明的变量 // let const 声明的变量对应的作用域才是块级作用域 1.2全局作用域标签和.js文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。 全局作用域中声明的变量，任何其它作用域都可以被访问 注意： 1.为window对象动态添加的属性默认也是全局的-不推荐 2.函数中未使用任何关键字声明的变量为全局变量-不推荐 3.尽可能少的声明全局变量，防止全局变量被污染 1234567891011121314151617181920212223242526272829303132// 全局作用域内声明的变量可以再全局访问也可以在局部作用域内访问 // let a = 10; // // console.log(a); // function fn ()&#123; // console.log(a) // &#125; // fn() // window对象下挂载的变量对应的也是全局作用域 【不推荐】 // window.a = 10; // function fn ()&#123; // console.log(window.a) // &#125; // fn() // 不使用任何关键字 声明的变量 对应的作用域也是全局作用域 [不推荐] // function fn()&#123; // a =10 // &#125; // fn() // console.log(window.a) // let var const // 只有var 关键字声明的变量，才会自动挂载到window上，let const 不会 const a = 100; let b = 1000; var c = 10000; console.log(window.a) console.log(window.b) console.log(window.c) #### 1.3作用域链 作用域链本质上是底层的变量查找机制 ​ 在函数被执行时，会优先查找当前函数作用域中查找变量 ​ 如果当前作用域查找不到则会依次逐级查找父作用域直到全局作用域 总结： 1.嵌套关系的作用域串联起来形成了作用域链 2.相同作用域链中按着从小到大的规则查找变量 3.子作用域能够访问父作用域，父级作用域无法访问子级作用域 12345678910let a = 100; function fn1()&#123; // let a = 10; function fn2()&#123; // let a = 1; console.log(a); &#125; fn2() &#125; fn1() #### 1.4 JS垃圾回收机制 垃圾回收机制（Garbage Collection）简称GC JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。 正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题 但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况 不再用到的内存，没有及时释放，就叫做内存泄漏。 所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉 ##### 1.4.1内存的生命周期 JS环境中分配的内存, 一般有如下生命周期： 1.内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 2.内存使用：即读写内存，也就是使用变量、函数等 3.内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 说明： 全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 ##### 1.4.2 引用计数法 IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。 算法： 1.跟踪记录每个值被引用的次数。 2.如果这个值的被引用了一次，那么就记录次数1 3.多次引用会累加。 4.如果减少一个引用就减1。 5.如果引用次数是0 ，则释放内存。 123456const person = &#123;age: 18,name: &#x27;pink老师&#x27; &#125;const p = personperson = 1p = null 致命的问题：嵌套引用。 如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。 12345678//因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露function fn() &#123;let o1 = &#123;&#125;let o2 = &#123;&#125;o1.a = o2o2.a = o1return &#x27;引用计数无法回收&#x27; &#125;fn() ##### 1.4.3 标记清除法 \u001a\u0005现代的浏览器已经不再使用引用计数算法了。 现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。 核心： 1.标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 2.就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 3.那些无法由根部出发触及到的对象被标记为不再使用，稍后进 行回收。 12345678//根部已经访问不到，所以自动清除function fn() &#123;let o1 = &#123;&#125;let o2 = &#123;&#125;o1.a = o2o2.a = o1return &#x27;引用计数无法回收&#x27; &#125;fn() #### 1.5 闭包 概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 简单理解：闭包 = 内层函数 + 外层函数的变量 闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量 123456789101112function outer() &#123; let a = 10; function fn() &#123; console.log(a) &#125; // console.log(fn); return fn &#125; //fun==&gt; outer() ==&gt; fn ==&gt; function fn() &#123; console.log(a) &#125; let fun = outer(); // console.log(fun); fun() //调用函数 外部函数使用内部函数的变量 闭包应用：实现数据的私有 比如，我们要做个统计函数调用次数，函数调用一次，就++ 12345678910111213function outer() &#123; let i = 0; //长驻内存 function fn() &#123; i++; console.log(`第$&#123;i&#125;次调用函数`) &#125; return fn &#125; let fun = outer(); fun(); // 确定了fun 不再被调用的时候 fun = null; //函数变成 不可达了 闭包可能引起的问题：内存泄漏 #### 1.6变量提升 变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量） 只提升变量声明， 不提升变量赋值 注意： 1.变量在未声明即被访问时会报语法错误 2.变量在var声明之前即被访问，变量的值为 undefined 3.let/const 声明的变量不存在变量提升 4.变量提升出现在相同作用域当中 5.实际开发中推荐先声明再访问变量 12345678910111213141516171819202122// 变量提升 提升的仅仅是声明 而不提升赋值 // console.log(a) // var a = 10; // ===相当于 // var a; // console.log(a) // a = 10 //变量提升 仅仅提升在当前作用域的最前端 // function fn() &#123; // console.log(a) // var a = 10 // &#125; // fn() // console.log(a) // let 和 const 存在变量提升 console.log(a) // let a = 10; const a = 10; ### 2-函数进阶 #### 2.1函数提升 函数提升与变量提升比较类似，是指函数在声明之前即可被调用。 1.函数提升能够使函数的声明调用更灵活 2.函数表达式不存在提升的现象 3.函数提升出现在相同作用域当中 注意：函数表达式不存在提升现象 1234567891011121314151617181920212223242526272829303132// 函数提升，函数可以在函数声明之前调用 // fn(); // function fn()&#123; // console.log(1) // &#125; // 相当于 // function fn() &#123; // console.log(1) // &#125; // fn(); // fn() // var fn = function () &#123; // console.log(1) // &#125; //相当于 // var fn; // fn() // fn = function () &#123; // console.log(1) // &#125; // 当变量和函数同时存在提升的时候，函数的优先级高 console.log(fn) var fn = 123; function fn() &#123; console.log(1234) &#125; #### 2.2函数参数 产品需求： 写一个求和函数 不管用户传入几个实参，都要把和求出来 实线： 1.动态参数 2.剩余参数 ##### 2.2.1动态参数（arguments ） arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参 1.arguments 是一个伪数组，只存在于函数中 2.arguments 的作用是动态获取函数的实参 3.可以通过for循环依次得到传递过来的实参 1234567891011function getSum() &#123; // console.log(arguments) let sum = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i] &#125; console.log(sum); &#125; getSum(1, 2, 3, 4) getSum(1, 2, 3, 4, 5) getSum(1, 2, 3, 4, 5, 6) ##### 2.2.2剩余参数（...other） 剩余参数允许我们将一个不定数量的参数表示为一个数组 1、 ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 2、借助 ... 获取的剩余实参，是个真数组 开发中，还是提倡多使用 剩余参数。 123456789101112131415// 剩余参数 // 语法： ...变量名，只能放在函数形参的最末尾 // 作用：可以拿到所有的实参 // 变量名是一个真数组 function getSum(...arr) &#123; // console.log(arr) let sum = 0; for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; console.log(sum) &#125; getSum(1, 2, 3, 4) getSum(1, 2, 3, 4, 5) getSum(1, 2, 3, 4, 5, 6) 剩余参数和动态参数区别是什么？开发中提倡使用哪一个？ 1.动态参数是伪数组 2.剩余参数是真数组 区别：开发中使用剩余参数想必也是极好的 #### 2.3 展开运算符 展开运算符(…),将一个数组进行展开 典型运用场景： 求数组最大值(最小值)、合并数组等 123456// 展开运算符 // 语法： ...arr // 特点：不会影响元素组 let arr = [1, 2, 3, 4] console.log(...arr) //？1,2,3,4 console.log(arr) 1234567891011121314151617181920// 可以利用展开运算符 求最大值 最小值 数组合并 // const max = Math.max(1, 2, 3, 4, 5) // console.log(max) // 求最大值 // const arr = [1, 2, 3, 4, 5] // const max = Math.max(...arr) // console.log(max) // 求最小值 // const arr = [1, 2, 3, 4, 5] // const min = Math.min(...arr) // console.log(min) // 数组合并 const arr1 = [1, 2, 3, 8] const arr2 = [4, 5, 6]; // const arr3 = [1, 2, 3, 4, 5, 6,8]; const arr3 = [...arr1, ...arr2] console.log(arr3) ##### 展开运算符 or 剩余参数 剩余参数：函数参数使用，得到真数组 展开运算符：数组中使用，数组展开 #### 2.4箭头函数 引入箭头函数的目的是更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁 12345678910111213141516171819202122232425262728 // 基本语法 // const fn = () =&gt; &#123; // console.log(123) // &#125;// 传参 // const fn = (x) =&gt; &#123; // console.log(x) // &#125; // fn(1) // 只有一个形参的时候可以省略小括号 // const fn = x =&gt; &#123; // console.log(x) // &#125; // fn(1) // 只有一行代码的时候 可以省略大括号 // const fn = x =&gt; console.log(x) // fn(2) // 只有一行代码可以省略return // const fn = x =&gt; x + x // console.log(fn(2)) // 直接返回对象 // const fn = uname =&gt; (&#123; uname: uname &#125;) // console.log(fn(&#x27;刘德华&#x27;)) 1.箭头函数属于表达式函数，因此不存在函数提升 2.箭头函数只有一个参数时可以省略圆括号 () 3.箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回 4.加括号的函数体返回对象字面量表达式 ##### 2.4.1 箭头函数参数 1.普通函数有arguments 动态参数 2.箭头函数没有 arguments 动态参数，但是有 剩余参数 ..args 使用场景：箭头函数更适用于那些本来需要匿名函数的地方 123456789// 箭头函数求和 const getSum = (...arr) =&gt; &#123; let sum = 0 for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum &#125; console.log(getSum(2, 3, 4)) ##### 2.4.2 箭头函数 this 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值， 非常令人讨厌。 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。 1234567console.log(this) //此处为windowcosnt sayHi = function () &#123; console.log(this) //普通函数指向调用者 此处为window&#125;btn.addEventListener (&#x27;click&#x27;, function () &#123; console.log(this) //当前this 指向btn&#125;) 1234567console.log(this) //此处为windowcosnt sayHi =() =&gt; &#123; console.log(this) //箭头函数此处为window&#125;btn.addEventListener (&#x27;click&#x27;, function () &#123; console.log(this) //当前this 指向window&#125;) 1234567891011const user = &#123; name: &#x27;小明&#x27; sleep: function () &#123; console.log(this) //指向 user const fn = () =&gt; &#123; console.log(this) //指向user 该箭头函数中的 this 与 sleep 中的 this 一致 &#125; fn() //调用箭头函数 &#125;&#125;user.sleep() ### 3-解构赋值 解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值。 分为： 数组解构 对象解构 #### 3.1数组解构 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法。 基本语法： 1.赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 2.变量的顺序对应数组单元值的位置依次进行赋值操作 12345678910const arr = [100, 60, 80] const [max, min, avg] = arr //const [max, min, avg] = [100, 60, 80] console.log(max) console.log(avg) // 交换两个变量 let a = 1 let b = 2; //必须写; [b, a] = [a, b] console.log(a, b) 注意： js 前面必须加分号情况 Js 前面有两哪种情况需要加分号的 1.立即执行函数 2.数组解构 独立完成数组解构赋值 需求①： 有个数组： const pc = ['海尔', '联想', '小米', '方正'] 解构为变量: hr lx mi fz 需求②：请将最大值和最小值函数返回值解构 max 和min 两个变量 12345678910111213const pc = [&#x27;海尔&#x27;, &#x27;联想&#x27;, &#x27;小米&#x27;, &#x27;方正&#x27;] const [hr, lx, mi, fz] = pc console.log(hr) console.log(lx) console.log(mi) console.log(fz) function getValue() &#123; return [100, 60] &#125; const [max, min] = getValue() console.log(max, min) ##### 3.1.1变量多 单元值少的情况 12345cosnt [a, b, c, d] = [&#x27;小米&#x27;, &#x27;苹果&#x27;, &#x27;华为&#x27;]console.log(a) //小米console.log(b) //苹果console.log(c) //华为console.log(d) //undefined 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 防止有undefined传递单元值的情况，可以设置默认值 123cosnt [a = &#x27;手机&#x27;, b = &#x27;华为&#x27;] = [&#x27;小米&#x27;]console.log(a) //小米console.log(b) //华为 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 ##### 3.1.2变量少 单元值多的情况 12345cosnt [a, b, c] = [&#x27;小米&#x27;, &#x27;苹果&#x27;, &#x27;华为&#x27;, &#x27;格力&#x27;]console.log(a) //小米console.log(b) //苹果console.log(c) //华为console.log(d) //undefined 利用剩余参数解决变量少 单元值多的情况 1234cosnt [a, b, ...tel] = [&#x27;小米&#x27;, &#x27;苹果&#x27;, &#x27;华为&#x27;, &#x27;格力&#x27;]console.log(a) //小米console.log(b) //苹果console.log(c) //[&#x27;华为&#x27;, &#x27;格力&#x27;] 剩余参数返回的还是一个数组 但只能置于最末尾 ##### 3.1.3按需导入，忽略某些返回值 1234cosnt [a, ,c, d] = [&#x27;小米&#x27;, &#x27;苹果&#x27;, &#x27;华为&#x27;, &#x27;格力&#x27;]console.log(a) //小米console.log(c) //华为console.log(d) //格力 ##### 3.1.4支持多维数组的结构 123const [a, b] = [&#x27;苹果&#x27;, [&#x27;小米&#x27;, &#x27;华为&#x27;]]console.log(a) //苹果console.log(b) //[&#x27;小米&#x27;, &#x27;华为&#x27;] 12345//如何拿到小米华为？const [a, [b, c]] = [&#x27;苹果&#x27;, [&#x27;小米&#x27;, &#x27;华为&#x27;]]console.log(a) //苹果console.log(b) //小米console.log(c) //华为 #### 3.2对象解构 对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法 基本语法： 1.赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 2.对象属性的值将被赋值给与属性名相同的变量 3.注意解构的变量名不要和外面的变量名冲突否则报错 4.对象中找不到与变量名一致的属性时变量值为 undefined 1234567const obj = &#123; uname: &#x27;熊大&#x27;, age: &#x27;18&#x27; &#125; const &#123; uname, age &#125; = &#123; uname: &#x27;熊大&#x27;, age: &#x27;18&#x27; &#125; console.log(uname) //熊大 console.log(age) //18 ###### 给新的变量名赋值 可以从一个对象中提取变量并同时修改新的变量名 1234const &#123; uname:username, age &#125; = &#123; uname: &#x27;熊大&#x27;, age: &#x27;18&#x27; &#125; console.log(username) console.log(age) //冒号表示“什么值：赋值给谁” ##### 3.2.1数组对象解构 123456const pig = [ &#123; uname: &#x27;佩奇&#x27;, weight: 200 &#125; ] 123const [&#123; uname, weight &#125;] = [&#123; uname: &#x27;佩奇&#x27;, weight: &#x27;200kg&#x27; &#125;] console.log(uname) console.log(weight) 123456789const pig = &#123; name: &#x27;佩奇&#x27;, age: 6 &#125; const &#123; name, age &#125; = &#123;name: &#x27;佩奇&#x27;,age: 6&#125; console.log(name) console.log(age) const &#123; name:uname, age &#125; = &#123;name: &#x27;佩奇&#x27;,age: 6&#125; console.log(uname,age) 123456const goods = [ &#123; goodsName: &#x27;小米&#x27;, price: 1999 &#125; ] 12const [&#123;goodsName, price&#125;] = [&#123; goodsName: &#x27;小米&#x27;, price: 1999 &#125;] console.log(goodsName,price) ##### 3.2.2多级对象解构 1234567891011121314const pig = &#123;name: &#x27;佩奇&#x27;,family: &#123;mother: &#x27;猪妈妈&#x27;,father: &#x27;猪爸爸&#x27;,sister: &#x27;乔治&#x27;&#125;,age: 6&#125;const &#123; name, family: &#123; mother, father, sister&#125;&#125; = pigconsole.log(name) //佩奇console.log(mother) //猪妈妈console.log(father) //猪爸爸console.log(sister) //乔治 案例 123456789101112131415161718192021222324252627282930313233343536// 1.传递的数据 const msg = &#123; &quot;code&quot;: 200, &quot;msg&quot;: &quot;获取新闻列表成功&quot;, &quot;data&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;5G商用自己，三大运营商收入下降&quot;, &quot;count&quot;: 58 &#125;, &#123; &quot;id&quot;: 2, &quot;title&quot;: &quot;国际媒体&quot;, &quot;count&quot;: 56 &#125;, &#123; &quot;id&quot;: 3, &quot;title&quot;: &quot;俄乌冲突&quot;, &quot;count&quot;: 199 &#125;, ] &#125; // 需求1：请将意思msg对象 采用解构的方式 只选出 data const &#123; data &#125; = msg console.log(data) // 需求2：上面msg是后天传递的数据 我们需要把data 选出来当做参数传递给 函数 function render(&#123; data &#125;) &#123; console.log(data) &#125; render(msg) // 需求3：为了防止msg里面的data名字混淆 要求渲染函数里面的数据名改为 myData function render(&#123; data: myData &#125;) &#123; console.log(myData) &#125; render(msg) #### 3.3遍历数组 forEach 方法 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 主要使用场景： 遍历数组的每个元素 参数当前数组元素是必须要写的， 索引号可选 语法： 123被遍历的数组.forEach(function (当前数组元素, 当前元素索引号)&#123; 函数体&#125;) 12345const arr = [&#x27;pink&#x27;, &#x27;red&#x27;, &#x27;green&#x27;]arr.forEach(function (item, index)&#123; console.log(`当前数组元素是：$&#123;item&#125;`) //依次打印数组每一个元素 console.log(`当前数组元素的索引号是：$&#123;index&#125;`) //依次打印数组每一个元素的索引号&#125;) #### 3.4筛选数组 filter 方法 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组 语法： 123被遍历的数组.filter (function (当前数组元素, 当前元素索引号)&#123; 函数体&#125;) 返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组 参数：当前数组元素 必须写， 索引号 可选 因为返回新数组，所以不会影响原数组 123456//筛选数组中大于30的元素const score = [10, 50, 3, 40, 33]const re = score.filter( function (item) &#123; return item &gt; 30&#125;)console.log(re) //[50, 40, 33] ### 4-深入对象 #### 4.1创建对象三种方式 ##### 4.1.1利用对象字面量创建对象 123const o = &#123; name: &#x27;佩奇&#x27;&#125; ##### 4.1.2利用 new Object 创建对象 1234const o = new Object(&#123; name: &#x27;佩奇&#x27;&#125;)console.log(o) //&#123;name: &#x27;佩奇&#x27;&#125; ##### 4.1.3利用构造函数创建对象 12345678 //创建构造函数 function Pig(uname, age) &#123; this.uname = uname this.age = age &#125;//创建对象 const p = new Pig(&#x27;佩奇&#x27;, 6) console.log(p) #### 4.2构造函数 构造函数 ：是一种特殊的函数，主要用来初始化对象 使用场景：常规的 {...} 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一 遍，此时可以通过构造函数来快速创建多个类似的对象。 构造函数在技术上是常规函数。 注意：不过有两个约定： 1.它们的命名以大写字母开头。 2.它们只能由 \"new\" 操作符来执行。 1234567891011function Goods(name, price, count) &#123; this.name = name this.price = price this.count = count &#125; const mi = new Goods(&#x27;小米&#x27;, 1999, 20) const hw = new Goods(&#x27;华为&#x27;, 2999, 50) const vo = new Goods(&#x27;vivo&#x27;, 1888, 60) console.log(mi) console.log(hw) console.log(vo) 说明： 1.使用 new 关键字调用函数的行为被称为实例化 2.实例化构造函数时没有参数时可以省略 () 3.构造函数内部无需写return，返回值即为新创建的对象 4.构造函数内部的 return 返回的简单类型值无效，引用类型的值会被返回。所以不要写return 5.new Object（） new Date（） 也是实例化构造函数 实例化执行过程 1.创建新空对象 2.构造函数this指向新对象 3.执行构造函数代码，修改this，添加新的属性 4.返回新对象 #### 4.3实例成员&静态成员 ##### 4.3.1实例成员： 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。 说明： 1.实例对象的属性和方法即为实例成员 2.为构造函数传入参数，动态创建结构相同但值不同的对象 3.构造函数创建的实例对象彼此独立互不影响。 ##### 4.3.2静态成员： 构造函数的属性和方法被称为静态成员 说明： 1.构造函数的属性和方法被称为静态成员 2.一般公共特征的属性或方法静态成员设置为静态成员 3.静态成员方法中的 this 指向构造函数本身 ### 5-内置构造函数 #### 5.1 Object Object 是内置的构造函数，用于创建普通对象。 123456const user = new Object( &#123; name: &#x27;小明&#x27;, age: 18 &#125;) 推荐使用字面量方式声明对象，而不是 Object 构造函数 ##### 5.1.1 学习三个常用静态方法（静态方法就是只有构造函数Object可以调用的） Object.keys 静态方法获取对象中所有属性（键） 返回的是一个数组 Object.values 静态方法获取对象中所有属性值 返回的是一个数组 Object. assign 静态方法常用于对象拷贝 1234567891011const o = &#123; name: &#x27;熊大&#x27;, age: 6 &#125; // 1.获得所有的属性名 console.log(Object.keys(o)) // 2.获得所有的属性值 console.log(Object.values(o)) // 3.对象的拷贝 // const oo = &#123;&#125; // Object.assign(oo, o) // console.log(oo) Object.assign(o, &#123; gender: &#x27;男&#x27; &#125;) console.log(o) #### 5.2 Array ##### 5.2.1 reduce reduce 返回函数累计处理的结果，经常用于求和等 语法： 1arr.reduce(function (累计值, 当前元素 [,索引号][,源数组])&#123;&#125;,起始值) 累计值参数： 1.如果有起始值，则以起始值为准开始累计， 累计值 = 起始值 2.如果没有起始值， 则累计值以数组的第一个数组元素作为起始值开始累计 3.后面每次遍历就会用后面的数组元素 累计到 累计值 里面 （类似求和里面的 sum ） 12345678const arr = [1, 2, 3] // arr.reduce(function(累计值, 当前元素)&#123;&#125;,起始值) arr.reduce(function (prev, item) &#123; // console.log(prev) return prev + item &#125;, 0) const re = arr.reduce((prev, item) =&gt; prev + item) console.log(re) ##### 5.2.2 数组常见方法-其他方法 1234567891011121314151617181920212223242526272829303132333435363738// join字符串拼接 const sj = [&#x27;2022&#x27;, &#x27;07&#x27;, &#x27;01&#x27;] const str = sj.join(&#x27;-&#x27;) console.log(str) // find 查找元素 返回符合条件的第一个数组元素值 const arr1 = [10, 20, 30, 40, 50, 60] // const newArr1 = arr1.find(function (item) &#123; // return item &gt;= 40 // &#125;) // const newArr1 = arr1.find(item =&gt; item &gt;= 40) // findIndex 查找索引号 // const newArr1 = arr1.findIndex(function (item) &#123; // return item &gt;= 40 // &#125;) // console.log(newArr1) // every 检查数组所有元素都是否满足条件 // const groupScore = [40, 80, 90, 100] // const result = groupScore.every(function (item) &#123; // return item &gt;= 80 // &#125;) // console.log(result) //flase // some 检查数组中是否有满足条件 const groupScore = [40, 80, 90, 100] const result = groupScore.some(function (item) &#123; return item &gt;= 90 &#125;) console.log(result) //true //Array.from() 伪数组转为真数组 function getSum() &#123; const re= Array.from(arguments).reduce((prev, item) =&gt; prev + item) console.log(re) &#125; getSum(1, 2, 3, 4) ![Snipaste_2022-07-01_18-09-31](E:\\能放\\前端\\截图\\js进阶\\Snipaste_2022-07-01_18-09-31.png) #### 5.3 String 在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法 之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称 为包装类型。![Snipaste_2022-07-01_18-28-45](E:\\能放\\前端\\截图\\js进阶\\Snipaste_2022-07-01_18-28-45.png) 12345678910111213141516171819202122232425262728// 1.split 把字符串分割 返回数组 和 join() 相反 // const str1 = &#x27;abcd,efg&#x27; // const arr = str1.split(&#x27;,&#x27;) // const str2 = &#x27;2022-06-27&#x27; // const arr1 = str2.split(&#x27;-&#x27;) // console.log(arr) // console.log(arr1) // 2.字符串截取 substring(开始的索引号[,结束的索引号]) // 如果省略结束的索引号，默认取到最后 // 结束的索引号不包含想要截取的部分 // const str = &#x27;了空间和规范的撒&#x27; // console.log(str.substring(1, 3)) //空间 // 3.startsWith 判断是不是以某个字符开头 // const str = &#x27;abcdefg&#x27; // console.log(str.startsWith(&#x27;abc&#x27;)) //返回true // console.log(str.startsWith(&#x27;bcd&#x27;)) //返回false // 4.includes 判断某个字符串是不是包含在一个字符串里 // const str = &#x27;abcdefg&#x27; // console.log(str.includes(&#x27;bce&#x27;)) //返回true // console.log(str.includes(&#x27;fgh&#x27;)) //返回false // console.log(str.includes(&#x27;abc&#x27;,1)) //返回false //5. length 用来获取字符串的长度 const str = &#x27;今天天气真好666！&#x27; console.log(str.length) //10 #### 5.4 Number Number 是内置的构造函数，用于创建数值 常用方法： toFixed() 设置保留小数位的长度 1234const price = 12.345const price2 = 12.385console.log(price.toFixed(2)) //12.35 保留两位小数 假四舍五入console.log(price2.toFixed(2)) //12.38 保留两位小数 假四舍五入 小案例 1234567891011121314// const gift = &#x27;50g的茶叶,清洗球&#x27; // // 1.把字符串拆分为数组 // console.log( gift.split(&#x27;,&#x27;)) // // 2.根据数组元素的个数，生成对应 span 标签 // const str = gift.split(&#x27;,&#x27;).map(function (item) &#123; // return `&lt;span&gt;【赠品】 $&#123;item&#125;&lt;/span&gt;&lt;/br&gt;` // &#125;).join(&#x27;&#x27;) // console.log(str) // document.querySelector(&#x27;div&#x27;).innerHTML = str const gift = &#x27;50g的茶叶,清洗球&#x27; // 1.把字符串拆分为数组 // 2.根据数组元素的个数，生成对应 span 标签 document.querySelector(&#x27;div&#x27;).innerHTML = gift.split(&#x27;,&#x27;).map(item =&gt; `&lt;span&gt;【赠品】 $&#123;item&#125;&lt;/span&gt;&lt;/br&gt;`).join(&#x27;&#x27;) #### 综合案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374* &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .list &#123; width: 990px; margin: 100px auto 0; &#125; .item &#123; padding: 15px; transition: all .5s; display: flex; border-top: 1px solid #e4e4e4; &#125; .item:nth-child(4n) &#123; margin-left: 0; &#125; .item:hover &#123; cursor: pointer; background-color: #f5f5f5; &#125; .item img &#123; width: 80px; height: 80px; margin-right: 10px; &#125; .item .name &#123; font-size: 18px; margin-right: 10px; color: #333; flex: 2; &#125; .item .name .tag &#123; display: block; padding: 2px; font-size: 12px; color: #999; &#125; .item .price, .item .sub-total &#123; font-size: 18px; color: firebrick; flex: 1; &#125; .item .price::before, .item .sub-total::before, .amount::before &#123; content: &quot;¥&quot;; font-size: 12px; &#125; .item .spec &#123; flex: 2; color: #888; font-size: 14px; &#125; .item .count &#123; flex: 1; color: #aaa; &#125; .total &#123; width: 990px; margin: 0 auto; display: flex; justify-content: flex-end; border-top: 1px solid #e4e4e4; padding: 20px; &#125; .total .amount &#123; font-size: 18px; color: firebrick; font-weight: bold; margin-right: 50px; &#125; 12345678910111213&lt;div class=&quot;list&quot;&gt; &lt;!-- &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;name&quot;&gt;称心如意手摇咖啡磨豆机咖啡豆研磨机 &lt;span class=&quot;tag&quot;&gt;【赠品】10优惠券&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;spec&quot;&gt;白色/10寸&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;289.90&lt;/p&gt; &lt;p class=&quot;count&quot;&gt;x2&lt;/p&gt; &lt;p class=&quot;sub-total&quot;&gt;579.80&lt;/p&gt; &lt;/div&gt; --&gt; &lt;/div&gt; &lt;div class=&quot;total&quot;&gt; &lt;div&gt;合计：&lt;span class=&quot;amount&quot;&gt;1000.00&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const goodsList = [ &#123; id: &#x27;4001172&#x27;, name: &#x27;称心如意手摇咖啡磨豆机咖啡豆研磨机&#x27;, price: 289.9, picture: &#x27;https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg&#x27;, count: 2, spec: &#123; color: &#x27;白色&#x27; &#125; &#125;, &#123; id: &#x27;4001009&#x27;, name: &#x27;竹制干泡茶盘正方形沥水茶台品茶盘&#x27;, price: 109.8, picture: &#x27;https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png&#x27;, count: 3, spec: &#123; size: &#x27;40cm*40cm&#x27;, color: &#x27;黑色&#x27; &#125; &#125;, &#123; id: &#x27;4001874&#x27;, name: &#x27;古法温酒汝瓷酒具套装白酒杯莲花温酒器&#x27;, price: 488, picture: &#x27;https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png&#x27;, count: 1, spec: &#123; color: &#x27;青色&#x27;, sum: &#x27;一大四小&#x27; &#125; &#125;, &#123; id: &#x27;4001649&#x27;, name: &#x27;大师监制龙泉青瓷茶叶罐&#x27;, price: 139, picture: &#x27;https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png&#x27;, count: 1, spec: &#123; size: &#x27;小号&#x27;, color: &#x27;紫色&#x27; &#125;, gift: &#x27;50g茶叶,清洗球&#x27; &#125; ] document.querySelector(&#x27;.list&#x27;).innerHTML = goodsList.map(item =&gt; &#123; // console.log(item) const &#123; name, price, count, picture, spec, gift &#125; = item const text = Object.values(spec).join(&#x27;/&#x27;) const subTotal = ((price * 100 * count) / 100).toFixed(2) const str = gift ? gift.split(&#x27;,&#x27;).map(item =&gt; `&lt;span class=&quot;tag&quot;&gt;【赠品】$&#123;item&#125;&lt;/span&gt;`).join(&#x27;&#x27;) : &#x27;&#x27; // console.log(str) return ` &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;$&#123;picture&#125;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;name&quot;&gt;$&#123;name&#125; $&#123;str&#125;&lt;/p&gt; &lt;p class=&quot;spec&quot;&gt;$&#123;text&#125;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;$&#123;price.toFixed(2)&#125;&lt;/p&gt; &lt;p class=&quot;count&quot;&gt;x$&#123;count&#125;&lt;/p&gt; &lt;p class=&quot;sub-total&quot;&gt;$&#123;subTotal&#125;&lt;/p&gt; &lt;/div&gt; ` &#125;).join(&#x27;&#x27;) const total = goodsList.reduce((prev, item) =&gt; prev + (item.price * 100 * item.count)/100, 0).toFixed(2) document.querySelector(&#x27;.amount&#x27;).innerHTML = total ### 6-编程思想 #### 6.1.1 面向过程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次 调用就可以了。 面向过程，就是按照我们分析好了的步骤，按照步骤解决问题。 #### 6.1.2 面向对象编程 (oop) 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。 面向对象是以对象功能来划分问题，而不是步骤。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。 面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。 **面向对象的特性：** **1.封装性** **2.继承性** **3.多态性** 编程思想-面向过程和面向对象的对比 **面向过程编程** 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。 缺点：没有面向对象易维护、易复用、易扩展 **面向对象编程** 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加活、更加易于维护 缺点：性能比面向过程低![编程思想对比](E:\\能放\\前端\\截图\\js进阶\\编程思想对比.png) ### 7-构造函数 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。 同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的。 总结： 1.构造函数体现了面向对象的封装特性 2.构造函数实例创建的对象彼此独立、互不影响 123456function Star(uname, age) &#123; this.uname = uname this.age = age&#125;const zs = new Star(&#x27;张三&#x27;, 18)const ls = new Star(&#x27;李四&#x27;, 19) 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。 前面我们学过的构造函数方法很好用，但是 存在浪费内存的问题 123456789function Star(uname, age) &#123; this.uname = uname this.age = age this.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;) &#125;&#125; const ldh = new Star(&#x27;刘德华&#x27;, 18)const zxy = new Star(&#x27;张学友&#x27;, 19) 我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？ => 原型 ### 8-原型 #### 8.1 prototype 属性 构造函数通过原型分配的函数是所有对象所 共享的。 JavaScript 规定，**每一个构造函数都有一个 prototype 属性**，指向另一个对象，所以我们也称为原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 构造函数和原型对象中的this 都指向 实例化的对象 **原型是：一个对象，我们也称为 prototype 为原型对象。** **原型的作用是：** **1.共享方法** **2.可以把那些不变的方法，直接定义在 prototype 对象上** **构造函数和原型里面的this指向 > 实例化的对象** ![原型](E:\\能放\\前端\\截图\\js进阶\\原型.png) ![Snipaste_2022-07-01_20-17-06](E:\\能放\\前端\\截图\\js进阶\\Snipaste_2022-07-01_20-17-06.png) 1234567891011121314151617181920function Star(name, age) &#123; this.name = name; this.age = age; &#125; // 每一个构造函数上都有一个prototype属性。prototype指向的是一个对象。 也叫做原型对象（也常说prototype就是原型对象） console.log(Star.prototype) Star.prototype.sing = function () &#123; console.log(&#x27;唱歌&#x27;) &#125; const ldh = new Star(&#x27;刘德华&#x27;, 18); // 原型对象上的方法(和属性)可以被构造函数的实例所共享 ldh.sing() const zxy = new Star(&#x27;张学友&#x27;, 20) zxy.sing(); // 挂载到原型对象上的方法 多次创建对象的时候 不会多次开辟空间，节约了内存 console.log(ldh.sing === zxy.sing) //true ##### 8.1.1原型- this指向 构造函数和原型对象中的this 都指向 实例化的对象 1234567891011121314let that function Star(uname) &#123; // that = this this.uname = uname &#125; // 原型对象的函数 this 还是指向实例对象 xd Star.prototype.sing = function ()&#123; that = this console.log(&#x27;唱歌&#x27;) &#125; //构造函数里面的 this 就是 实例对象 xd const xd = new Star(&#x27;熊大&#x27;) xd.sing() console.log(that === xd) //true 给数组扩展方法求最大值最小值求和 12345678910111213const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] Array.prototype.max = function () &#123; return Math.max(...this) &#125; Array.prototype.min = function () &#123; return Math.min(...this) &#125; Array.prototype.sum = function () &#123; return this.reduce((prev, item) =&gt; prev + item, 0) &#125; console.log(arr.max()) console.log(arr.min()) console.log([1, 2, 3].sum()) #### 8.2 constructor 属性 每个原型对象里面都有个constructor 属性（constructor 构造函数） 作用：该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子 123456789function Star(name, age) &#123; this.name = name; this.age = age; &#125; // constructor属性存在于 构造函数的原型对象上 console.log(Star.prototype) // constructor指向的构造函数 console.log(Star.prototype.constructor) ![constructor](E:\\能放\\前端\\截图\\js进阶\\constructor.png) 使用场景： 如果有多个对象的方法，我们可以给原型对象采取对象形式赋值. 但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了 此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 123456789101112131415161718192021222324252627282930313233343536373839function Star(name, age) &#123; this.name = name; this.age = age; &#125; // 挂载到原型对象上的原因是节约内存 /* // 这么写代码重复度太高 Star.prototype.sing = function () &#123; console.log(&#x27;唱歌&#x27;); &#125; Star.prototype.dance = function () &#123; console.log(&#x27;跳舞&#x27;); &#125; Star.prototype.movie = function () &#123; console.log(&#x27;演电影&#x27;) &#125; */ console.log(Star.prototype) Star.prototype = &#123; constructor: Star, sing: function () &#123; console.log(&#x27;唱歌&#x27;); &#125;, dance: function () &#123; console.log(&#x27;跳舞&#x27;); &#125;, movie: function () &#123; console.log(&#x27;演电影&#x27;) &#125; &#125; console.log(Star.prototype) const ldh = new Star(&#x27;刘德华&#x27;, 18) ldh.sing(); ldh.dance(); ldh.movie(); #### 8.3 对象原型 对象都会有一个属性 ____proto___ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 ____proto___原型的存在。 ![对象原型](E:\\能放\\前端\\截图\\js进阶\\对象原型.png) 注意： ____proto___是JS非标准属性 [[prototype]]和______proto_____意义相同 用来表明当前实例对象指向哪个原型对象prototype _______proto______对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数 对象都会有一个属性 ____proto___指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 ____proto___原型的存在。 ![对象原型1](E:\\能放\\前端\\截图\\js进阶\\对象原型1.png) 12345678910111213141516171819202122232425function Star(name, age) &#123; this.name = name; this.age = age; &#125; // 构造函数可以通过new方式 实例化对象 // ldh =&gt;实例对象 const ldh = new Star(&#x27;刘德华&#x27;, 18) // 构造函数上都有一个属性prototype 指向的原型对象 console.log(Star.prototype) // 每一个原型对象上都有一个属性叫constructor 指向的构造函数 console.log(Star.prototype.constructor === Star) // 对象上都有属性叫做__proto__【对象原型】 console.log(ldh.__proto__) // 对象的对象原型 指向的是 构造函数的原型对象 // __proto__只读属性 console.log(ldh.__proto__ === Star.prototype) // 实例对象的对象原型也有constructor 指向的构造函数 console.log(ldh.__proto__.constructor === Star) 1.prototype是什么？哪里来的？ 原型（原型对象） 构造函数都自动有原型 2.constructor属性在哪里？作用干啥的？ prototype原型和对象原型__proto__里面都有 都指向创建实例对象/原型的构造函数 3._proto__属性在哪里？指向谁？ 在实例对象里面 指向原型 prototype #### 8.4 原型继承 继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承 的特性。 ##### 8.4.1 封装-抽取公共部分 把公共的部分抽取出来 ![封装](E:\\能放\\前端\\截图\\js进阶\\封装.png) 123456789101112131415161718192021222324252627282930 //提取公共部分 cosnt Person = &#123; nose : 1; eyes : 2; eat : function () &#123; console.log(&#x27;吃饭&#x27;); &#125;&#125; function Man() &#123;//nose : 1; //eyes : 2; //eat : function () &#123; // console.log(&#x27;吃饭&#x27;); // &#125; &#125; Man.prototype = new Person(); Man.prototype.constructor = Man; const lw = new Man(); // console.log(lw.baby()); function Woman() &#123; // nose : 1; // eyes : 2; // eat : function () &#123; // console.log(&#x27;吃饭&#x27;); // &#125; &#125; Woman.prototype = new Person(); Woman.prototype.constructor = Woman; const fengjie = new Woman(); ##### 8.4.2 继承 继承公共部分的属性和方法，可以共享这些公共的属性和方法 继承-让男人和女人都能继承人类的一些属性和方法 1.把男人女人公共的属性和方法抽取出来 People 2.然后赋值给Man的原型对象，可以共享这些属性和方法 3.注意让constructor指回Man这个构造函数 ![继承](E:\\能放\\前端\\截图\\js进阶\\继承.png) 123456789101112131415161718192021 //提取公共部分 cosnt Person = &#123; nose : 1; eyes : 2; eat : function () &#123; console.log(&#x27;吃饭&#x27;); &#125;&#125; function Man() &#123; &#125; Man.prototype = new Person(); Man.prototype.constructor = Man; const lw = new Man(); // console.log(lw.baby()); function Woman() &#123; &#125; Woman.prototype = new Person(); Woman.prototype.constructor = Woman; const fengjie = new Woman(); ##### 8.4.3 继承写法完善 不要使用同一个对象，但是不同对象里面包含相同的属性和方法 ![继承问题](E:\\能放\\前端\\截图\\js进阶\\继承问题.png) ![继承原因](E:\\能放\\前端\\截图\\js进阶\\继承原因.png) 解决方法：构造函数 new 每次都会创建一个新的对象 ![解决](E:\\能放\\前端\\截图\\js进阶\\解决.png) ![继承完善写法](E:\\能放\\前端\\截图\\js进阶\\继承完善写法.png) ![继承完善写法1](E:\\能放\\前端\\截图\\js进阶\\继承完善写法1.png) 123456789101112131415161718192021222324252627function Person() &#123; this.nose = 1; this.eyes = 2; this.eat = function () &#123; console.log(&#x27;吃饭&#x27;); &#125; &#125; function Man() &#123; &#125; Man.prototype = new Person(); Man.prototype.constructor = Man; const lw = new Man(); // console.log(lw.baby()); function Woman() &#123; &#125; Woman.prototype = new Person(); Woman.prototype.baby = function () &#123; console.log(&#x27;生孩子&#x27;) &#125; Woman.prototype.constructor = Woman; const fengjie = new Woman(); console.log(fengjie.baby()) console.log(lw === fengjie) //false #### 8.5 原型链 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对 象的链状结构关系称为原型链 **所有的对象里面都有____proto__对象原型 指向原型对象** **所有的原型对象都有constructor 指回创造该原型对象的构造函数** ![原型链](E:\\能放\\前端\\截图\\js进阶\\原型链.png) ##### 8.5.1 原型链-查找规则 ① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 ② 如果没有就查找它的原型（也就是 ____proto__指向的 prototype 原型对象） ③ 如果还没有就查找原型对象的原型（Object的原型对象） ④ 依此类推一直找到 Object 为止（null） ⑤ ____proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 **⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上** ##### 综合案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.modal &#123; width: 300px; min-height: 100px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); border-radius: 4px; position: fixed; z-index: 999; left: 50%; top: 50%; transform: translate3d(-50%, -50%, 0); background-color: #fff; &#125; .modal .header &#123; line-height: 40px; padding: 0 10px; position: relative; font-size: 20px; &#125; .modal .header i &#123; font-style: normal; color: #999; position: absolute; right: 15px; top: -2px; cursor: pointer; &#125; .modal .body &#123; text-align: center; padding: 10px; &#125; .modal .footer &#123; display: flex; justify-content: flex-end; padding: 10px; &#125; .modal .footer a &#123; padding: 3px 8px; background: #ccc; text-decoration: none; color: #fff; border-radius: 2px; margin-right: 10px; font-size: 14px; &#125; .modal .footer a.submit &#123; background-color: #369; &#125; 1234567&lt;button id=&quot;delete&quot;&gt;删除&lt;/button&gt; &lt;button id=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;!-- &lt;div class=&quot;modal&quot;&gt; &lt;div class=&quot;header&quot;&gt;温馨提示 &lt;i&gt;x&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;body&quot;&gt;您没有删除权限操作&lt;/div&gt; &lt;/div&gt; --&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.模态框的构造函数 function Modal(title = &#x27;&#x27;, message = &#x27;&#x27;) &#123; // 公共部分 this.title = title this.message = message // 1.创建盒子 谁 new 给谁用 this.modalBox = document.createElement(&#x27;div&#x27;) // 2.添加类名 this.modalBox.className = &#x27;modal&#x27; // 3.填充内容 更换数据 this.modalBox.innerHTML = ` &lt;div class=&quot;header&quot;&gt;$&#123;this.title&#125; &lt;i&gt;x&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;body&quot;&gt;$&#123;this.message&#125;&lt;/div&gt; ` &#125; // 2.打开方法 挂载到原型身上 Modal.prototype.open = function () &#123; // 只有你没有modal的时候才执行这段代码 if (!document.querySelector(&#x27;.modal&#x27;)) &#123; // 把创建的盒子 modalBox 渲染到页面中 追加到给定父节点 语法：父元素.appendChild(子元素) document.body.appendChild(this.modalBox) // 把关闭写在打开方法里 获取 x 调用关闭方法 // 箭头函数没有 this 它指向函数里面的 this , 函数里的this 指向 m this.modalBox.querySelector(&#x27;i&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; this.close() &#125;) &#125; &#125; // 3.关闭方法 挂载到原型身上 Modal.prototype.close = function () &#123; document.body.removeChild(this.modalBox) &#125; // 4.按钮点击删除 就创建模态框 document.querySelector(&#x27;#delete&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 传递参数 const m = new Modal(&#x27;温馨提示&#x27;, &#x27;您没有删除权限操作&#x27;) // 调用打开方法 m.open() &#125;) // 5.按钮点击登录 就创建模态框 document.querySelector(&#x27;#login&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; const m = new Modal(&#x27;友情提示&#x27;, &#x27;您没有注册账户&#x27;) // 调用打开方法 m.open() &#125;) ### 9-深浅拷贝 #### 9.1 浅拷贝 首先浅拷贝和深拷贝只针对引用类型 浅拷贝：对象中的简单类型拷贝值，复杂类型拷贝的是地址 常见方法： 1.拷贝对象：Object.assgin() / 展开运算符 {...obj} 拷贝对象 2.拷贝数组：Array.prototype.concat() 或者 [...arr] 12345678910111213141516171819202122const obj = &#123; uname: &#x27;pink&#x27;, age: 18, family: &#123; baby: &#x27;小pink&#x27; &#125; &#125; // 1.浅拷贝(展开运算符) // const o = &#123;...obj&#125; // console.log(o) // o.age = 20 // console.log(o) // console.log(obj) // 2.浅拷贝(assign) const o = &#123;&#125; Object.assign(o, obj) o.age = 20 // 浅拷贝拷贝的是地址 适合用于简单数据类型 //o.family.baby = &#x27;老pink&#x27; console.log(o) console.log(obj) **直接赋值和浅拷贝有什么区别？** 1.直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址 2.浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝还会相互影响 **浅拷贝怎么理解？** 1.拷贝对象之后，里面的属性值是简单数据类型直接拷贝值 2.如果属性值是引用数据类型则拷贝的是地址 #### 9.2 深拷贝 首先浅拷贝和深拷贝只针对引用类型 深拷贝：拷贝的是对象，不是地址 常见方法： 1.通过递归实现深拷贝 2.lodash/cloneDeep 3.通过JSON.stringify()实现 ##### 9.2.1 通过递归实现深拷贝 函数递归： 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 1.简单理解:函数内部自己调用自己, 这个函数就是递归函数 2.递归函数的作用和循环效果类似 3.由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return 1234567891011let i = 1 // 递归函数 自己调用自己 function fn() &#123; console.log(`这是第$&#123;i&#125;次`) if (i &gt;= 6) &#123; return &#125; i++ fn() &#125; fn() 123456// 用递归函数 模拟setInterval效果 function getTime() &#123; document.querySelector(&#x27;div&#x27;).innerHTML = new Date().toLocaleString() setTimeout(getTime, 1000) &#125; getTime() 123456789101112131415161718192021222324252627282930//数组拷贝const obj = &#123; uname: &#x27;熊大&#x27;, age: 10, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] &#125; const o = &#123;&#125; // 拷贝数组 function deepClone(newObj, oldObj) &#123; for (let k in oldObj) &#123; // 处理数组问题 // 检测类似是不是数组 if (oldObj[k] instanceof Array) &#123; // 把数组 hobby 里的内容再次遍历 可以使用递归自己调用自己 newObj[k] = [] // newObj[k] 是新数组里的值 oldObj[k]是旧数组里的值 === [&#x27;乒乓球&#x27;, &#x27;足球&#x27;] // 把旧数组的值传进去遍历给新数组 deepClone(newObj[k],oldObj[k]) &#125; else &#123; // k 表示属性名 uname oldObj[k] 表示属性值 10 // newObj[k] === o.name newObj[k] = oldObj[k] &#125; &#125; &#125; deepClone(o, obj) console.log(o) o.age = 20 o.hobby[0] = &#x27;篮球&#x27; console.log(obj) ##### 9.2.2 lodash/cloneDeep js库lodash里面cloneDeep内部实现了深拷贝 123456789101112131415&lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const obj = &#123; uname: &#x27;熊大&#x27;, age: 10, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小熊&#x27; &#125; &#125; //_.cloneDeep(要被克隆的对象) const o = _.cloneDeep(obj) console.log(o) o.family.baby = &#x27;大熊&#x27; console.log(obj) ##### 9.2.3 通过JSON.stringify()实现 利用JSON字符串转换 1234567891011121314const obj = &#123; uname: &#x27;熊大&#x27;, age: 10, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小熊&#x27; &#125; &#125; // 把对象转换为 JSON 字符串 拿到的全是字符串 // JSON.stringify(obj) const o = JSON.parse(JSON.stringify(obj)) console.log(o) o.family.baby = &#x27;123&#x27; console.log(obj) ### 10-异常处理 #### 10.1 throw 抛异常 异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行 1.throw 抛出异常信息，程序也会终止执行 2.throw 后面跟的是错误提示信息 3.Error 对象配合 throw 使用，能够设置更详细的错误信息 12345678function fn(x, y) &#123; if (!x || !y) &#123; // throw &#x27;用户没有传递参数进来&#x27; throw new Error(&#x27;没有参数传递进来&#x27;) &#125; return x + y &#125; console.log(fn()) #### 10.2 try /catch 捕获异常 我们可以通过try / catch 捕获错误信息（浏览器提供的错误信息） try 试试 catch 拦住 finally 最后 1.try...catch 用于捕获错误信息 2.将预估可能发生错误的代码写在 try 代码段中 3.如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 4.finally 不管是否有错误，都会执行 123456789101112131415161718function fn() &#123; try &#123; const p = document.querySelector(&#x27;.p&#x27;) p.style.color = &#x27;red&#x27; &#125; catch (err) &#123; // 拦截错误信息，不中断 console.log(err.message) throw new Error(&#x27;错误&#x27;) // 需要加 return 中断程序 // return &#125; finally &#123; // 不管你的程序对不对,一定会执行的代码 alert(&#x27;弹出对话框&#x27;) &#125; console.log(11) &#125; fn() #### 10.3 debugger 代码中的断点 ![debugger](E:\\能放\\前端\\截图\\js进阶\\debugger.png) ### \u000111-处理this #### 11.1 this指向 ##### 11.1.1 this指向-普通函数 普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】 12345678910111213141516171819202122&lt;button&gt;按钮&lt;/button&gt; &lt;script&gt; // 普通函数 this 谁调用指向谁 // 严格模式下 this 指向 undefined console.log(this) //window function fn() &#123; console.log(this) //window &#125; // window.fn() fn() window.setInterval(function () &#123; console.log(this) //window &#125;, 1000) document.querySelector(&#x27;button&#x27;).addEventListener(&#x27;click&#x27;, function () &#123; console.log(this) //button &#125;) const obj = &#123; sayHi: function () &#123; console.log(this) //obj &#125; &#125; obj.sayHi() 普通函数没有明确调用者时 this 值为 window，严格模式('use strict')下没有调用者时 this 的值为 undefined ##### 11.1.2 this指向-箭头函数 **箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！** 1.箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的 2.箭头函数中的this引用的就是最近作用域中的this 3.向外层作用域中，一层一层查找this，直到有this的定义 注意情况： 1.在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window,因此DOM事件回调函数如果里面需要DOM对象的this，则不推荐使用箭头函数 2.同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数 总结： 1.函数内不存在this，沿用上一级的 2.不适用 构造函数，原型函数，dom事件函数等等 3.适用 需要使用上层this的地方 #### 11.2 改变this JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向 ##### 11.2.1 call() 1语法： fun.call(thisArg, arg1, arg2, ...) 1.thisArg：在 fun 函数运行时指定的 this 值 2.arg1，arg2：传递的其他参数 3.返回值就是函数的返回值，因为它就是调用函数 123456789101112const obj = &#123; uname: &#x27;张三&#x27; &#125; function fn(x, y) &#123; console.log(this) console.log(x + y) &#125; // 1.调用函数 // 2.改变 this // 3.传递普通参数 fn.call(obj, 1, 2) // 返回值就是函数的返回值 ##### 11.2.2 apply() 使用 apply 方法调用函数，同时指定被调用函数中 this 的值 1语法：fun.apply(thisArg, [argsArray]) thisArg：在fun函数运行时指定的 this 值 argsArray：传递的值，必须包含在数组里面 返回值就是函数的返回值，因为它就是调用函数 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值 1234567891011121314151617181920212223242526272829const obj = &#123; age: 18 &#125; function fn(x, y) &#123; console.log(this) console.log(x + y) &#125; // 1.调用函数 // 2.改变this指向 // 3.传递数组 // fn.apply(this指向谁, 数组参数) fn.apply(obj, [1, 2]) // 返回值就是函数的返回值 // 使用场景：求数组最大值 // const max = Math.max(1,2,3) // console.log(max) const arr = [100, 200, 300] const max = Math.max.apply(Math, arr) const min = Math.min.apply(null, arr) console.log(max) console.log(min) // console.log(Math.max(...arr)) ##### 11.2.3 bind() bind() 方法不会调用函数。但是能改变函数内部this 指向 1语法：fun.bind(thisArg, arg1, arg2, ...) thisArg：在 fun 函数运行时指定的 this 值 arg1，arg2：传递的其他参数 返回由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数） 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的this指向 123456789101112131415161718192021222324252627&lt;button&gt;发送&lt;/button&gt; &lt;script&gt; const obj = &#123; age: 18 &#125; function fn() &#123; console.log(this) &#125; // 1.bind 不会调用函数 // 2.改变this指向 // 3.返回值是个函数，但是这个函数里面的this是更改过的obj const fun = fn.bind(obj) // console.log(fun) fun() // 需求： 点击按钮禁用 两秒后开启 const btn = document.querySelector(&#x27;button&#x27;) btn.addEventListener(&#x27;click&#x27;, function () &#123; // 禁用 this.disabled = true setTimeout(function () &#123; // 让this由原来的window 指向btn this.disabled = false &#125;.bind(this), 2000) &#125;) ##### call apply bind 总结 相同点: 都可以改变函数内部的this指向. 区别点: 1.call 和 apply 会调用函数, 并且改变函数内部this指向. 2.call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式[arg] 3.bind 不会调用函数, 可以改变函数内部this指向. 主要应用场景: 1.call 调用函数并且可以传递参数 2.apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 3.bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向 ### 12-性能优化 #### 12.1 节流（throttle） 所谓节流，就是指事件触发后，在 n 秒后执行这个事件的处理函数。如果n秒内连续触发事件，则忽略不执行 开发使用场景 – 小米轮播图点击效果 、 鼠标移动、页面尺寸缩放resize、滚动条滚动 就可以加节流 假如一张轮播图完成切换需要300ms， 不加节流效果，快速点击，则嗖嗖嗖的切换 加上节流效果， 不管快速点击多少次， 300ms时间内，只能切换一张图片。 1234567891011121314151617181920212223242526272829303132333435//要求： 鼠标在盒子上移动，里面的数字就会变化+1//如果以前方式，每次鼠标移动就会有大量操作，触发频次太高//利用节流的方式， 鼠标经过，500ms ，数字才显示&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 function mouseMove() &#123; box.innerHTML = i++ // 如果里面存在大量操作dom 的情况，可能卡顿 &#125; // 节流函数 throttle(函数,时间) // mouseMove 传给 fn , 500 传给 t function throttle(fn, t) &#123; // 页面打开的起始时间 let startTime = 0 // return function () &#123; // console.log(i) // &#125; return function()&#123; // 得到当前的时间戳 let now = Date.now() // 移动后的时间 - 刚开始移动的时间 &gt;= 500ms 我才去执行 mouseMove函数 // 进行判断 如果大于等于 500ms，则执行函数 if(now - startTime &gt;= t)&#123; // 调用函数 fn() // 让起始时间 = 现在的时间 startTime = now &#125; &#125; &#125; // box.addEventListener(&#x27;mousemove&#x27;, throttle(mouseMove,500)) // throttle(mousemove, 500) === function()&#123;console.log(i)&#125; box.addEventListener(&#x27;mousemove&#x27;, throttle(mouseMove,500)) #### 12.2 防抖（debounce） **所谓防抖，就是指触发事件后在 n 秒后执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间** 举例： 北京买房政策：需要连续5年的社保，如果中间有一年断了社保，则需要从新开始计算 比如，我 2020年开始计算，连续交5年，也就是到2024年可以买房了，包含2020年 但是我 2024年断社保了，整年没交，则需要从2025年开始算第一年往后推5年… 也就是 2029年才能买房… **开发使用场景- 搜索框防抖** 假设输入就可以发送请求，但是不能每次输入都去发送请求，输入比较快发送请求会比较多 我们设定一个时间，假如300ms， 当输入第一个字符时候，300ms后发送请求，但是在200ms的时候又输入了一个字符， 则需要再等300ms 后发送请求 123456789101112131415161718192021&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 function mouseMove() &#123; box.innerHTML = i++ // 如果里面存在大量操作dom 的情况，可能卡顿 &#125; // 防抖函数 function debounce(fn, t) &#123; let timeId return function () &#123; // 如果有定时器就清除 if (timeId) clearTimeout(timeId) // 开启定时器 timeId = setTimeout(function () &#123; fn() &#125;, t) &#125; &#125; box.addEventListener(&#x27;mousemove&#x27;, debounce(mouseMove, 200)) #### 12.3 Lodash 库 实现节流和防抖 1234567891011121314&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const box = document.querySelector(&#x27;.box&#x27;) let i = 1 // 鼠标移动函数 function mouseMove() &#123; box.innerHTML = i++ // 如果里面存在大量操作dom 的情况，可能卡顿 &#125; // lodash 节流 // box.addEventListener(&#x27;mousemove&#x27;, _.throttle(mouseMove, 500)) // lodash 防抖 box.addEventListener(&#x27;mousemove&#x27;, _.debounce(mouseMove, 500)) #### 综合案例 需求：页面打开，可以记录上一次的视频播放位置 两个事件: ①：ontimeupdate 事件在视频/音频（audio/video）当前的播放位置发送改变时触发 ②：onloadeddata 事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频（audio/video）的下一帧时触发 谁需要节流？ ontimeupdate ， 触发频次太高了，我们可以设定 1秒钟触发一次 步骤： 1.在ontimeupdate事件触发的时候，每隔1秒钟，就记录当前时间到本地存储 2.下次打开页面， onloadeddata 事件触发，就可以从本地存储取出时间，让视频从取出的时间播放，如果没有就默认为0s 3.获得当前时间 video.currentTime 123456789101112// 获取元素 对视频进行操作 const video = document.querySelector(&#x27;video&#x27;) // ontimeupdate 当前的播放位置发生改变是触发 video.ontimeupdate = _.throttle(() =&gt; &#123; // console.log(video.currentTime) //获得当前的视频时间 // 把当前时间存储到本地存储 localStorage.setItem(&#x27;currentTime&#x27;, video.currentTime) &#125;, 1000) // 打开页面触发事件，从本地存储里面取出记录的时间，赋值给 video.currentTime video.onloadeddata = () =&gt; &#123; video.currentTime = localStorage.getItem(&#x27;currentTime&#x27;) || 0 &#125;","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"初识（一）","slug":"CSS","date":"2022-11-06T03:27:06.000Z","updated":"2022-11-06T03:36:25.548Z","comments":true,"path":"2022/11/06/CSS/","link":"","permalink":"http://example.com/2022/11/06/CSS/","excerpt":"","text":"CSS一、基础认知认识网页（了解）➢ 问题1：网页由哪些部分组成？ ✓ 文字、图片、音频、视频、超链接 ➢ 问题2：我们看到的网页背后本质是什么？ ✓ 前端程序员写的代码 ➢ 问题3：前端的代码是通过什么软件转换成用户眼中的页面的？ ✓ 通过浏览器转化（解析和渲染）成用户看到的网页. 123display: flex;justify-content: space-between; //子元素靠边对齐平均分剩余的空间 两端贴边对齐align-items: center; //纵向居中 五大浏览器➢ 浏览器：是网页显示、运行的平台，是前端开发必备利器 ➢ 常见的五大浏览器： IE浏览器、火狐浏览器（Firefox）、谷歌浏览器（Chrome）、Safari浏览器、欧朋浏览器（Opera） 渲染引擎（了解）渲染引擎（浏览器内核）：浏览器中专门对代码进行解析渲染的部分 ➢ 浏览器出品的公司不同，内在的渲染引擎也是不同的： ➢ 注意点： • 渲染引擎不同，导致解析相同代码时的 速度、性能、效果也不同的 • 谷歌浏览器的渲染引擎速度快、性能高、效果好，所以更吸引用户的喜爱（推荐） 小结五大浏览器有哪些？ • IE浏览器 • 火狐浏览器（Firefox） • 谷歌浏览器（Chrome） • Safari浏览器 • 欧朋浏览器（Opera） ➢ 相同的网页在不同浏览器中显示效果会完全一致吗？ • 因为不同浏览器渲染引擎不同，解析的效果会存在差异 ➢ 前端工程师日常推荐使用哪一个浏览器？ • 谷歌浏览器（Chrome） Web标准的构成Web标准中分成三个构成： HTML的概念➢ HTML（Hyper Text Markup Language）中文译为：超文本标记语言 ➢ 专门用于网页开发的语言，主要通过HTML标签对网页中的文本、图片、音频、视频等内容进行描述 ➢ 案例：文字变粗案例 ➢ 体验构建一个网页，需要在网页中显示一个加粗的文字 **** 小结HTML骨架结构由哪些标签组成？ • html标签：网页的整体 • head标签：网页的头部 • body标签：网页的身体 • title标签：网页的标题 12345678const name = &#x27;熊大&#x27;const age = 10const sex = &#x27;男&#x27;export default &#123; name, age,&#125; 二、基础标签p标签：段落之间存在间隙，独占一行** br标签：单标签 换行 hr标签：单标签 在页面中显示一条水平线 strong &#x2F; b 标签： 加粗 ins &#x2F; u 标签：下划线 em &#x2F; i 标签：倾斜 del &#x2F; s 标签：删除线 img 标签：单标签 img标签需要展示对应的效果，需要借助标签的属性进行设置 图片标签的src属性：目标图片的路径 图片标签的alt属性：替换文本 当图片加载失败时，才显示alt的文本 图片标签的title属性：提示文本 当鼠标悬停时，才显示的文本 图片标签的width和height属性：宽度和高度 绝对路径：指目录下的绝对位置，可直接到达目标位置，通常从盘符开始的路径 例如： 盘符开头：D:\\day01\\images\\1.jpg 完整的网络地址：https://www.itcast.cn/2018czgw/images/logo.gif（了解） 相对路径（常用）：从当前文件开始出发找目标文件的过程 audio标签：音频标签 音频标签src属性：音频的路径 音频标签controls属性：显示播放的控件 音频标签autoplay属性：自动播放 音频标签loop属性：循环播放 音频标签目前支持三种格式：MP3、Wav、Ogg video标签：视频标签 视频标签src属性：音频的路径 视频标签controls属性：显示播放的控件 视频标签autoplay属性：自动播放 视频标签loop属性：循环播放 视频标签目前支持三种格式：MP4 、WebM 、Ogg a标签：双标签，内部可以包裹内容 如果需要a标签点击之后去指定页面，需要设置a标签的href属性 链接标签的target属性： 取值1：_self 默认值，在当前窗口跳转 取值2：_blank 在新窗口中跳转 列表标签ul标签：表示无序列表的整体，用于包裹li标签 ，ul标签中只允许包含li标签，列表的每一项前默认显示圆点标识 li标签：表示无序列表的每一项，用于包含每一行的内容，li标签可以包含任意内容 ol标签：表示有序列表的整体，用于包含li标签，ol标签中只允许包含li标签，列表的每一项前默认显示序号标识 li标签：表示有序列表的每一项，用于包含每一行的内容，li标签可以包含任意内容 dl标签：表示自定义列表标签，用于包裹dt&#x2F;dd标签 dt标签：表示自定义列表的主题，dd前会默认显示缩进效果 dd标签：表示自定义列表的针对主题的每一项内容 表格标签table：表格整体，用于包裹多个tr tr：表格每行，用于包裹td td：表格单元格，用于包裹内容 注意：标签的嵌套关系：table &gt; tr &gt; td \u0007caption：表示表格整体大标签，默认在表格整体 顶部居中位置显示 th：表示一列小标题，通常用于表格第一行，默认内部文字加粗并居中显示 注意：caption标签书写在table标签内部，th标签书写在tr标签内部（用于替换td标签）。 表格的结构标签： thead：表格头部 tbody：表格主体 tfoot：表格底部。 rowspan：跨行合并，将多行的单元格垂直合并 colspan：跨列合并，将多列的单元格水平合并 注意：只有同一个结构标签中的单元格才能合并，不能跨结构标签合并（不能跨：thead、tbody、tfoot） \u0001表单标签input系列标签 ​ 属性名： text ：文本框 placeholder：占位符 ​ password：密码框 placeholder：占位符 ​ radio：单选框 ​ checkbox：多选框 ​ file：文件选择 multiple：多文件选择 ​ submit：提交按钮 ​ reset：重置按钮 ​ button：按钮 ​ 如果需要实现以上按钮功能，需要配合form标签使用 ​ form使用方法：用form标签把表单标签一起包裹起来即可 button按钮标签 ​ 属性名：submit：提交按钮 ​ reset：重置按钮 ​ button：按钮 select下拉菜单标签 option标签：下拉菜单的每一项 selected：下拉菜单的默认选中 textarea文本域标签 ​ 属性：cols：规定了文本域内可见宽度 ​ rows：规定了文本域内可见行数 label标签：绑定内容与表单标签的关系 语义化标签div标签：一行只显示一个（独占一行） span标签：一行可以显示多个 header：网页头部 nav：网页导航 footer：网页底部 aside：网页侧边栏 section：网页区块 article：网页文章 常见字符实体&amp;nbsp：空格 &amp;gt：&gt; &amp;lt：&lt; 三、css属性link标签引入 color：文字颜色 12345678910111213141516171819202122232425262728293031323334353637常见颜色取值：• red：红色• green：绿色• blue：蓝色• yellow：黄色• orange：橘色• skyblue：天蓝色• pink：粉色rgb表示法➢ 每项取值范围：0~255➢ 常见颜色取值：• rgb ( 255 , 0 , 0 ) ：红色• rgb ( 0 , 255 , 0 ) ：绿色• rgb ( 0 , 0 , 255 ) ：蓝色• rgb ( 0 , 0 , 0 ) ：黑色• rgb ( 255 , 255 , 255 ) ：白色rgba表示法• 其实，比rgb表示法多个一个a，a表示透明度➢ a的取值范围：0~1• 1：完全不透明• 0：完全透明➢ 省略写法：• rgba ( 0 , 0 , 0 , 0.5 ) 可以省略写成 rgba ( 0 , 0 , 0 , .5 )十六进制表示法➢ 取值范围：• 两个数字为一组，每个数字的取值范围：0~9 , a , b , c , d , e , f➢ 省略写法：• 如果三组中，每组数字都相同，此时可以每组可以省略只写一个数字• 正确写法：#ffaabb 改写成 #fab➢ 常见取值：• #fff ：白色• #000 ：黑色➢ 注意点1. 类似于：#ffaabc 不能改写成 #fabc font-size：字体大小 background-color：背景颜色 width：宽度 height：高度 标签选择器 结构：标签名 { css属性名：属性值； } 类选择器 .类名 { css属性名：属性值； } id选择器 id属性值 { css属性名：属性值； } 通配符选择器 *{ css属性名：属性值； } 字体样式 字体大小：font-size 取值：数字 + px 字体粗细：font-weight 取值：正常normal&#x2F;400 加粗bold&#x2F;700 字体样式：font-style 取值：正常normal 倾斜italic 字体类型：font-family 具体字体：”Microsoft YaHei”、微软雅黑、黑体、宋体、楷体等 文本样式 文本缩进：text-indent 取值：数字 + px 文本水平对齐方式：text-align 取值：left左对齐、center居中对齐、right右对齐 文本修饰：text-decoration 取值：underline下划线、line-through删除线、overline上划线、none无装饰 开发中会使用 text-decoration : none ; 清除a标签默认的下划线 line-height行高 取值：数字+px 让单行文本垂直居中可以设置 line-height : 文字父元素高度 网页精准布局时，会设置 line-height : 1 可以取消上下间距 ​ 4.文字阴影:text-shadow ​ 取值：h-shadow (必填,水平偏移量) v-shadow(必填,垂直偏移量) ​ blur(可选,模糊度) color(可选,阴影颜色) ​ 取值之间以逗号隔开 ​ 5.盒子阴影：box-shadow ​ \u0001取值：h-shadow (必填,水平偏移量) v-shadow(必填,垂直偏移量) ​ \u0011blur(可选,模糊度) color(可选,阴影颜色) spread(可选,阴影扩大) inset(可选,将阴影改为内部阴影) 选择器后代选择器：空格选择器语法：选择器1 选择器2 { css } \u0001作用：根据 HTML 标签的嵌套关系，选择父元素 后代中 满足条件的元素 子代选择器：&gt;选择器语法：选择器1 &gt; 选择器2 { css } 作用：根据 HTML 标签的嵌套关系，选择父元素 子代中 满足条件的元素 并集选择器：,选择器语法：选择器1 ， 选择器2 { css } 作用：同时选择多组标签，设置相同的样式 交集选择器：紧挨着选择器语法：选择器1选择器2 { css } 作用：选中页面中 同时满足 多个选择器的标签 hover伪类选择器选择器语法：选择器:hover { css } \u0006作用：选中鼠标悬停在元素上的状态，设置样式 背景相关属性背景颜色属性名：background-color（bgc） 属性值：颜色取值：关键字、rgb表示法、rgba表示法、十六进制 透明：rgba(0,0,0,0)、transparent 背景图片属性名：background-image（bgi） 属性值：url(‘图片路径’) 背景平铺属性名：background-repeat（bgr） 属性值：repeat 默认值水平和垂直都平铺 no-repeat：不平铺 repeat-x：水平方向平铺 repeat-y：垂直方向平铺 背景位置属性名：background-position（bgp） 属性值：background-position：水平方向位置 垂直方向位置 注意：方位名词取值和坐标取值可以混使用，第一个取值表示水平，第二个取值表示垂直 方位名称：水平方向 left、center、right 垂直方向top、center、bottom 坐标：(x,y) 背景图片大小语法：background-size：宽度 高度； 属性名：background-size 属性值： 数字+px 百分比% contain(包含,将背景图片等比例缩放,直到不会超出盒子的最大) cover(覆盖,将背景图片等比例缩放,直到刚好填满整个盒子没有空白) 元素显示模式块级元素(block)：独占一行（一行只能显示一个）宽度默认是父元素的宽度，高度默认由内容撑开，可以设置宽高 代表标签：div、p、h系列、ul、li、dl、dt、dd、form、header、nav、footer **行内元素(inline)**：一行可以显示多个，宽度和高度默认由内容撑开，不可以设置宽高 代表标签：a、span 、b、u、i、s、strong、ins、em、del **行内块元素(inline-block)**：一行可以显示多个，可以设置宽高 代表标签：input、textarea、button、select 元素显示模式转换转换成块级元素 display:block 转换成行内元素 display：inline 转换成行内块元素 display：inline-block css选择器优先级：不同选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低选择器样式 优先级公式：继承 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important 盒子模型CSS 中规定每个盒子分别由：内容区域（content）、内边距区域（padding）、边框区域（border）、 外边距区域（margin）构成，这就是 盒子模型 边框（border）- 单个属性\u0001 border-width：数字+px 边框粗细 ​ border-style： solid(实线)、dashed(虚线)、dotted(点线) ​ border-color： 颜色取值 边框（border）- 连写形式：border : 10px solid red内边距（padding）-设置 边框 与 内容区域 之间的距离 自动内减：给盒子设置属性 box-sizing : border-box ; 浏览器会自动计算多余大小，自动在内容中减去 外边距（margin）-设置边框以外，盒子与盒子之间的距离外边距折叠现象 – ① 合并现象➢ 场景：垂直布局 的 块级元素，上下的margin会合并 ➢ 结果：最终两者距离为margin的最大值 ➢ 解决方法：避免就好 • 只给其中一个盒子设置margin即可 外边距折叠现象 – ② 塌陷现象➢ 场景：互相嵌套 的 块级元素，子元素的 margin-top 会作用在父元素上 ➢ 结果：导致父元素一起往下移动 ➢ 解决方法： 给父元素设置border-top 或者 padding-top（分隔父子元素的margin-top） 给父元素设置overflow：hidden 转换成行内块元素 设置浮动 结构伪类选择器E.first-child { } 匹配父元素中第一个子元素 E.last-child { } 匹配父元素中最后一个子元素 E.nth-child(n) { } 匹配父元素中第n个子元素 E.nth-last-child(n) { } 匹配父元素中倒数第n个子元素 E.nth-of-type(n) { } 只在父元素的同类型(E)子元素范围中，匹配第n个 区别： • :nth-child → 直接在所有孩子中数个数 • :nth-of-type → 先通过该 类型 找到符合的一堆子元素，然后在这一堆子元素中数个数 伪元素伪元素：一般页面中的非主体内容可以使用伪元素 ➢ 区别： 元素：HTML 设置的标签 伪元素：由 CSS 模拟出的标签效果 ::before 在父元素内容的最前面添加一个伪元素 ::after 在父元素内容的最后面添加一个伪元素 注意点： 必须设置content属性才能生效 伪元素默认是行内元素 浮动float:left&#x2F;right 浮动的特点 浮动元素会脱标，在标准流中不占位置 浮动元素比标准流高出半个级别，可以覆盖标准流中的元素 浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动 浮动元素有特殊的显示效果：① 一行可以显示多个 ② 可以设置宽高 注意点：浮动的元素不能通过text-align:center或者margin:0 auto 清除浮动如果子元素浮动了，此时子元素不能撑开标准流的块级父元素 原因： • 子元素浮动后脱标 → 不占位置 ➢ 目的： • 需要父元素有高度，从而不影响其他网页元素的布局 清除浮动的方法 — ① 直接设置父元素高度 缺点：有些布局中不能固定父元素高度。如：新闻列表、京东推荐模块 清除浮动的方法 — ② 额外标签法 操作： 在父元素内容的最后添加一个块级元素 给添加的块级元素设置 clear:both 缺点：会在页面中添加额外的标签，会让页面的HTML结构变得复杂 清除浮动的方法 — ③ 单伪元素清除法 12345678.clearfix::after &#123; content: &#x27;&#x27;; display: block; clear: both; /*补充代码：在网页中看不到伪元素*/ height: 0; visibility: hidden;&#125; 清除浮动的方法 — ④ 双伪元素清除法1234567.clearfix::before,.clearfix::after &#123; content: &#x27;&#x27;; display: table;&#125;.clearfix::after &#123; clear: both;&#125; BFC的介绍➢ 块格式化上下文（Block Formatting Context）：BFC • 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 ➢ 创建BFC方法： html标签是BFC盒子 浮动元素是BFC盒子 行内块元素是BFC盒子 overflow属性取值不为visible。如：auto、hidden… ➢ BFC盒子常见特点： BFC盒子会默认包裹住内部子元素（标准流、浮动）→ 应用：清除浮动 BFC盒子本身与子元素之间不存在margin的塌陷现象 → 应用：解决margin的塌陷 定位 可以让元素自由的摆放在网页的任意位置 一般用于 盒子之间的层叠情况 属性名：position 属性值：static(默认：静态定位)、relative(相对定位)、absolute(绝对定位)、固定定位(fixed) 相对定位 position:relative 相对于自己原来位置进行移动，在页面中占位置 → 没有脱标 绝对定位 position:absolute 相对于非静态定位的父元素进行定位移动(默认相对于浏览器可视区域进行移动) 在页面中不占位置 → 已经脱标 子绝父相水平垂直都居中案例 子绝父相 让子盒子往右走大盒子一半 • left:50% 让子盒子往下走大盒子一半 • top:50% 让子盒子往左+往上走自己的一半 • transform:translate(-50%,-50%); 固定定位 position:fixed 相对于浏览器进行定位移动 在页面中不占位置 → 已经脱标 装饰垂直对齐方式属性名:vertical-align 属性值:baseline(默认基线对齐)&#x2F;top(顶部对齐)&#x2F;middle(中部对齐)&#x2F;bottom(底部对齐) 项目中 vertical-align 可以解决的问题 文本框和表单按钮无法对齐问题 input和img无法对齐问题 div中的文本框，文本框无法贴顶问题 div不设高度由img标签撑开，此时img标签下面会存在额外间隙问题 使用line-height让img标签垂直居中问题 光标类型属性名:cursor 设置鼠标光标在元素上时显示的样式 属性值: default(默认值,通常是箭头) pointer(小手效果,提示用户可以点击) text(工字型,提示用户可以选择文字) move(十字光标,提示用户可以移动) 边框圆角属性名：border-radius ➢ 画一个正圆： 盒子必须是正方形 设置边框圆角为盒子宽高的一半 → border-radius:50% ➢ 胶囊按钮： 盒子要求是长方形 设置 → border-radius：盒子高度的一半 溢出部分显示效果溢出部分：指的是盒子 内容部分 所超出盒子范围的区域 属性名：overflow \u0001属性值： visible(默认值：溢出部分可见) hidden(溢出部分隐藏) scroll(无论是否溢出,都显示滚动条) auto(根据是否溢出,自动显示或隐藏滚动条) 元素本身隐藏➢ 场景：让某元素本身在屏幕中不可见。如：鼠标:hover之后元素隐藏 ➢ 常见属性： visibility:hidden display:none ➢ 区别： visibility:hidden 隐藏元素本身，并且在网页中 占位置 display:none 隐藏元素本身，并且在网页中 不占位置 ➢ 注意点： • 开发中经常会通过 display属性完成元素的显示隐藏切换 • display:none;（隐藏）、 display:block;（显示） 元素整体透明度➢ 场景：让某元素整体（包括内容）一起变透明 ➢ 属性名：opacity ➢ 属性值：0~1之间的数字 • 1：表示完全不透明 • 0：表示完全透明 ➢ 注意点： • opacity会让元素整体透明，包括里面的内容，如：文字、子元素等 边框合并➢ 场景：让相邻表格边框进行合并，得到细线边框效果 ➢ 代码：border-collapse:collapse; 用CSS画三角形的步骤 设置一个盒子 设置四周不同颜色的边框 将盒子宽高设置为0，仅保留边框 得到四个三角形，选择其中一个后，其他三角形（边框）设置颜色为透明 过渡属性名：transition 过渡的属性：all(所有属性过渡)、具体属性名如width(只有width有过渡) 过渡的时长：数字+s(秒) Ø 注意点： 过渡需要：默认状态 和 hover状态样式不同，才能有过渡效果 transition属性给需要过渡的元素本身加 transition属性设置在不同状态中，效果不同的 ① 给默认状态设置，鼠标移入移出都有过渡效果 ② 给hover状态设置，鼠标移入有过渡效果，移出没有过渡效果 选择器拓展链接伪类选择器场景：常用于选中超链接的不同状态 选择器语法： a:link { } 选中a链接 未访问过 的状态 a:visited { } 选中a链接 访问之后 的状态 a:hover { } 选中 鼠标悬停 的状态 a:active { } 选中 鼠标按下 的状态 焦点伪类选择器场景：用于选中元素获取焦点时状态，常用于表单控件 选择器语法：:focus { } 1234input:focus &#123; background-color: red&#125;// 表单控件获取焦点时默认会显示外部轮廓线 属性选择器场景：通过元素上的HTML属性来选择元素，常用于选择 input 标签 选中页面中所有的文本框 input[type&#x3D;”text”] { } 精灵图 创建一个盒子 通过PxCook量取小图片大小，将小图片的宽高设置给盒子 将精灵图设置为盒子的背景图片 通过PxCook测量小图片左上角坐标，分别取负值设置给盒子的background-position：x y 版心12345.container &#123; width: 1240px; margin: 0 auto;&#125;/*版心类名常用：container、wrapper、w*/ CSS书写顺序1.布局属性：display、position、float、clear、visibility、overflow 2.盒子模型+背景：width、height、margin、padding、border 3.文本内容属性：color、font、text-decoration、text-align、line-height 4.点缀属性：cursor、border-radius、text-shadow、box-shadow 注意点： • 开发中推荐多用类 + 后代，但不是层级越多越好，一个选择器中的类选择器的个数推荐 不要超过 3 个","categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-11-05T08:24:20.768Z","updated":"2022-11-05T08:24:20.768Z","comments":true,"path":"2022/11/05/hello-world/","link":"","permalink":"http://example.com/2022/11/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"资料","slug":"资料","permalink":"http://example.com/categories/%E8%B5%84%E6%96%99/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"http://example.com/tags/uni-app/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://example.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"Vue基础","slug":"Vue基础","permalink":"http://example.com/tags/Vue%E5%9F%BA%E7%A1%80/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"Ajax","slug":"Ajax","permalink":"http://example.com/tags/Ajax/"},{"name":"Web Api","slug":"Web-Api","permalink":"http://example.com/tags/Web-Api/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]}